package ebpftracer

import (
	"errors"
	"net/netip"
	"testing"
	"time"

	"github.com/castai/kvisor/pkg/ebpftracer/decoder"
	"github.com/castai/kvisor/pkg/ebpftracer/events"
	"github.com/castai/kvisor/pkg/ebpftracer/types"
	"github.com/castai/kvisor/pkg/logging"
	"github.com/stretchr/testify/require"
)

func TestFilterAnd(t *testing.T) {
	errFilterFail := errors.New("")

	filterPass := GlobalEventFilterGenerator(
		func(event *types.Event) error {
			return FilterPass
		},
	)

	filterFail := GlobalEventFilterGenerator(
		func(event *types.Event) error {
			return errFilterFail
		},
	)

	type testCase struct {
		name     string
		filters  []EventFilterGenerator
		expected error
	}

	testCases := []testCase{
		{
			name:     "multiple filters all returning true should produce true",
			filters:  []EventFilterGenerator{filterPass, filterPass, filterPass},
			expected: FilterPass,
		},
		{
			name:     "multiple filter one returning false should produce false",
			filters:  []EventFilterGenerator{filterPass, filterPass, filterFail},
			expected: errFilterFail,
		},
		{
			name:     "single true filter should return true",
			filters:  []EventFilterGenerator{filterPass},
			expected: FilterPass,
		},
		{
			name:     "single false filter should return false",
			filters:  []EventFilterGenerator{filterFail},
			expected: errFilterFail,
		},
	}

	for _, testCase := range testCases {
		t.Run(testCase.name, func(t *testing.T) {
			combinedFilters := FilterAnd(testCase.filters...)()

			actual := combinedFilters(&types.Event{})

			require.Equal(t, testCase.expected, actual)
		})
	}
}

func TestDNSPolicyFilter(t *testing.T) {
	r := require.New(t)
	log := logging.NewTestLog()
	f := DeduplicateDNSEventsPreFilter(log, 2, 1*time.Hour)
	g := f()

	// Pass non dns event.
	args, err := g(&types.EventContext{EventID: events.Connect}, nil)
	r.NoError(err)
	r.Nil(args)

	var dnsPacket = []byte{
		// Args num and index.
		0x0, 0x0,

		// Payload size
		0xe4, 0x00, 0x00, 0x00,

		// IP header
		0x45, 0x00, 0x00, 0xe4, 0xb4, 0x0c, 0x40, 0x00, 0x3f, 0x11, 0x71, 0x44, 0x0a, 0x60, 0x00, 0x0a,
		0x0a, 0xf4, 0x00, 0x5b,

		// UDP header
		0x00, 0x35, 0xc5, 0x78, 0x00, 0xd0, 0x16, 0x9a,

		// DNS message
		0xc2, 0x3b, 0x81, 0x80, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x6f, 0x72, 0x66,
		0x02, 0x61, 0x74, 0x00, 0x00, 0x01, 0x00, 0x01, 0x03, 0x6f, 0x72, 0x66, 0x02, 0x61, 0x74, 0x00,
		0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x04, 0xc2, 0xe8, 0x68, 0x8e, 0x03, 0x6f,
		0x72, 0x66, 0x02, 0x61, 0x74, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x04,
		0xc2, 0xe8, 0x68, 0x96, 0x03, 0x6f, 0x72, 0x66, 0x02, 0x61, 0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x1e, 0x00, 0x04, 0xc2, 0xe8, 0x68, 0x8d, 0x03, 0x6f, 0x72, 0x66, 0x02, 0x61,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x04, 0xc2, 0xe8, 0x68, 0x04,
		0x03, 0x6f, 0x72, 0x66, 0x02, 0x61, 0x74, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1e,
		0x00, 0x04, 0xc2, 0xe8, 0x68, 0x8c, 0x03, 0x6f, 0x72, 0x66, 0x02, 0x61, 0x74, 0x00, 0x00, 0x01,
		0x00, 0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x04, 0xc2, 0xe8, 0x68, 0x95, 0x03, 0x6f, 0x72, 0x66,
		0x02, 0x61, 0x74, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x04, 0xc2, 0xe8,
		0x68, 0x8b, 0x03, 0x6f, 0x72, 0x66, 0x02, 0x61, 0x74, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x1e, 0x00, 0x04, 0xc2, 0xe8, 0x68, 0x03,
	}

	// Pass first dns event.
	args, err = g(&types.EventContext{EventID: events.NetPacketDNSBase}, decoder.NewEventDecoder(log, dnsPacket))
	r.NoError(err)

	// Should not pass since this is duplicate.
	args, err = g(&types.EventContext{EventID: events.NetPacketDNSBase}, decoder.NewEventDecoder(log, dnsPacket))
	r.ErrorIs(err, FilterErrDNSDuplicateDetected)
}

func TestRateLimitPrivateIP(t *testing.T) {
	f := RateLimitPrivateIP(RateLimitPolicy{
		Rate:  1,
		Burst: 1,
	})
	g := f()

	// Should not rate limit public IP.
	e := &types.Event{
		Context: &types.EventContext{EventID: events.SockSetState},
		Args: types.SockSetStateArgs{
			Tuple: types.AddrTuple{Dst: netip.MustParseAddrPort("140.3.2.1:7894")},
		},
	}
	for range 10 {
		if err := g(e); err != nil {
			t.Fatal(err)
		}
	}

	// Should rate limit private IP.
	e.Args = types.SockSetStateArgs{
		Tuple: types.AddrTuple{Dst: netip.MustParseAddrPort("10.0.0.1:7894")},
	}
	var err error
	for range 10 {
		err = g(e)
	}
	require.ErrorIs(t, err, FilterErrRateLimit)
}
