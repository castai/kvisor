// Code generated by tools/codegen; DO NOT EDIT.

package decoder

import (
  "errors"

  "github.com/castai/kvisor/pkg/ebpftracer/events"
  "github.com/castai/kvisor/pkg/ebpftracer/types"
	"github.com/castai/kvisor/pkg/logging"
)

var (
  ErrUnknownArgsType error = errors.New("unknown args type")
)

// eventMaxByteSliceBufferSize is used to determine the max slice size allowed for different
// event types. For example, most events have a max size of 4096, but for network related events
// there is no max size (this is represented as -1).
func eventMaxByteSliceBufferSize(id events.ID) int {
  // For non network event, we have a max byte slice size of 4096
  if id < events.NetPacketBase || id > events.MaxNetID {
    return 4096
  }

  // Network events do not have a max buffer size.
  return -1
}

func ParseReadArgs(log *logging.Logger, decoder *Decoder) (types.ReadArgs, error) {
  var result types.ReadArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ReadArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Read': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ReadArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.ReadArgs{}, err
      }
    case 1:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.ReadArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    case 2:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.ReadArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseWriteArgs(log *logging.Logger, decoder *Decoder) (types.WriteArgs, error) {
  var result types.WriteArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.WriteArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Write': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.WriteArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.WriteArgs{}, err
      }
    case 1:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.WriteArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    case 2:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.WriteArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseOpenArgs(log *logging.Logger, decoder *Decoder) (types.OpenArgs, error) {
  var result types.OpenArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OpenArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Open': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OpenArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.OpenArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.OpenArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.OpenArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseCloseArgs(log *logging.Logger, decoder *Decoder) (types.CloseArgs, error) {
  var result types.CloseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CloseArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Close': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CloseArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.CloseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseStatArgs(log *logging.Logger, decoder *Decoder) (types.StatArgs, error) {
  var result types.StatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.StatArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Stat': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.StatArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.StatArgs{}, err
      }
    case 1:
      var dataStatbuf uint64
      err = decoder.DecodeUint64(&dataStatbuf)
      if err != nil {
        return types.StatArgs{}, err
      }
      result.Statbuf = uintptr(dataStatbuf)
    }
  }
  return result, nil
}

func ParseFstatArgs(log *logging.Logger, decoder *Decoder) (types.FstatArgs, error) {
  var result types.FstatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FstatArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Fstat': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FstatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FstatArgs{}, err
      }
    case 1:
      var dataStatbuf uint64
      err = decoder.DecodeUint64(&dataStatbuf)
      if err != nil {
        return types.FstatArgs{}, err
      }
      result.Statbuf = uintptr(dataStatbuf)
    }
  }
  return result, nil
}

func ParseLstatArgs(log *logging.Logger, decoder *Decoder) (types.LstatArgs, error) {
  var result types.LstatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LstatArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Lstat': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LstatArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LstatArgs{}, err
      }
    case 1:
      var dataStatbuf uint64
      err = decoder.DecodeUint64(&dataStatbuf)
      if err != nil {
        return types.LstatArgs{}, err
      }
      result.Statbuf = uintptr(dataStatbuf)
    }
  }
  return result, nil
}

func ParsePollArgs(log *logging.Logger, decoder *Decoder) (types.PollArgs, error) {
  var result types.PollArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PollArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Poll': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PollArgs{}, err
    }

    switch currArg {
    case 0:
      var dataFds uint64
      err = decoder.DecodeUint64(&dataFds)
      if err != nil {
        return types.PollArgs{}, err
      }
      result.Fds = uintptr(dataFds)
    case 1:
      err = decoder.DecodeUint32(&result.Nfds)
      if err != nil {
        return types.PollArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Timeout)
      if err != nil {
        return types.PollArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseLseekArgs(log *logging.Logger, decoder *Decoder) (types.LseekArgs, error) {
  var result types.LseekArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LseekArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Lseek': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LseekArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.LseekArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Offset)
      if err != nil {
        return types.LseekArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Whence)
      if err != nil {
        return types.LseekArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMmapArgs(log *logging.Logger, decoder *Decoder) (types.MmapArgs, error) {
  var result types.MmapArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MmapArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Mmap': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MmapArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.MmapArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.MmapArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Prot)
      if err != nil {
        return types.MmapArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.MmapArgs{}, err
      }
    case 4:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.MmapArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint64(&result.Off)
      if err != nil {
        return types.MmapArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMprotectArgs(log *logging.Logger, decoder *Decoder) (types.MprotectArgs, error) {
  var result types.MprotectArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MprotectArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Mprotect': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MprotectArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.MprotectArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.MprotectArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Prot)
      if err != nil {
        return types.MprotectArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMunmapArgs(log *logging.Logger, decoder *Decoder) (types.MunmapArgs, error) {
  var result types.MunmapArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MunmapArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Munmap': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MunmapArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.MunmapArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.MunmapArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseBrkArgs(log *logging.Logger, decoder *Decoder) (types.BrkArgs, error) {
  var result types.BrkArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.BrkArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Brk': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.BrkArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.BrkArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    }
  }
  return result, nil
}

func ParseRtSigactionArgs(log *logging.Logger, decoder *Decoder) (types.RtSigactionArgs, error) {
  var result types.RtSigactionArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RtSigactionArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'RtSigaction': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RtSigactionArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Signum)
      if err != nil {
        return types.RtSigactionArgs{}, err
      }
    case 1:
      var dataAct uint64
      err = decoder.DecodeUint64(&dataAct)
      if err != nil {
        return types.RtSigactionArgs{}, err
      }
      result.Act = uintptr(dataAct)
    case 2:
      var dataOldact uint64
      err = decoder.DecodeUint64(&dataOldact)
      if err != nil {
        return types.RtSigactionArgs{}, err
      }
      result.Oldact = uintptr(dataOldact)
    case 3:
      err = decoder.DecodeUint64(&result.Sigsetsize)
      if err != nil {
        return types.RtSigactionArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRtSigprocmaskArgs(log *logging.Logger, decoder *Decoder) (types.RtSigprocmaskArgs, error) {
  var result types.RtSigprocmaskArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RtSigprocmaskArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'RtSigprocmask': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RtSigprocmaskArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.How)
      if err != nil {
        return types.RtSigprocmaskArgs{}, err
      }
    case 1:
      var dataSet uint64
      err = decoder.DecodeUint64(&dataSet)
      if err != nil {
        return types.RtSigprocmaskArgs{}, err
      }
      result.Set = uintptr(dataSet)
    case 2:
      var dataOldset uint64
      err = decoder.DecodeUint64(&dataOldset)
      if err != nil {
        return types.RtSigprocmaskArgs{}, err
      }
      result.Oldset = uintptr(dataOldset)
    case 3:
      err = decoder.DecodeUint64(&result.Sigsetsize)
      if err != nil {
        return types.RtSigprocmaskArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRtSigreturnArgs(log *logging.Logger, decoder *Decoder) (types.RtSigreturnArgs, error) {
  return types.RtSigreturnArgs{}, nil
}

func ParseIoctlArgs(log *logging.Logger, decoder *Decoder) (types.IoctlArgs, error) {
  var result types.IoctlArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoctlArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Ioctl': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoctlArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.IoctlArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Request)
      if err != nil {
        return types.IoctlArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Arg)
      if err != nil {
        return types.IoctlArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePread64Args(log *logging.Logger, decoder *Decoder) (types.Pread64Args, error) {
  var result types.Pread64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Pread64Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Pread64': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Pread64Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Pread64Args{}, err
      }
    case 1:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.Pread64Args{}, err
      }
      result.Buf = uintptr(dataBuf)
    case 2:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.Pread64Args{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Offset)
      if err != nil {
        return types.Pread64Args{}, err
      }
    }
  }
  return result, nil
}

func ParsePwrite64Args(log *logging.Logger, decoder *Decoder) (types.Pwrite64Args, error) {
  var result types.Pwrite64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Pwrite64Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Pwrite64': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Pwrite64Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Pwrite64Args{}, err
      }
    case 1:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.Pwrite64Args{}, err
      }
      result.Buf = uintptr(dataBuf)
    case 2:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.Pwrite64Args{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Offset)
      if err != nil {
        return types.Pwrite64Args{}, err
      }
    }
  }
  return result, nil
}

func ParseReadvArgs(log *logging.Logger, decoder *Decoder) (types.ReadvArgs, error) {
  var result types.ReadvArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ReadvArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Readv': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ReadvArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.ReadvArgs{}, err
      }
    case 1:
      var dataIov uint64
      err = decoder.DecodeUint64(&dataIov)
      if err != nil {
        return types.ReadvArgs{}, err
      }
      result.Iov = uintptr(dataIov)
    case 2:
      err = decoder.DecodeInt32(&result.Iovcnt)
      if err != nil {
        return types.ReadvArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseWritevArgs(log *logging.Logger, decoder *Decoder) (types.WritevArgs, error) {
  var result types.WritevArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.WritevArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Writev': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.WritevArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.WritevArgs{}, err
      }
    case 1:
      var dataIov uint64
      err = decoder.DecodeUint64(&dataIov)
      if err != nil {
        return types.WritevArgs{}, err
      }
      result.Iov = uintptr(dataIov)
    case 2:
      err = decoder.DecodeInt32(&result.Iovcnt)
      if err != nil {
        return types.WritevArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseAccessArgs(log *logging.Logger, decoder *Decoder) (types.AccessArgs, error) {
  var result types.AccessArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.AccessArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Access': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.AccessArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.AccessArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Mode)
      if err != nil {
        return types.AccessArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePipeArgs(log *logging.Logger, decoder *Decoder) (types.PipeArgs, error) {
  var result types.PipeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PipeArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Pipe': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PipeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeIntArray(result.Pipefd[:], 2)
      if err != nil {
        return types.PipeArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSelectArgs(log *logging.Logger, decoder *Decoder) (types.SelectArgs, error) {
  var result types.SelectArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SelectArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Select': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SelectArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Nfds)
      if err != nil {
        return types.SelectArgs{}, err
      }
    case 1:
      var dataReadfds uint64
      err = decoder.DecodeUint64(&dataReadfds)
      if err != nil {
        return types.SelectArgs{}, err
      }
      result.Readfds = uintptr(dataReadfds)
    case 2:
      var dataWritefds uint64
      err = decoder.DecodeUint64(&dataWritefds)
      if err != nil {
        return types.SelectArgs{}, err
      }
      result.Writefds = uintptr(dataWritefds)
    case 3:
      var dataExceptfds uint64
      err = decoder.DecodeUint64(&dataExceptfds)
      if err != nil {
        return types.SelectArgs{}, err
      }
      result.Exceptfds = uintptr(dataExceptfds)
    case 4:
      var dataTimeout uint64
      err = decoder.DecodeUint64(&dataTimeout)
      if err != nil {
        return types.SelectArgs{}, err
      }
      result.Timeout = uintptr(dataTimeout)
    }
  }
  return result, nil
}

func ParseSchedYieldArgs(log *logging.Logger, decoder *Decoder) (types.SchedYieldArgs, error) {
  return types.SchedYieldArgs{}, nil
}

func ParseMremapArgs(log *logging.Logger, decoder *Decoder) (types.MremapArgs, error) {
  var result types.MremapArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MremapArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Mremap': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MremapArgs{}, err
    }

    switch currArg {
    case 0:
      var dataOldAddress uint64
      err = decoder.DecodeUint64(&dataOldAddress)
      if err != nil {
        return types.MremapArgs{}, err
      }
      result.OldAddress = uintptr(dataOldAddress)
    case 1:
      err = decoder.DecodeUint64(&result.OldSize)
      if err != nil {
        return types.MremapArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.NewSize)
      if err != nil {
        return types.MremapArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.MremapArgs{}, err
      }
    case 4:
      var dataNewAddress uint64
      err = decoder.DecodeUint64(&dataNewAddress)
      if err != nil {
        return types.MremapArgs{}, err
      }
      result.NewAddress = uintptr(dataNewAddress)
    }
  }
  return result, nil
}

func ParseMsyncArgs(log *logging.Logger, decoder *Decoder) (types.MsyncArgs, error) {
  var result types.MsyncArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MsyncArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Msync': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MsyncArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.MsyncArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.MsyncArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.MsyncArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMincoreArgs(log *logging.Logger, decoder *Decoder) (types.MincoreArgs, error) {
  var result types.MincoreArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MincoreArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Mincore': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MincoreArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.MincoreArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.MincoreArgs{}, err
      }
    case 2:
      var dataVec uint64
      err = decoder.DecodeUint64(&dataVec)
      if err != nil {
        return types.MincoreArgs{}, err
      }
      result.Vec = uintptr(dataVec)
    }
  }
  return result, nil
}

func ParseMadviseArgs(log *logging.Logger, decoder *Decoder) (types.MadviseArgs, error) {
  var result types.MadviseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MadviseArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Madvise': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MadviseArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.MadviseArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.MadviseArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Advice)
      if err != nil {
        return types.MadviseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseShmgetArgs(log *logging.Logger, decoder *Decoder) (types.ShmgetArgs, error) {
  var result types.ShmgetArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ShmgetArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Shmget': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ShmgetArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Key)
      if err != nil {
        return types.ShmgetArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.ShmgetArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Shmflg)
      if err != nil {
        return types.ShmgetArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseShmatArgs(log *logging.Logger, decoder *Decoder) (types.ShmatArgs, error) {
  var result types.ShmatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ShmatArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Shmat': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ShmatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Shmid)
      if err != nil {
        return types.ShmatArgs{}, err
      }
    case 1:
      var dataShmaddr uint64
      err = decoder.DecodeUint64(&dataShmaddr)
      if err != nil {
        return types.ShmatArgs{}, err
      }
      result.Shmaddr = uintptr(dataShmaddr)
    case 2:
      err = decoder.DecodeInt32(&result.Shmflg)
      if err != nil {
        return types.ShmatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseShmctlArgs(log *logging.Logger, decoder *Decoder) (types.ShmctlArgs, error) {
  var result types.ShmctlArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ShmctlArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Shmctl': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ShmctlArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Shmid)
      if err != nil {
        return types.ShmctlArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Cmd)
      if err != nil {
        return types.ShmctlArgs{}, err
      }
    case 2:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.ShmctlArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    }
  }
  return result, nil
}

func ParseDupArgs(log *logging.Logger, decoder *Decoder) (types.DupArgs, error) {
  var result types.DupArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.DupArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Dup': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.DupArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Oldfd)
      if err != nil {
        return types.DupArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseDup2Args(log *logging.Logger, decoder *Decoder) (types.Dup2Args, error) {
  var result types.Dup2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Dup2Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Dup2': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Dup2Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Oldfd)
      if err != nil {
        return types.Dup2Args{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Newfd)
      if err != nil {
        return types.Dup2Args{}, err
      }
    }
  }
  return result, nil
}

func ParsePauseArgs(log *logging.Logger, decoder *Decoder) (types.PauseArgs, error) {
  return types.PauseArgs{}, nil
}

func ParseNanosleepArgs(log *logging.Logger, decoder *Decoder) (types.NanosleepArgs, error) {
  var result types.NanosleepArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NanosleepArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Nanosleep': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NanosleepArgs{}, err
    }

    switch currArg {
    case 0:
      result.Req, err = decoder.ReadTimespec()
      if err != nil {
        return types.NanosleepArgs{}, err
      }
    case 1:
      result.Rem, err = decoder.ReadTimespec()
      if err != nil {
        return types.NanosleepArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetitimerArgs(log *logging.Logger, decoder *Decoder) (types.GetitimerArgs, error) {
  var result types.GetitimerArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetitimerArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Getitimer': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetitimerArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Which)
      if err != nil {
        return types.GetitimerArgs{}, err
      }
    case 1:
      var dataCurrValue uint64
      err = decoder.DecodeUint64(&dataCurrValue)
      if err != nil {
        return types.GetitimerArgs{}, err
      }
      result.CurrValue = uintptr(dataCurrValue)
    }
  }
  return result, nil
}

func ParseAlarmArgs(log *logging.Logger, decoder *Decoder) (types.AlarmArgs, error) {
  var result types.AlarmArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.AlarmArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Alarm': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.AlarmArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Seconds)
      if err != nil {
        return types.AlarmArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetitimerArgs(log *logging.Logger, decoder *Decoder) (types.SetitimerArgs, error) {
  var result types.SetitimerArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetitimerArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Setitimer': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetitimerArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Which)
      if err != nil {
        return types.SetitimerArgs{}, err
      }
    case 1:
      var dataNewValue uint64
      err = decoder.DecodeUint64(&dataNewValue)
      if err != nil {
        return types.SetitimerArgs{}, err
      }
      result.NewValue = uintptr(dataNewValue)
    case 2:
      var dataOldValue uint64
      err = decoder.DecodeUint64(&dataOldValue)
      if err != nil {
        return types.SetitimerArgs{}, err
      }
      result.OldValue = uintptr(dataOldValue)
    }
  }
  return result, nil
}

func ParseGetpidArgs(log *logging.Logger, decoder *Decoder) (types.GetpidArgs, error) {
  return types.GetpidArgs{}, nil
}

func ParseSendfileArgs(log *logging.Logger, decoder *Decoder) (types.SendfileArgs, error) {
  var result types.SendfileArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SendfileArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Sendfile': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SendfileArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.OutFd)
      if err != nil {
        return types.SendfileArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.InFd)
      if err != nil {
        return types.SendfileArgs{}, err
      }
    case 2:
      var dataOffset uint64
      err = decoder.DecodeUint64(&dataOffset)
      if err != nil {
        return types.SendfileArgs{}, err
      }
      result.Offset = uintptr(dataOffset)
    case 3:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.SendfileArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSocketArgs(log *logging.Logger, decoder *Decoder) (types.SocketArgs, error) {
  var result types.SocketArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SocketArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Socket': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SocketArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Domain)
      if err != nil {
        return types.SocketArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Type)
      if err != nil {
        return types.SocketArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Protocol)
      if err != nil {
        return types.SocketArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseConnectArgs(log *logging.Logger, decoder *Decoder) (types.ConnectArgs, error) {
  var result types.ConnectArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ConnectArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Connect': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ConnectArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.ConnectArgs{}, err
      }
    case 1:
      result.Addr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.ConnectArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Addrlen)
      if err != nil {
        return types.ConnectArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseAcceptArgs(log *logging.Logger, decoder *Decoder) (types.AcceptArgs, error) {
  var result types.AcceptArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.AcceptArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Accept': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.AcceptArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.AcceptArgs{}, err
      }
    case 1:
      result.Addr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.AcceptArgs{}, err
      }
    case 2:
      var dataAddrlen uint64
      err = decoder.DecodeUint64(&dataAddrlen)
      if err != nil {
        return types.AcceptArgs{}, err
      }
      result.Addrlen = uintptr(dataAddrlen)
    }
  }
  return result, nil
}

func ParseSendtoArgs(log *logging.Logger, decoder *Decoder) (types.SendtoArgs, error) {
  var result types.SendtoArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SendtoArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Sendto': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SendtoArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.SendtoArgs{}, err
      }
    case 1:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.SendtoArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    case 2:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.SendtoArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.SendtoArgs{}, err
      }
    case 4:
      result.DestAddr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.SendtoArgs{}, err
      }
    case 5:
      err = decoder.DecodeInt32(&result.Addrlen)
      if err != nil {
        return types.SendtoArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRecvfromArgs(log *logging.Logger, decoder *Decoder) (types.RecvfromArgs, error) {
  var result types.RecvfromArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RecvfromArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Recvfrom': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RecvfromArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.RecvfromArgs{}, err
      }
    case 1:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.RecvfromArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    case 2:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.RecvfromArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.RecvfromArgs{}, err
      }
    case 4:
      result.SrcAddr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.RecvfromArgs{}, err
      }
    case 5:
      var dataAddrlen uint64
      err = decoder.DecodeUint64(&dataAddrlen)
      if err != nil {
        return types.RecvfromArgs{}, err
      }
      result.Addrlen = uintptr(dataAddrlen)
    }
  }
  return result, nil
}

func ParseSendmsgArgs(log *logging.Logger, decoder *Decoder) (types.SendmsgArgs, error) {
  var result types.SendmsgArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SendmsgArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Sendmsg': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SendmsgArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.SendmsgArgs{}, err
      }
    case 1:
      var dataMsg uint64
      err = decoder.DecodeUint64(&dataMsg)
      if err != nil {
        return types.SendmsgArgs{}, err
      }
      result.Msg = uintptr(dataMsg)
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.SendmsgArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRecvmsgArgs(log *logging.Logger, decoder *Decoder) (types.RecvmsgArgs, error) {
  var result types.RecvmsgArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RecvmsgArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Recvmsg': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RecvmsgArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.RecvmsgArgs{}, err
      }
    case 1:
      var dataMsg uint64
      err = decoder.DecodeUint64(&dataMsg)
      if err != nil {
        return types.RecvmsgArgs{}, err
      }
      result.Msg = uintptr(dataMsg)
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.RecvmsgArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseShutdownArgs(log *logging.Logger, decoder *Decoder) (types.ShutdownArgs, error) {
  var result types.ShutdownArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ShutdownArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Shutdown': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ShutdownArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.ShutdownArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.How)
      if err != nil {
        return types.ShutdownArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseBindArgs(log *logging.Logger, decoder *Decoder) (types.BindArgs, error) {
  var result types.BindArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.BindArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Bind': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.BindArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.BindArgs{}, err
      }
    case 1:
      result.Addr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.BindArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Addrlen)
      if err != nil {
        return types.BindArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseListenArgs(log *logging.Logger, decoder *Decoder) (types.ListenArgs, error) {
  var result types.ListenArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ListenArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Listen': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ListenArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.ListenArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Backlog)
      if err != nil {
        return types.ListenArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetsocknameArgs(log *logging.Logger, decoder *Decoder) (types.GetsocknameArgs, error) {
  var result types.GetsocknameArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetsocknameArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Getsockname': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetsocknameArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.GetsocknameArgs{}, err
      }
    case 1:
      result.Addr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.GetsocknameArgs{}, err
      }
    case 2:
      var dataAddrlen uint64
      err = decoder.DecodeUint64(&dataAddrlen)
      if err != nil {
        return types.GetsocknameArgs{}, err
      }
      result.Addrlen = uintptr(dataAddrlen)
    }
  }
  return result, nil
}

func ParseGetpeernameArgs(log *logging.Logger, decoder *Decoder) (types.GetpeernameArgs, error) {
  var result types.GetpeernameArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetpeernameArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Getpeername': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetpeernameArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.GetpeernameArgs{}, err
      }
    case 1:
      result.Addr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.GetpeernameArgs{}, err
      }
    case 2:
      var dataAddrlen uint64
      err = decoder.DecodeUint64(&dataAddrlen)
      if err != nil {
        return types.GetpeernameArgs{}, err
      }
      result.Addrlen = uintptr(dataAddrlen)
    }
  }
  return result, nil
}

func ParseSocketpairArgs(log *logging.Logger, decoder *Decoder) (types.SocketpairArgs, error) {
  var result types.SocketpairArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SocketpairArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Socketpair': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SocketpairArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Domain)
      if err != nil {
        return types.SocketpairArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Type)
      if err != nil {
        return types.SocketpairArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Protocol)
      if err != nil {
        return types.SocketpairArgs{}, err
      }
    case 3:
      err = decoder.DecodeIntArray(result.Sv[:], 2)
      if err != nil {
        return types.SocketpairArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetsockoptArgs(log *logging.Logger, decoder *Decoder) (types.SetsockoptArgs, error) {
  var result types.SetsockoptArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetsockoptArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Setsockopt': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetsockoptArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.SetsockoptArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Level)
      if err != nil {
        return types.SetsockoptArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Optname)
      if err != nil {
        return types.SetsockoptArgs{}, err
      }
    case 3:
      var dataOptval uint64
      err = decoder.DecodeUint64(&dataOptval)
      if err != nil {
        return types.SetsockoptArgs{}, err
      }
      result.Optval = uintptr(dataOptval)
    case 4:
      err = decoder.DecodeInt32(&result.Optlen)
      if err != nil {
        return types.SetsockoptArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetsockoptArgs(log *logging.Logger, decoder *Decoder) (types.GetsockoptArgs, error) {
  var result types.GetsockoptArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetsockoptArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Getsockopt': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetsockoptArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.GetsockoptArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Level)
      if err != nil {
        return types.GetsockoptArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Optname)
      if err != nil {
        return types.GetsockoptArgs{}, err
      }
    case 3:
      var dataOptval uint64
      err = decoder.DecodeUint64(&dataOptval)
      if err != nil {
        return types.GetsockoptArgs{}, err
      }
      result.Optval = uintptr(dataOptval)
    case 4:
      var dataOptlen uint64
      err = decoder.DecodeUint64(&dataOptlen)
      if err != nil {
        return types.GetsockoptArgs{}, err
      }
      result.Optlen = uintptr(dataOptlen)
    }
  }
  return result, nil
}

func ParseCloneArgs(log *logging.Logger, decoder *Decoder) (types.CloneArgs, error) {
  var result types.CloneArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CloneArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Clone': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CloneArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.Flags)
      if err != nil {
        return types.CloneArgs{}, err
      }
    case 1:
      var dataStack uint64
      err = decoder.DecodeUint64(&dataStack)
      if err != nil {
        return types.CloneArgs{}, err
      }
      result.Stack = uintptr(dataStack)
    case 2:
      var dataParentTid uint64
      err = decoder.DecodeUint64(&dataParentTid)
      if err != nil {
        return types.CloneArgs{}, err
      }
      result.ParentTid = uintptr(dataParentTid)
    case 3:
      var dataChildTid uint64
      err = decoder.DecodeUint64(&dataChildTid)
      if err != nil {
        return types.CloneArgs{}, err
      }
      result.ChildTid = uintptr(dataChildTid)
    case 4:
      err = decoder.DecodeUint64(&result.Tls)
      if err != nil {
        return types.CloneArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseForkArgs(log *logging.Logger, decoder *Decoder) (types.ForkArgs, error) {
  return types.ForkArgs{}, nil
}

func ParseVforkArgs(log *logging.Logger, decoder *Decoder) (types.VforkArgs, error) {
  return types.VforkArgs{}, nil
}

func ParseExecveArgs(log *logging.Logger, decoder *Decoder) (types.ExecveArgs, error) {
  var result types.ExecveArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ExecveArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Execve': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ExecveArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ExecveArgs{}, err
      }
    case 1:
      result.Argv, err = decoder.ReadStringArrayFromBuff()
      if err != nil {
        return types.ExecveArgs{}, err
      }
    case 2:
      result.Envp, err = decoder.ReadStringArrayFromBuff()
      if err != nil {
        return types.ExecveArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseExitArgs(log *logging.Logger, decoder *Decoder) (types.ExitArgs, error) {
  var result types.ExitArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ExitArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Exit': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ExitArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Status)
      if err != nil {
        return types.ExitArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseWait4Args(log *logging.Logger, decoder *Decoder) (types.Wait4Args, error) {
  var result types.Wait4Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Wait4Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Wait4': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Wait4Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.Wait4Args{}, err
      }
    case 1:
      var dataWstatus uint64
      err = decoder.DecodeUint64(&dataWstatus)
      if err != nil {
        return types.Wait4Args{}, err
      }
      result.Wstatus = uintptr(dataWstatus)
    case 2:
      err = decoder.DecodeInt32(&result.Options)
      if err != nil {
        return types.Wait4Args{}, err
      }
    case 3:
      var dataRusage uint64
      err = decoder.DecodeUint64(&dataRusage)
      if err != nil {
        return types.Wait4Args{}, err
      }
      result.Rusage = uintptr(dataRusage)
    }
  }
  return result, nil
}

func ParseKillArgs(log *logging.Logger, decoder *Decoder) (types.KillArgs, error) {
  var result types.KillArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.KillArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Kill': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.KillArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.KillArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Sig)
      if err != nil {
        return types.KillArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseUnameArgs(log *logging.Logger, decoder *Decoder) (types.UnameArgs, error) {
  var result types.UnameArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UnameArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Uname': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UnameArgs{}, err
    }

    switch currArg {
    case 0:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.UnameArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    }
  }
  return result, nil
}

func ParseSemgetArgs(log *logging.Logger, decoder *Decoder) (types.SemgetArgs, error) {
  var result types.SemgetArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SemgetArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Semget': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SemgetArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Key)
      if err != nil {
        return types.SemgetArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Nsems)
      if err != nil {
        return types.SemgetArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Semflg)
      if err != nil {
        return types.SemgetArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSemopArgs(log *logging.Logger, decoder *Decoder) (types.SemopArgs, error) {
  var result types.SemopArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SemopArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Semop': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SemopArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Semid)
      if err != nil {
        return types.SemopArgs{}, err
      }
    case 1:
      var dataSops uint64
      err = decoder.DecodeUint64(&dataSops)
      if err != nil {
        return types.SemopArgs{}, err
      }
      result.Sops = uintptr(dataSops)
    case 2:
      err = decoder.DecodeUint64(&result.Nsops)
      if err != nil {
        return types.SemopArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSemctlArgs(log *logging.Logger, decoder *Decoder) (types.SemctlArgs, error) {
  var result types.SemctlArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SemctlArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Semctl': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SemctlArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Semid)
      if err != nil {
        return types.SemctlArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Semnum)
      if err != nil {
        return types.SemctlArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Cmd)
      if err != nil {
        return types.SemctlArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Arg)
      if err != nil {
        return types.SemctlArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseShmdtArgs(log *logging.Logger, decoder *Decoder) (types.ShmdtArgs, error) {
  var result types.ShmdtArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ShmdtArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Shmdt': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ShmdtArgs{}, err
    }

    switch currArg {
    case 0:
      var dataShmaddr uint64
      err = decoder.DecodeUint64(&dataShmaddr)
      if err != nil {
        return types.ShmdtArgs{}, err
      }
      result.Shmaddr = uintptr(dataShmaddr)
    }
  }
  return result, nil
}

func ParseMsggetArgs(log *logging.Logger, decoder *Decoder) (types.MsggetArgs, error) {
  var result types.MsggetArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MsggetArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Msgget': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MsggetArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Key)
      if err != nil {
        return types.MsggetArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Msgflg)
      if err != nil {
        return types.MsggetArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMsgsndArgs(log *logging.Logger, decoder *Decoder) (types.MsgsndArgs, error) {
  var result types.MsgsndArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MsgsndArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Msgsnd': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MsgsndArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Msqid)
      if err != nil {
        return types.MsgsndArgs{}, err
      }
    case 1:
      var dataMsgp uint64
      err = decoder.DecodeUint64(&dataMsgp)
      if err != nil {
        return types.MsgsndArgs{}, err
      }
      result.Msgp = uintptr(dataMsgp)
    case 2:
      err = decoder.DecodeUint64(&result.Msgsz)
      if err != nil {
        return types.MsgsndArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Msgflg)
      if err != nil {
        return types.MsgsndArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMsgrcvArgs(log *logging.Logger, decoder *Decoder) (types.MsgrcvArgs, error) {
  var result types.MsgrcvArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MsgrcvArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Msgrcv': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MsgrcvArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Msqid)
      if err != nil {
        return types.MsgrcvArgs{}, err
      }
    case 1:
      var dataMsgp uint64
      err = decoder.DecodeUint64(&dataMsgp)
      if err != nil {
        return types.MsgrcvArgs{}, err
      }
      result.Msgp = uintptr(dataMsgp)
    case 2:
      err = decoder.DecodeUint64(&result.Msgsz)
      if err != nil {
        return types.MsgrcvArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt64(&result.Msgtyp)
      if err != nil {
        return types.MsgrcvArgs{}, err
      }
    case 4:
      err = decoder.DecodeInt32(&result.Msgflg)
      if err != nil {
        return types.MsgrcvArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMsgctlArgs(log *logging.Logger, decoder *Decoder) (types.MsgctlArgs, error) {
  var result types.MsgctlArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MsgctlArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Msgctl': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MsgctlArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Msqid)
      if err != nil {
        return types.MsgctlArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Cmd)
      if err != nil {
        return types.MsgctlArgs{}, err
      }
    case 2:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.MsgctlArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    }
  }
  return result, nil
}

func ParseFcntlArgs(log *logging.Logger, decoder *Decoder) (types.FcntlArgs, error) {
  var result types.FcntlArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FcntlArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Fcntl': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FcntlArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FcntlArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Cmd)
      if err != nil {
        return types.FcntlArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Arg)
      if err != nil {
        return types.FcntlArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFlockArgs(log *logging.Logger, decoder *Decoder) (types.FlockArgs, error) {
  var result types.FlockArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FlockArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Flock': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FlockArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FlockArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Operation)
      if err != nil {
        return types.FlockArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFsyncArgs(log *logging.Logger, decoder *Decoder) (types.FsyncArgs, error) {
  var result types.FsyncArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FsyncArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Fsync': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FsyncArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FsyncArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFdatasyncArgs(log *logging.Logger, decoder *Decoder) (types.FdatasyncArgs, error) {
  var result types.FdatasyncArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FdatasyncArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Fdatasync': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FdatasyncArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FdatasyncArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseTruncateArgs(log *logging.Logger, decoder *Decoder) (types.TruncateArgs, error) {
  var result types.TruncateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TruncateArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Truncate': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TruncateArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.TruncateArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.TruncateArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFtruncateArgs(log *logging.Logger, decoder *Decoder) (types.FtruncateArgs, error) {
  var result types.FtruncateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FtruncateArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Ftruncate': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FtruncateArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FtruncateArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.FtruncateArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetdentsArgs(log *logging.Logger, decoder *Decoder) (types.GetdentsArgs, error) {
  var result types.GetdentsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetdentsArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Getdents': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetdentsArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.GetdentsArgs{}, err
      }
    case 1:
      var dataDirp uint64
      err = decoder.DecodeUint64(&dataDirp)
      if err != nil {
        return types.GetdentsArgs{}, err
      }
      result.Dirp = uintptr(dataDirp)
    case 2:
      err = decoder.DecodeUint32(&result.Count)
      if err != nil {
        return types.GetdentsArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetcwdArgs(log *logging.Logger, decoder *Decoder) (types.GetcwdArgs, error) {
  var result types.GetcwdArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetcwdArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Getcwd': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetcwdArgs{}, err
    }

    switch currArg {
    case 0:
      result.Buf, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.GetcwdArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.GetcwdArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseChdirArgs(log *logging.Logger, decoder *Decoder) (types.ChdirArgs, error) {
  var result types.ChdirArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ChdirArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Chdir': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ChdirArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ChdirArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFchdirArgs(log *logging.Logger, decoder *Decoder) (types.FchdirArgs, error) {
  var result types.FchdirArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FchdirArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Fchdir': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FchdirArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FchdirArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRenameArgs(log *logging.Logger, decoder *Decoder) (types.RenameArgs, error) {
  var result types.RenameArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RenameArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Rename': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RenameArgs{}, err
    }

    switch currArg {
    case 0:
      result.Oldpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.RenameArgs{}, err
      }
    case 1:
      result.Newpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.RenameArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMkdirArgs(log *logging.Logger, decoder *Decoder) (types.MkdirArgs, error) {
  var result types.MkdirArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MkdirArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Mkdir': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MkdirArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MkdirArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.MkdirArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRmdirArgs(log *logging.Logger, decoder *Decoder) (types.RmdirArgs, error) {
  var result types.RmdirArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RmdirArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Rmdir': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RmdirArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.RmdirArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseCreatArgs(log *logging.Logger, decoder *Decoder) (types.CreatArgs, error) {
  var result types.CreatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CreatArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Creat': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CreatArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.CreatArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.CreatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseLinkArgs(log *logging.Logger, decoder *Decoder) (types.LinkArgs, error) {
  var result types.LinkArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LinkArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Link': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LinkArgs{}, err
    }

    switch currArg {
    case 0:
      result.Oldpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LinkArgs{}, err
      }
    case 1:
      result.Newpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LinkArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseUnlinkArgs(log *logging.Logger, decoder *Decoder) (types.UnlinkArgs, error) {
  var result types.UnlinkArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UnlinkArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Unlink': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UnlinkArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.UnlinkArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSymlinkArgs(log *logging.Logger, decoder *Decoder) (types.SymlinkArgs, error) {
  var result types.SymlinkArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SymlinkArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Symlink': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SymlinkArgs{}, err
    }

    switch currArg {
    case 0:
      result.Target, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SymlinkArgs{}, err
      }
    case 1:
      result.Linkpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SymlinkArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseReadlinkArgs(log *logging.Logger, decoder *Decoder) (types.ReadlinkArgs, error) {
  var result types.ReadlinkArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ReadlinkArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Readlink': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ReadlinkArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ReadlinkArgs{}, err
      }
    case 1:
      result.Buf, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ReadlinkArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Bufsiz)
      if err != nil {
        return types.ReadlinkArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseChmodArgs(log *logging.Logger, decoder *Decoder) (types.ChmodArgs, error) {
  var result types.ChmodArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ChmodArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Chmod': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ChmodArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ChmodArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.ChmodArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFchmodArgs(log *logging.Logger, decoder *Decoder) (types.FchmodArgs, error) {
  var result types.FchmodArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FchmodArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Fchmod': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FchmodArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FchmodArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.FchmodArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseChownArgs(log *logging.Logger, decoder *Decoder) (types.ChownArgs, error) {
  var result types.ChownArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ChownArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Chown': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ChownArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ChownArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Owner)
      if err != nil {
        return types.ChownArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Group)
      if err != nil {
        return types.ChownArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFchownArgs(log *logging.Logger, decoder *Decoder) (types.FchownArgs, error) {
  var result types.FchownArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FchownArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Fchown': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FchownArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FchownArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Owner)
      if err != nil {
        return types.FchownArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Group)
      if err != nil {
        return types.FchownArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseLchownArgs(log *logging.Logger, decoder *Decoder) (types.LchownArgs, error) {
  var result types.LchownArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LchownArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Lchown': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LchownArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LchownArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Owner)
      if err != nil {
        return types.LchownArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Group)
      if err != nil {
        return types.LchownArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseUmaskArgs(log *logging.Logger, decoder *Decoder) (types.UmaskArgs, error) {
  var result types.UmaskArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UmaskArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Umask': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UmaskArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Mask)
      if err != nil {
        return types.UmaskArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGettimeofdayArgs(log *logging.Logger, decoder *Decoder) (types.GettimeofdayArgs, error) {
  var result types.GettimeofdayArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GettimeofdayArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Gettimeofday': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GettimeofdayArgs{}, err
    }

    switch currArg {
    case 0:
      var dataTv uint64
      err = decoder.DecodeUint64(&dataTv)
      if err != nil {
        return types.GettimeofdayArgs{}, err
      }
      result.Tv = uintptr(dataTv)
    case 1:
      var dataTz uint64
      err = decoder.DecodeUint64(&dataTz)
      if err != nil {
        return types.GettimeofdayArgs{}, err
      }
      result.Tz = uintptr(dataTz)
    }
  }
  return result, nil
}

func ParseGetrlimitArgs(log *logging.Logger, decoder *Decoder) (types.GetrlimitArgs, error) {
  var result types.GetrlimitArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetrlimitArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Getrlimit': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetrlimitArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Resource)
      if err != nil {
        return types.GetrlimitArgs{}, err
      }
    case 1:
      var dataRlim uint64
      err = decoder.DecodeUint64(&dataRlim)
      if err != nil {
        return types.GetrlimitArgs{}, err
      }
      result.Rlim = uintptr(dataRlim)
    }
  }
  return result, nil
}

func ParseGetrusageArgs(log *logging.Logger, decoder *Decoder) (types.GetrusageArgs, error) {
  var result types.GetrusageArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetrusageArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Getrusage': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetrusageArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Who)
      if err != nil {
        return types.GetrusageArgs{}, err
      }
    case 1:
      var dataUsage uint64
      err = decoder.DecodeUint64(&dataUsage)
      if err != nil {
        return types.GetrusageArgs{}, err
      }
      result.Usage = uintptr(dataUsage)
    }
  }
  return result, nil
}

func ParseSysinfoArgs(log *logging.Logger, decoder *Decoder) (types.SysinfoArgs, error) {
  var result types.SysinfoArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SysinfoArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Sysinfo': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SysinfoArgs{}, err
    }

    switch currArg {
    case 0:
      var dataInfo uint64
      err = decoder.DecodeUint64(&dataInfo)
      if err != nil {
        return types.SysinfoArgs{}, err
      }
      result.Info = uintptr(dataInfo)
    }
  }
  return result, nil
}

func ParseTimesArgs(log *logging.Logger, decoder *Decoder) (types.TimesArgs, error) {
  var result types.TimesArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimesArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Times': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimesArgs{}, err
    }

    switch currArg {
    case 0:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.TimesArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    }
  }
  return result, nil
}

func ParsePtraceArgs(log *logging.Logger, decoder *Decoder) (types.PtraceArgs, error) {
  var result types.PtraceArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PtraceArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Ptrace': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PtraceArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt64(&result.Request)
      if err != nil {
        return types.PtraceArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.PtraceArgs{}, err
      }
    case 2:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.PtraceArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 3:
      var dataData uint64
      err = decoder.DecodeUint64(&dataData)
      if err != nil {
        return types.PtraceArgs{}, err
      }
      result.Data = uintptr(dataData)
    }
  }
  return result, nil
}

func ParseGetuidArgs(log *logging.Logger, decoder *Decoder) (types.GetuidArgs, error) {
  return types.GetuidArgs{}, nil
}

func ParseSyslogArgs(log *logging.Logger, decoder *Decoder) (types.SyslogArgs, error) {
  var result types.SyslogArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SyslogArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Syslog': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SyslogArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Type)
      if err != nil {
        return types.SyslogArgs{}, err
      }
    case 1:
      result.Bufp, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SyslogArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Len)
      if err != nil {
        return types.SyslogArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetgidArgs(log *logging.Logger, decoder *Decoder) (types.GetgidArgs, error) {
  return types.GetgidArgs{}, nil
}

func ParseSetuidArgs(log *logging.Logger, decoder *Decoder) (types.SetuidArgs, error) {
  var result types.SetuidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetuidArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Setuid': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetuidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Uid)
      if err != nil {
        return types.SetuidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetgidArgs(log *logging.Logger, decoder *Decoder) (types.SetgidArgs, error) {
  var result types.SetgidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetgidArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Setgid': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetgidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Gid)
      if err != nil {
        return types.SetgidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGeteuidArgs(log *logging.Logger, decoder *Decoder) (types.GeteuidArgs, error) {
  return types.GeteuidArgs{}, nil
}

func ParseGetegidArgs(log *logging.Logger, decoder *Decoder) (types.GetegidArgs, error) {
  return types.GetegidArgs{}, nil
}

func ParseSetpgidArgs(log *logging.Logger, decoder *Decoder) (types.SetpgidArgs, error) {
  var result types.SetpgidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetpgidArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Setpgid': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetpgidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SetpgidArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Pgid)
      if err != nil {
        return types.SetpgidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetppidArgs(log *logging.Logger, decoder *Decoder) (types.GetppidArgs, error) {
  return types.GetppidArgs{}, nil
}

func ParseGetpgrpArgs(log *logging.Logger, decoder *Decoder) (types.GetpgrpArgs, error) {
  return types.GetpgrpArgs{}, nil
}

func ParseSetsidArgs(log *logging.Logger, decoder *Decoder) (types.SetsidArgs, error) {
  return types.SetsidArgs{}, nil
}

func ParseSetreuidArgs(log *logging.Logger, decoder *Decoder) (types.SetreuidArgs, error) {
  var result types.SetreuidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetreuidArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Setreuid': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetreuidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Ruid)
      if err != nil {
        return types.SetreuidArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Euid)
      if err != nil {
        return types.SetreuidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetregidArgs(log *logging.Logger, decoder *Decoder) (types.SetregidArgs, error) {
  var result types.SetregidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetregidArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Setregid': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetregidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Rgid)
      if err != nil {
        return types.SetregidArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Egid)
      if err != nil {
        return types.SetregidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetgroupsArgs(log *logging.Logger, decoder *Decoder) (types.GetgroupsArgs, error) {
  var result types.GetgroupsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetgroupsArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Getgroups': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetgroupsArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Size)
      if err != nil {
        return types.GetgroupsArgs{}, err
      }
    case 1:
      var dataList uint64
      err = decoder.DecodeUint64(&dataList)
      if err != nil {
        return types.GetgroupsArgs{}, err
      }
      result.List = uintptr(dataList)
    }
  }
  return result, nil
}

func ParseSetgroupsArgs(log *logging.Logger, decoder *Decoder) (types.SetgroupsArgs, error) {
  var result types.SetgroupsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetgroupsArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Setgroups': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetgroupsArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Size)
      if err != nil {
        return types.SetgroupsArgs{}, err
      }
    case 1:
      var dataList uint64
      err = decoder.DecodeUint64(&dataList)
      if err != nil {
        return types.SetgroupsArgs{}, err
      }
      result.List = uintptr(dataList)
    }
  }
  return result, nil
}

func ParseSetresuidArgs(log *logging.Logger, decoder *Decoder) (types.SetresuidArgs, error) {
  var result types.SetresuidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetresuidArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Setresuid': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetresuidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Ruid)
      if err != nil {
        return types.SetresuidArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Euid)
      if err != nil {
        return types.SetresuidArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Suid)
      if err != nil {
        return types.SetresuidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetresuidArgs(log *logging.Logger, decoder *Decoder) (types.GetresuidArgs, error) {
  var result types.GetresuidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetresuidArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Getresuid': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetresuidArgs{}, err
    }

    switch currArg {
    case 0:
      var dataRuid uint64
      err = decoder.DecodeUint64(&dataRuid)
      if err != nil {
        return types.GetresuidArgs{}, err
      }
      result.Ruid = uintptr(dataRuid)
    case 1:
      var dataEuid uint64
      err = decoder.DecodeUint64(&dataEuid)
      if err != nil {
        return types.GetresuidArgs{}, err
      }
      result.Euid = uintptr(dataEuid)
    case 2:
      var dataSuid uint64
      err = decoder.DecodeUint64(&dataSuid)
      if err != nil {
        return types.GetresuidArgs{}, err
      }
      result.Suid = uintptr(dataSuid)
    }
  }
  return result, nil
}

func ParseSetresgidArgs(log *logging.Logger, decoder *Decoder) (types.SetresgidArgs, error) {
  var result types.SetresgidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetresgidArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Setresgid': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetresgidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Rgid)
      if err != nil {
        return types.SetresgidArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Egid)
      if err != nil {
        return types.SetresgidArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Sgid)
      if err != nil {
        return types.SetresgidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetresgidArgs(log *logging.Logger, decoder *Decoder) (types.GetresgidArgs, error) {
  var result types.GetresgidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetresgidArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Getresgid': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetresgidArgs{}, err
    }

    switch currArg {
    case 0:
      var dataRgid uint64
      err = decoder.DecodeUint64(&dataRgid)
      if err != nil {
        return types.GetresgidArgs{}, err
      }
      result.Rgid = uintptr(dataRgid)
    case 1:
      var dataEgid uint64
      err = decoder.DecodeUint64(&dataEgid)
      if err != nil {
        return types.GetresgidArgs{}, err
      }
      result.Egid = uintptr(dataEgid)
    case 2:
      var dataSgid uint64
      err = decoder.DecodeUint64(&dataSgid)
      if err != nil {
        return types.GetresgidArgs{}, err
      }
      result.Sgid = uintptr(dataSgid)
    }
  }
  return result, nil
}

func ParseGetpgidArgs(log *logging.Logger, decoder *Decoder) (types.GetpgidArgs, error) {
  var result types.GetpgidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetpgidArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Getpgid': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetpgidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.GetpgidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetfsuidArgs(log *logging.Logger, decoder *Decoder) (types.SetfsuidArgs, error) {
  var result types.SetfsuidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetfsuidArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Setfsuid': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetfsuidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fsuid)
      if err != nil {
        return types.SetfsuidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetfsgidArgs(log *logging.Logger, decoder *Decoder) (types.SetfsgidArgs, error) {
  var result types.SetfsgidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetfsgidArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Setfsgid': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetfsgidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fsgid)
      if err != nil {
        return types.SetfsgidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetsidArgs(log *logging.Logger, decoder *Decoder) (types.GetsidArgs, error) {
  var result types.GetsidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetsidArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Getsid': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetsidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.GetsidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseCapgetArgs(log *logging.Logger, decoder *Decoder) (types.CapgetArgs, error) {
  var result types.CapgetArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CapgetArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Capget': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CapgetArgs{}, err
    }

    switch currArg {
    case 0:
      var dataHdrp uint64
      err = decoder.DecodeUint64(&dataHdrp)
      if err != nil {
        return types.CapgetArgs{}, err
      }
      result.Hdrp = uintptr(dataHdrp)
    case 1:
      var dataDatap uint64
      err = decoder.DecodeUint64(&dataDatap)
      if err != nil {
        return types.CapgetArgs{}, err
      }
      result.Datap = uintptr(dataDatap)
    }
  }
  return result, nil
}

func ParseCapsetArgs(log *logging.Logger, decoder *Decoder) (types.CapsetArgs, error) {
  var result types.CapsetArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CapsetArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Capset': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CapsetArgs{}, err
    }

    switch currArg {
    case 0:
      var dataHdrp uint64
      err = decoder.DecodeUint64(&dataHdrp)
      if err != nil {
        return types.CapsetArgs{}, err
      }
      result.Hdrp = uintptr(dataHdrp)
    case 1:
      var dataDatap uint64
      err = decoder.DecodeUint64(&dataDatap)
      if err != nil {
        return types.CapsetArgs{}, err
      }
      result.Datap = uintptr(dataDatap)
    }
  }
  return result, nil
}

func ParseRtSigpendingArgs(log *logging.Logger, decoder *Decoder) (types.RtSigpendingArgs, error) {
  var result types.RtSigpendingArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RtSigpendingArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'RtSigpending': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RtSigpendingArgs{}, err
    }

    switch currArg {
    case 0:
      var dataSet uint64
      err = decoder.DecodeUint64(&dataSet)
      if err != nil {
        return types.RtSigpendingArgs{}, err
      }
      result.Set = uintptr(dataSet)
    case 1:
      err = decoder.DecodeUint64(&result.Sigsetsize)
      if err != nil {
        return types.RtSigpendingArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRtSigtimedwaitArgs(log *logging.Logger, decoder *Decoder) (types.RtSigtimedwaitArgs, error) {
  var result types.RtSigtimedwaitArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RtSigtimedwaitArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'RtSigtimedwait': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RtSigtimedwaitArgs{}, err
    }

    switch currArg {
    case 0:
      var dataSet uint64
      err = decoder.DecodeUint64(&dataSet)
      if err != nil {
        return types.RtSigtimedwaitArgs{}, err
      }
      result.Set = uintptr(dataSet)
    case 1:
      var dataInfo uint64
      err = decoder.DecodeUint64(&dataInfo)
      if err != nil {
        return types.RtSigtimedwaitArgs{}, err
      }
      result.Info = uintptr(dataInfo)
    case 2:
      result.Timeout, err = decoder.ReadTimespec()
      if err != nil {
        return types.RtSigtimedwaitArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Sigsetsize)
      if err != nil {
        return types.RtSigtimedwaitArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRtSigqueueinfoArgs(log *logging.Logger, decoder *Decoder) (types.RtSigqueueinfoArgs, error) {
  var result types.RtSigqueueinfoArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RtSigqueueinfoArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'RtSigqueueinfo': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RtSigqueueinfoArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Tgid)
      if err != nil {
        return types.RtSigqueueinfoArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Sig)
      if err != nil {
        return types.RtSigqueueinfoArgs{}, err
      }
    case 2:
      var dataInfo uint64
      err = decoder.DecodeUint64(&dataInfo)
      if err != nil {
        return types.RtSigqueueinfoArgs{}, err
      }
      result.Info = uintptr(dataInfo)
    }
  }
  return result, nil
}

func ParseRtSigsuspendArgs(log *logging.Logger, decoder *Decoder) (types.RtSigsuspendArgs, error) {
  var result types.RtSigsuspendArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RtSigsuspendArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'RtSigsuspend': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RtSigsuspendArgs{}, err
    }

    switch currArg {
    case 0:
      var dataMask uint64
      err = decoder.DecodeUint64(&dataMask)
      if err != nil {
        return types.RtSigsuspendArgs{}, err
      }
      result.Mask = uintptr(dataMask)
    case 1:
      err = decoder.DecodeUint64(&result.Sigsetsize)
      if err != nil {
        return types.RtSigsuspendArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSigaltstackArgs(log *logging.Logger, decoder *Decoder) (types.SigaltstackArgs, error) {
  var result types.SigaltstackArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SigaltstackArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Sigaltstack': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SigaltstackArgs{}, err
    }

    switch currArg {
    case 0:
      var dataSs uint64
      err = decoder.DecodeUint64(&dataSs)
      if err != nil {
        return types.SigaltstackArgs{}, err
      }
      result.Ss = uintptr(dataSs)
    case 1:
      var dataOldSs uint64
      err = decoder.DecodeUint64(&dataOldSs)
      if err != nil {
        return types.SigaltstackArgs{}, err
      }
      result.OldSs = uintptr(dataOldSs)
    }
  }
  return result, nil
}

func ParseUtimeArgs(log *logging.Logger, decoder *Decoder) (types.UtimeArgs, error) {
  var result types.UtimeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UtimeArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Utime': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UtimeArgs{}, err
    }

    switch currArg {
    case 0:
      result.Filename, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.UtimeArgs{}, err
      }
    case 1:
      var dataTimes uint64
      err = decoder.DecodeUint64(&dataTimes)
      if err != nil {
        return types.UtimeArgs{}, err
      }
      result.Times = uintptr(dataTimes)
    }
  }
  return result, nil
}

func ParseMknodArgs(log *logging.Logger, decoder *Decoder) (types.MknodArgs, error) {
  var result types.MknodArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MknodArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Mknod': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MknodArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MknodArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.MknodArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.MknodArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseUselibArgs(log *logging.Logger, decoder *Decoder) (types.UselibArgs, error) {
  var result types.UselibArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UselibArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Uselib': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UselibArgs{}, err
    }

    switch currArg {
    case 0:
      result.Library, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.UselibArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePersonalityArgs(log *logging.Logger, decoder *Decoder) (types.PersonalityArgs, error) {
  var result types.PersonalityArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PersonalityArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Personality': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PersonalityArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.Persona)
      if err != nil {
        return types.PersonalityArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseUstatArgs(log *logging.Logger, decoder *Decoder) (types.UstatArgs, error) {
  var result types.UstatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UstatArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Ustat': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UstatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.UstatArgs{}, err
      }
    case 1:
      var dataUbuf uint64
      err = decoder.DecodeUint64(&dataUbuf)
      if err != nil {
        return types.UstatArgs{}, err
      }
      result.Ubuf = uintptr(dataUbuf)
    }
  }
  return result, nil
}

func ParseStatfsArgs(log *logging.Logger, decoder *Decoder) (types.StatfsArgs, error) {
  var result types.StatfsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.StatfsArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Statfs': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.StatfsArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.StatfsArgs{}, err
      }
    case 1:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.StatfsArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    }
  }
  return result, nil
}

func ParseFstatfsArgs(log *logging.Logger, decoder *Decoder) (types.FstatfsArgs, error) {
  var result types.FstatfsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FstatfsArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Fstatfs': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FstatfsArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FstatfsArgs{}, err
      }
    case 1:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.FstatfsArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    }
  }
  return result, nil
}

func ParseSysfsArgs(log *logging.Logger, decoder *Decoder) (types.SysfsArgs, error) {
  var result types.SysfsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SysfsArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Sysfs': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SysfsArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Option)
      if err != nil {
        return types.SysfsArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetpriorityArgs(log *logging.Logger, decoder *Decoder) (types.GetpriorityArgs, error) {
  var result types.GetpriorityArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetpriorityArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Getpriority': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetpriorityArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Which)
      if err != nil {
        return types.GetpriorityArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Who)
      if err != nil {
        return types.GetpriorityArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetpriorityArgs(log *logging.Logger, decoder *Decoder) (types.SetpriorityArgs, error) {
  var result types.SetpriorityArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetpriorityArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Setpriority': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetpriorityArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Which)
      if err != nil {
        return types.SetpriorityArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Who)
      if err != nil {
        return types.SetpriorityArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Prio)
      if err != nil {
        return types.SetpriorityArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedSetparamArgs(log *logging.Logger, decoder *Decoder) (types.SchedSetparamArgs, error) {
  var result types.SchedSetparamArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedSetparamArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SchedSetparam': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedSetparamArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SchedSetparamArgs{}, err
      }
    case 1:
      var dataParam uint64
      err = decoder.DecodeUint64(&dataParam)
      if err != nil {
        return types.SchedSetparamArgs{}, err
      }
      result.Param = uintptr(dataParam)
    }
  }
  return result, nil
}

func ParseSchedGetparamArgs(log *logging.Logger, decoder *Decoder) (types.SchedGetparamArgs, error) {
  var result types.SchedGetparamArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedGetparamArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SchedGetparam': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedGetparamArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SchedGetparamArgs{}, err
      }
    case 1:
      var dataParam uint64
      err = decoder.DecodeUint64(&dataParam)
      if err != nil {
        return types.SchedGetparamArgs{}, err
      }
      result.Param = uintptr(dataParam)
    }
  }
  return result, nil
}

func ParseSchedSetschedulerArgs(log *logging.Logger, decoder *Decoder) (types.SchedSetschedulerArgs, error) {
  var result types.SchedSetschedulerArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedSetschedulerArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SchedSetscheduler': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedSetschedulerArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SchedSetschedulerArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Policy)
      if err != nil {
        return types.SchedSetschedulerArgs{}, err
      }
    case 2:
      var dataParam uint64
      err = decoder.DecodeUint64(&dataParam)
      if err != nil {
        return types.SchedSetschedulerArgs{}, err
      }
      result.Param = uintptr(dataParam)
    }
  }
  return result, nil
}

func ParseSchedGetschedulerArgs(log *logging.Logger, decoder *Decoder) (types.SchedGetschedulerArgs, error) {
  var result types.SchedGetschedulerArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedGetschedulerArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'SchedGetscheduler': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedGetschedulerArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SchedGetschedulerArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedGetPriorityMaxArgs(log *logging.Logger, decoder *Decoder) (types.SchedGetPriorityMaxArgs, error) {
  var result types.SchedGetPriorityMaxArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedGetPriorityMaxArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'SchedGetPriorityMax': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedGetPriorityMaxArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Policy)
      if err != nil {
        return types.SchedGetPriorityMaxArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedGetPriorityMinArgs(log *logging.Logger, decoder *Decoder) (types.SchedGetPriorityMinArgs, error) {
  var result types.SchedGetPriorityMinArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedGetPriorityMinArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'SchedGetPriorityMin': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedGetPriorityMinArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Policy)
      if err != nil {
        return types.SchedGetPriorityMinArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedRrGetIntervalArgs(log *logging.Logger, decoder *Decoder) (types.SchedRrGetIntervalArgs, error) {
  var result types.SchedRrGetIntervalArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedRrGetIntervalArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SchedRrGetInterval': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedRrGetIntervalArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SchedRrGetIntervalArgs{}, err
      }
    case 1:
      result.Tp, err = decoder.ReadTimespec()
      if err != nil {
        return types.SchedRrGetIntervalArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMlockArgs(log *logging.Logger, decoder *Decoder) (types.MlockArgs, error) {
  var result types.MlockArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MlockArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Mlock': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MlockArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.MlockArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.MlockArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMunlockArgs(log *logging.Logger, decoder *Decoder) (types.MunlockArgs, error) {
  var result types.MunlockArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MunlockArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Munlock': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MunlockArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.MunlockArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.MunlockArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMlockallArgs(log *logging.Logger, decoder *Decoder) (types.MlockallArgs, error) {
  var result types.MlockallArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MlockallArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Mlockall': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MlockallArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.MlockallArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMunlockallArgs(log *logging.Logger, decoder *Decoder) (types.MunlockallArgs, error) {
  return types.MunlockallArgs{}, nil
}

func ParseVhangupArgs(log *logging.Logger, decoder *Decoder) (types.VhangupArgs, error) {
  return types.VhangupArgs{}, nil
}

func ParseModifyLdtArgs(log *logging.Logger, decoder *Decoder) (types.ModifyLdtArgs, error) {
  var result types.ModifyLdtArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ModifyLdtArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'ModifyLdt': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ModifyLdtArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Func)
      if err != nil {
        return types.ModifyLdtArgs{}, err
      }
    case 1:
      var dataPtr uint64
      err = decoder.DecodeUint64(&dataPtr)
      if err != nil {
        return types.ModifyLdtArgs{}, err
      }
      result.Ptr = uintptr(dataPtr)
    case 2:
      err = decoder.DecodeUint64(&result.Bytecount)
      if err != nil {
        return types.ModifyLdtArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePivotRootArgs(log *logging.Logger, decoder *Decoder) (types.PivotRootArgs, error) {
  var result types.PivotRootArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PivotRootArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'PivotRoot': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PivotRootArgs{}, err
    }

    switch currArg {
    case 0:
      result.NewRoot, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.PivotRootArgs{}, err
      }
    case 1:
      result.PutOld, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.PivotRootArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSysctlArgs(log *logging.Logger, decoder *Decoder) (types.SysctlArgs, error) {
  var result types.SysctlArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SysctlArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Sysctl': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SysctlArgs{}, err
    }

    switch currArg {
    case 0:
      var dataArgs uint64
      err = decoder.DecodeUint64(&dataArgs)
      if err != nil {
        return types.SysctlArgs{}, err
      }
      result.Args = uintptr(dataArgs)
    }
  }
  return result, nil
}

func ParsePrctlArgs(log *logging.Logger, decoder *Decoder) (types.PrctlArgs, error) {
  var result types.PrctlArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PrctlArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Prctl': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PrctlArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Option)
      if err != nil {
        return types.PrctlArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Arg2)
      if err != nil {
        return types.PrctlArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Arg3)
      if err != nil {
        return types.PrctlArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Arg4)
      if err != nil {
        return types.PrctlArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Arg5)
      if err != nil {
        return types.PrctlArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseArchPrctlArgs(log *logging.Logger, decoder *Decoder) (types.ArchPrctlArgs, error) {
  var result types.ArchPrctlArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ArchPrctlArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ArchPrctl': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ArchPrctlArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Option)
      if err != nil {
        return types.ArchPrctlArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Addr)
      if err != nil {
        return types.ArchPrctlArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseAdjtimexArgs(log *logging.Logger, decoder *Decoder) (types.AdjtimexArgs, error) {
  var result types.AdjtimexArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.AdjtimexArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Adjtimex': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.AdjtimexArgs{}, err
    }

    switch currArg {
    case 0:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.AdjtimexArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    }
  }
  return result, nil
}

func ParseSetrlimitArgs(log *logging.Logger, decoder *Decoder) (types.SetrlimitArgs, error) {
  var result types.SetrlimitArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetrlimitArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Setrlimit': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetrlimitArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Resource)
      if err != nil {
        return types.SetrlimitArgs{}, err
      }
    case 1:
      var dataRlim uint64
      err = decoder.DecodeUint64(&dataRlim)
      if err != nil {
        return types.SetrlimitArgs{}, err
      }
      result.Rlim = uintptr(dataRlim)
    }
  }
  return result, nil
}

func ParseChrootArgs(log *logging.Logger, decoder *Decoder) (types.ChrootArgs, error) {
  var result types.ChrootArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ChrootArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Chroot': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ChrootArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ChrootArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSyncArgs(log *logging.Logger, decoder *Decoder) (types.SyncArgs, error) {
  return types.SyncArgs{}, nil
}

func ParseAcctArgs(log *logging.Logger, decoder *Decoder) (types.AcctArgs, error) {
  var result types.AcctArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.AcctArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Acct': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.AcctArgs{}, err
    }

    switch currArg {
    case 0:
      result.Filename, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.AcctArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSettimeofdayArgs(log *logging.Logger, decoder *Decoder) (types.SettimeofdayArgs, error) {
  var result types.SettimeofdayArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SettimeofdayArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Settimeofday': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SettimeofdayArgs{}, err
    }

    switch currArg {
    case 0:
      var dataTv uint64
      err = decoder.DecodeUint64(&dataTv)
      if err != nil {
        return types.SettimeofdayArgs{}, err
      }
      result.Tv = uintptr(dataTv)
    case 1:
      var dataTz uint64
      err = decoder.DecodeUint64(&dataTz)
      if err != nil {
        return types.SettimeofdayArgs{}, err
      }
      result.Tz = uintptr(dataTz)
    }
  }
  return result, nil
}

func ParseMountArgs(log *logging.Logger, decoder *Decoder) (types.MountArgs, error) {
  var result types.MountArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MountArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Mount': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MountArgs{}, err
    }

    switch currArg {
    case 0:
      result.Source, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MountArgs{}, err
      }
    case 1:
      result.Target, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MountArgs{}, err
      }
    case 2:
      result.Filesystemtype, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MountArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Mountflags)
      if err != nil {
        return types.MountArgs{}, err
      }
    case 4:
      var dataData uint64
      err = decoder.DecodeUint64(&dataData)
      if err != nil {
        return types.MountArgs{}, err
      }
      result.Data = uintptr(dataData)
    }
  }
  return result, nil
}

func ParseUmount2Args(log *logging.Logger, decoder *Decoder) (types.Umount2Args, error) {
  var result types.Umount2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Umount2Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Umount2': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Umount2Args{}, err
    }

    switch currArg {
    case 0:
      result.Target, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.Umount2Args{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.Umount2Args{}, err
      }
    }
  }
  return result, nil
}

func ParseSwaponArgs(log *logging.Logger, decoder *Decoder) (types.SwaponArgs, error) {
  var result types.SwaponArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SwaponArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Swapon': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SwaponArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SwaponArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Swapflags)
      if err != nil {
        return types.SwaponArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSwapoffArgs(log *logging.Logger, decoder *Decoder) (types.SwapoffArgs, error) {
  var result types.SwapoffArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SwapoffArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Swapoff': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SwapoffArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SwapoffArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRebootArgs(log *logging.Logger, decoder *Decoder) (types.RebootArgs, error) {
  var result types.RebootArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RebootArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Reboot': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RebootArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Magic)
      if err != nil {
        return types.RebootArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Magic2)
      if err != nil {
        return types.RebootArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Cmd)
      if err != nil {
        return types.RebootArgs{}, err
      }
    case 3:
      var dataArg uint64
      err = decoder.DecodeUint64(&dataArg)
      if err != nil {
        return types.RebootArgs{}, err
      }
      result.Arg = uintptr(dataArg)
    }
  }
  return result, nil
}

func ParseSethostnameArgs(log *logging.Logger, decoder *Decoder) (types.SethostnameArgs, error) {
  var result types.SethostnameArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SethostnameArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Sethostname': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SethostnameArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SethostnameArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.SethostnameArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetdomainnameArgs(log *logging.Logger, decoder *Decoder) (types.SetdomainnameArgs, error) {
  var result types.SetdomainnameArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetdomainnameArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Setdomainname': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetdomainnameArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SetdomainnameArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.SetdomainnameArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseIoplArgs(log *logging.Logger, decoder *Decoder) (types.IoplArgs, error) {
  var result types.IoplArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoplArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Iopl': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoplArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Level)
      if err != nil {
        return types.IoplArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseIopermArgs(log *logging.Logger, decoder *Decoder) (types.IopermArgs, error) {
  var result types.IopermArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IopermArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Ioperm': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IopermArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.From)
      if err != nil {
        return types.IopermArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Num)
      if err != nil {
        return types.IopermArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.TurnOn)
      if err != nil {
        return types.IopermArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseCreateModuleArgs(log *logging.Logger, decoder *Decoder) (types.CreateModuleArgs, error) {
  return types.CreateModuleArgs{}, nil
}

func ParseInitModuleArgs(log *logging.Logger, decoder *Decoder) (types.InitModuleArgs, error) {
  var result types.InitModuleArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.InitModuleArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'InitModule': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.InitModuleArgs{}, err
    }

    switch currArg {
    case 0:
      var dataModuleImage uint64
      err = decoder.DecodeUint64(&dataModuleImage)
      if err != nil {
        return types.InitModuleArgs{}, err
      }
      result.ModuleImage = uintptr(dataModuleImage)
    case 1:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.InitModuleArgs{}, err
      }
    case 2:
      result.ParamValues, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.InitModuleArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseDeleteModuleArgs(log *logging.Logger, decoder *Decoder) (types.DeleteModuleArgs, error) {
  var result types.DeleteModuleArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.DeleteModuleArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'DeleteModule': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.DeleteModuleArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DeleteModuleArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.DeleteModuleArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetKernelSymsArgs(log *logging.Logger, decoder *Decoder) (types.GetKernelSymsArgs, error) {
  return types.GetKernelSymsArgs{}, nil
}

func ParseQueryModuleArgs(log *logging.Logger, decoder *Decoder) (types.QueryModuleArgs, error) {
  return types.QueryModuleArgs{}, nil
}

func ParseQuotactlArgs(log *logging.Logger, decoder *Decoder) (types.QuotactlArgs, error) {
  var result types.QuotactlArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.QuotactlArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Quotactl': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.QuotactlArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Cmd)
      if err != nil {
        return types.QuotactlArgs{}, err
      }
    case 1:
      result.Special, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.QuotactlArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Id)
      if err != nil {
        return types.QuotactlArgs{}, err
      }
    case 3:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.QuotactlArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    }
  }
  return result, nil
}

func ParseNfsservctlArgs(log *logging.Logger, decoder *Decoder) (types.NfsservctlArgs, error) {
  return types.NfsservctlArgs{}, nil
}

func ParseGetpmsgArgs(log *logging.Logger, decoder *Decoder) (types.GetpmsgArgs, error) {
  return types.GetpmsgArgs{}, nil
}

func ParsePutpmsgArgs(log *logging.Logger, decoder *Decoder) (types.PutpmsgArgs, error) {
  return types.PutpmsgArgs{}, nil
}

func ParseAfsArgs(log *logging.Logger, decoder *Decoder) (types.AfsArgs, error) {
  return types.AfsArgs{}, nil
}

func ParseTuxcallArgs(log *logging.Logger, decoder *Decoder) (types.TuxcallArgs, error) {
  return types.TuxcallArgs{}, nil
}

func ParseSecurityArgs(log *logging.Logger, decoder *Decoder) (types.SecurityArgs, error) {
  return types.SecurityArgs{}, nil
}

func ParseGettidArgs(log *logging.Logger, decoder *Decoder) (types.GettidArgs, error) {
  return types.GettidArgs{}, nil
}

func ParseReadaheadArgs(log *logging.Logger, decoder *Decoder) (types.ReadaheadArgs, error) {
  var result types.ReadaheadArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ReadaheadArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Readahead': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ReadaheadArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.ReadaheadArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Offset)
      if err != nil {
        return types.ReadaheadArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.ReadaheadArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetxattrArgs(log *logging.Logger, decoder *Decoder) (types.SetxattrArgs, error) {
  var result types.SetxattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetxattrArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Setxattr': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetxattrArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SetxattrArgs{}, err
      }
    case 1:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SetxattrArgs{}, err
      }
    case 2:
      var dataValue uint64
      err = decoder.DecodeUint64(&dataValue)
      if err != nil {
        return types.SetxattrArgs{}, err
      }
      result.Value = uintptr(dataValue)
    case 3:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.SetxattrArgs{}, err
      }
    case 4:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.SetxattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseLsetxattrArgs(log *logging.Logger, decoder *Decoder) (types.LsetxattrArgs, error) {
  var result types.LsetxattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LsetxattrArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Lsetxattr': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LsetxattrArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LsetxattrArgs{}, err
      }
    case 1:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LsetxattrArgs{}, err
      }
    case 2:
      var dataValue uint64
      err = decoder.DecodeUint64(&dataValue)
      if err != nil {
        return types.LsetxattrArgs{}, err
      }
      result.Value = uintptr(dataValue)
    case 3:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.LsetxattrArgs{}, err
      }
    case 4:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.LsetxattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFsetxattrArgs(log *logging.Logger, decoder *Decoder) (types.FsetxattrArgs, error) {
  var result types.FsetxattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FsetxattrArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Fsetxattr': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FsetxattrArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FsetxattrArgs{}, err
      }
    case 1:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FsetxattrArgs{}, err
      }
    case 2:
      var dataValue uint64
      err = decoder.DecodeUint64(&dataValue)
      if err != nil {
        return types.FsetxattrArgs{}, err
      }
      result.Value = uintptr(dataValue)
    case 3:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.FsetxattrArgs{}, err
      }
    case 4:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.FsetxattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetxattrArgs(log *logging.Logger, decoder *Decoder) (types.GetxattrArgs, error) {
  var result types.GetxattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetxattrArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Getxattr': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetxattrArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.GetxattrArgs{}, err
      }
    case 1:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.GetxattrArgs{}, err
      }
    case 2:
      var dataValue uint64
      err = decoder.DecodeUint64(&dataValue)
      if err != nil {
        return types.GetxattrArgs{}, err
      }
      result.Value = uintptr(dataValue)
    case 3:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.GetxattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseLgetxattrArgs(log *logging.Logger, decoder *Decoder) (types.LgetxattrArgs, error) {
  var result types.LgetxattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LgetxattrArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Lgetxattr': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LgetxattrArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LgetxattrArgs{}, err
      }
    case 1:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LgetxattrArgs{}, err
      }
    case 2:
      var dataValue uint64
      err = decoder.DecodeUint64(&dataValue)
      if err != nil {
        return types.LgetxattrArgs{}, err
      }
      result.Value = uintptr(dataValue)
    case 3:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.LgetxattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFgetxattrArgs(log *logging.Logger, decoder *Decoder) (types.FgetxattrArgs, error) {
  var result types.FgetxattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FgetxattrArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Fgetxattr': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FgetxattrArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FgetxattrArgs{}, err
      }
    case 1:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FgetxattrArgs{}, err
      }
    case 2:
      var dataValue uint64
      err = decoder.DecodeUint64(&dataValue)
      if err != nil {
        return types.FgetxattrArgs{}, err
      }
      result.Value = uintptr(dataValue)
    case 3:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.FgetxattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseListxattrArgs(log *logging.Logger, decoder *Decoder) (types.ListxattrArgs, error) {
  var result types.ListxattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ListxattrArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Listxattr': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ListxattrArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ListxattrArgs{}, err
      }
    case 1:
      result.List, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ListxattrArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.ListxattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseLlistxattrArgs(log *logging.Logger, decoder *Decoder) (types.LlistxattrArgs, error) {
  var result types.LlistxattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LlistxattrArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Llistxattr': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LlistxattrArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LlistxattrArgs{}, err
      }
    case 1:
      result.List, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LlistxattrArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.LlistxattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFlistxattrArgs(log *logging.Logger, decoder *Decoder) (types.FlistxattrArgs, error) {
  var result types.FlistxattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FlistxattrArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Flistxattr': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FlistxattrArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FlistxattrArgs{}, err
      }
    case 1:
      result.List, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FlistxattrArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.FlistxattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRemovexattrArgs(log *logging.Logger, decoder *Decoder) (types.RemovexattrArgs, error) {
  var result types.RemovexattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RemovexattrArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Removexattr': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RemovexattrArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.RemovexattrArgs{}, err
      }
    case 1:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.RemovexattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseLremovexattrArgs(log *logging.Logger, decoder *Decoder) (types.LremovexattrArgs, error) {
  var result types.LremovexattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LremovexattrArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Lremovexattr': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LremovexattrArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LremovexattrArgs{}, err
      }
    case 1:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LremovexattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFremovexattrArgs(log *logging.Logger, decoder *Decoder) (types.FremovexattrArgs, error) {
  var result types.FremovexattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FremovexattrArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Fremovexattr': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FremovexattrArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FremovexattrArgs{}, err
      }
    case 1:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FremovexattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseTkillArgs(log *logging.Logger, decoder *Decoder) (types.TkillArgs, error) {
  var result types.TkillArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TkillArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Tkill': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TkillArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Tid)
      if err != nil {
        return types.TkillArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Sig)
      if err != nil {
        return types.TkillArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseTimeArgs(log *logging.Logger, decoder *Decoder) (types.TimeArgs, error) {
  var result types.TimeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimeArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Time': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimeArgs{}, err
    }

    switch currArg {
    case 0:
      var dataTloc uint64
      err = decoder.DecodeUint64(&dataTloc)
      if err != nil {
        return types.TimeArgs{}, err
      }
      result.Tloc = uintptr(dataTloc)
    }
  }
  return result, nil
}

func ParseFutexArgs(log *logging.Logger, decoder *Decoder) (types.FutexArgs, error) {
  var result types.FutexArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FutexArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Futex': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FutexArgs{}, err
    }

    switch currArg {
    case 0:
      var dataUaddr uint64
      err = decoder.DecodeUint64(&dataUaddr)
      if err != nil {
        return types.FutexArgs{}, err
      }
      result.Uaddr = uintptr(dataUaddr)
    case 1:
      err = decoder.DecodeInt32(&result.FutexOp)
      if err != nil {
        return types.FutexArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Val)
      if err != nil {
        return types.FutexArgs{}, err
      }
    case 3:
      result.Timeout, err = decoder.ReadTimespec()
      if err != nil {
        return types.FutexArgs{}, err
      }
    case 4:
      var dataUaddr2 uint64
      err = decoder.DecodeUint64(&dataUaddr2)
      if err != nil {
        return types.FutexArgs{}, err
      }
      result.Uaddr2 = uintptr(dataUaddr2)
    case 5:
      err = decoder.DecodeInt32(&result.Val3)
      if err != nil {
        return types.FutexArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedSetaffinityArgs(log *logging.Logger, decoder *Decoder) (types.SchedSetaffinityArgs, error) {
  var result types.SchedSetaffinityArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedSetaffinityArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SchedSetaffinity': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedSetaffinityArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SchedSetaffinityArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Cpusetsize)
      if err != nil {
        return types.SchedSetaffinityArgs{}, err
      }
    case 2:
      var dataMask uint64
      err = decoder.DecodeUint64(&dataMask)
      if err != nil {
        return types.SchedSetaffinityArgs{}, err
      }
      result.Mask = uintptr(dataMask)
    }
  }
  return result, nil
}

func ParseSchedGetaffinityArgs(log *logging.Logger, decoder *Decoder) (types.SchedGetaffinityArgs, error) {
  var result types.SchedGetaffinityArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedGetaffinityArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SchedGetaffinity': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedGetaffinityArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SchedGetaffinityArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Cpusetsize)
      if err != nil {
        return types.SchedGetaffinityArgs{}, err
      }
    case 2:
      var dataMask uint64
      err = decoder.DecodeUint64(&dataMask)
      if err != nil {
        return types.SchedGetaffinityArgs{}, err
      }
      result.Mask = uintptr(dataMask)
    }
  }
  return result, nil
}

func ParseSetThreadAreaArgs(log *logging.Logger, decoder *Decoder) (types.SetThreadAreaArgs, error) {
  var result types.SetThreadAreaArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetThreadAreaArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'SetThreadArea': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetThreadAreaArgs{}, err
    }

    switch currArg {
    case 0:
      var dataUInfo uint64
      err = decoder.DecodeUint64(&dataUInfo)
      if err != nil {
        return types.SetThreadAreaArgs{}, err
      }
      result.UInfo = uintptr(dataUInfo)
    }
  }
  return result, nil
}

func ParseIoSetupArgs(log *logging.Logger, decoder *Decoder) (types.IoSetupArgs, error) {
  var result types.IoSetupArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoSetupArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'IoSetup': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoSetupArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.NrEvents)
      if err != nil {
        return types.IoSetupArgs{}, err
      }
    case 1:
      var dataCtxIdp uint64
      err = decoder.DecodeUint64(&dataCtxIdp)
      if err != nil {
        return types.IoSetupArgs{}, err
      }
      result.CtxIdp = uintptr(dataCtxIdp)
    }
  }
  return result, nil
}

func ParseIoDestroyArgs(log *logging.Logger, decoder *Decoder) (types.IoDestroyArgs, error) {
  var result types.IoDestroyArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoDestroyArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'IoDestroy': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoDestroyArgs{}, err
    }

    switch currArg {
    case 0:
      var dataCtxId uint64
      err = decoder.DecodeUint64(&dataCtxId)
      if err != nil {
        return types.IoDestroyArgs{}, err
      }
      result.CtxId = uintptr(dataCtxId)
    }
  }
  return result, nil
}

func ParseIoGeteventsArgs(log *logging.Logger, decoder *Decoder) (types.IoGeteventsArgs, error) {
  var result types.IoGeteventsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoGeteventsArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'IoGetevents': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoGeteventsArgs{}, err
    }

    switch currArg {
    case 0:
      var dataCtxId uint64
      err = decoder.DecodeUint64(&dataCtxId)
      if err != nil {
        return types.IoGeteventsArgs{}, err
      }
      result.CtxId = uintptr(dataCtxId)
    case 1:
      err = decoder.DecodeInt64(&result.MinNr)
      if err != nil {
        return types.IoGeteventsArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt64(&result.Nr)
      if err != nil {
        return types.IoGeteventsArgs{}, err
      }
    case 3:
      var dataEvents uint64
      err = decoder.DecodeUint64(&dataEvents)
      if err != nil {
        return types.IoGeteventsArgs{}, err
      }
      result.Events = uintptr(dataEvents)
    case 4:
      result.Timeout, err = decoder.ReadTimespec()
      if err != nil {
        return types.IoGeteventsArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseIoSubmitArgs(log *logging.Logger, decoder *Decoder) (types.IoSubmitArgs, error) {
  var result types.IoSubmitArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoSubmitArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'IoSubmit': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoSubmitArgs{}, err
    }

    switch currArg {
    case 0:
      var dataCtxId uint64
      err = decoder.DecodeUint64(&dataCtxId)
      if err != nil {
        return types.IoSubmitArgs{}, err
      }
      result.CtxId = uintptr(dataCtxId)
    case 1:
      err = decoder.DecodeInt64(&result.Nr)
      if err != nil {
        return types.IoSubmitArgs{}, err
      }
    case 2:
      var dataIocbpp uint64
      err = decoder.DecodeUint64(&dataIocbpp)
      if err != nil {
        return types.IoSubmitArgs{}, err
      }
      result.Iocbpp = uintptr(dataIocbpp)
    }
  }
  return result, nil
}

func ParseIoCancelArgs(log *logging.Logger, decoder *Decoder) (types.IoCancelArgs, error) {
  var result types.IoCancelArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoCancelArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'IoCancel': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoCancelArgs{}, err
    }

    switch currArg {
    case 0:
      var dataCtxId uint64
      err = decoder.DecodeUint64(&dataCtxId)
      if err != nil {
        return types.IoCancelArgs{}, err
      }
      result.CtxId = uintptr(dataCtxId)
    case 1:
      var dataIocb uint64
      err = decoder.DecodeUint64(&dataIocb)
      if err != nil {
        return types.IoCancelArgs{}, err
      }
      result.Iocb = uintptr(dataIocb)
    case 2:
      var dataResult uint64
      err = decoder.DecodeUint64(&dataResult)
      if err != nil {
        return types.IoCancelArgs{}, err
      }
      result.Result = uintptr(dataResult)
    }
  }
  return result, nil
}

func ParseGetThreadAreaArgs(log *logging.Logger, decoder *Decoder) (types.GetThreadAreaArgs, error) {
  var result types.GetThreadAreaArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetThreadAreaArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'GetThreadArea': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetThreadAreaArgs{}, err
    }

    switch currArg {
    case 0:
      var dataUInfo uint64
      err = decoder.DecodeUint64(&dataUInfo)
      if err != nil {
        return types.GetThreadAreaArgs{}, err
      }
      result.UInfo = uintptr(dataUInfo)
    }
  }
  return result, nil
}

func ParseLookupDcookieArgs(log *logging.Logger, decoder *Decoder) (types.LookupDcookieArgs, error) {
  var result types.LookupDcookieArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LookupDcookieArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'LookupDcookie': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LookupDcookieArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.Cookie)
      if err != nil {
        return types.LookupDcookieArgs{}, err
      }
    case 1:
      result.Buffer, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LookupDcookieArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.LookupDcookieArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseEpollCreateArgs(log *logging.Logger, decoder *Decoder) (types.EpollCreateArgs, error) {
  var result types.EpollCreateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.EpollCreateArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'EpollCreate': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.EpollCreateArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Size)
      if err != nil {
        return types.EpollCreateArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseEpollCtlOldArgs(log *logging.Logger, decoder *Decoder) (types.EpollCtlOldArgs, error) {
  return types.EpollCtlOldArgs{}, nil
}

func ParseEpollWaitOldArgs(log *logging.Logger, decoder *Decoder) (types.EpollWaitOldArgs, error) {
  return types.EpollWaitOldArgs{}, nil
}

func ParseRemapFilePagesArgs(log *logging.Logger, decoder *Decoder) (types.RemapFilePagesArgs, error) {
  var result types.RemapFilePagesArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RemapFilePagesArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'RemapFilePages': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RemapFilePagesArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.RemapFilePagesArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.RemapFilePagesArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Prot)
      if err != nil {
        return types.RemapFilePagesArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Pgoff)
      if err != nil {
        return types.RemapFilePagesArgs{}, err
      }
    case 4:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.RemapFilePagesArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetdents64Args(log *logging.Logger, decoder *Decoder) (types.Getdents64Args, error) {
  var result types.Getdents64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Getdents64Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Getdents64': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Getdents64Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Fd)
      if err != nil {
        return types.Getdents64Args{}, err
      }
    case 1:
      var dataDirp uint64
      err = decoder.DecodeUint64(&dataDirp)
      if err != nil {
        return types.Getdents64Args{}, err
      }
      result.Dirp = uintptr(dataDirp)
    case 2:
      err = decoder.DecodeUint32(&result.Count)
      if err != nil {
        return types.Getdents64Args{}, err
      }
    }
  }
  return result, nil
}

func ParseSetTidAddressArgs(log *logging.Logger, decoder *Decoder) (types.SetTidAddressArgs, error) {
  var result types.SetTidAddressArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetTidAddressArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'SetTidAddress': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetTidAddressArgs{}, err
    }

    switch currArg {
    case 0:
      var dataTidptr uint64
      err = decoder.DecodeUint64(&dataTidptr)
      if err != nil {
        return types.SetTidAddressArgs{}, err
      }
      result.Tidptr = uintptr(dataTidptr)
    }
  }
  return result, nil
}

func ParseRestartSyscallArgs(log *logging.Logger, decoder *Decoder) (types.RestartSyscallArgs, error) {
  return types.RestartSyscallArgs{}, nil
}

func ParseSemtimedopArgs(log *logging.Logger, decoder *Decoder) (types.SemtimedopArgs, error) {
  var result types.SemtimedopArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SemtimedopArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Semtimedop': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SemtimedopArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Semid)
      if err != nil {
        return types.SemtimedopArgs{}, err
      }
    case 1:
      var dataSops uint64
      err = decoder.DecodeUint64(&dataSops)
      if err != nil {
        return types.SemtimedopArgs{}, err
      }
      result.Sops = uintptr(dataSops)
    case 2:
      err = decoder.DecodeUint64(&result.Nsops)
      if err != nil {
        return types.SemtimedopArgs{}, err
      }
    case 3:
      result.Timeout, err = decoder.ReadTimespec()
      if err != nil {
        return types.SemtimedopArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFadvise64Args(log *logging.Logger, decoder *Decoder) (types.Fadvise64Args, error) {
  var result types.Fadvise64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Fadvise64Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Fadvise64': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Fadvise64Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Fadvise64Args{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Offset)
      if err != nil {
        return types.Fadvise64Args{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.Fadvise64Args{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Advice)
      if err != nil {
        return types.Fadvise64Args{}, err
      }
    }
  }
  return result, nil
}

func ParseTimerCreateArgs(log *logging.Logger, decoder *Decoder) (types.TimerCreateArgs, error) {
  var result types.TimerCreateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerCreateArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'TimerCreate': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerCreateArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Clockid)
      if err != nil {
        return types.TimerCreateArgs{}, err
      }
    case 1:
      var dataSevp uint64
      err = decoder.DecodeUint64(&dataSevp)
      if err != nil {
        return types.TimerCreateArgs{}, err
      }
      result.Sevp = uintptr(dataSevp)
    case 2:
      var dataTimerId uint64
      err = decoder.DecodeUint64(&dataTimerId)
      if err != nil {
        return types.TimerCreateArgs{}, err
      }
      result.TimerId = uintptr(dataTimerId)
    }
  }
  return result, nil
}

func ParseTimerSettimeArgs(log *logging.Logger, decoder *Decoder) (types.TimerSettimeArgs, error) {
  var result types.TimerSettimeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerSettimeArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'TimerSettime': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerSettimeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.TimerId)
      if err != nil {
        return types.TimerSettimeArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.TimerSettimeArgs{}, err
      }
    case 2:
      var dataNewValue uint64
      err = decoder.DecodeUint64(&dataNewValue)
      if err != nil {
        return types.TimerSettimeArgs{}, err
      }
      result.NewValue = uintptr(dataNewValue)
    case 3:
      var dataOldValue uint64
      err = decoder.DecodeUint64(&dataOldValue)
      if err != nil {
        return types.TimerSettimeArgs{}, err
      }
      result.OldValue = uintptr(dataOldValue)
    }
  }
  return result, nil
}

func ParseTimerGettimeArgs(log *logging.Logger, decoder *Decoder) (types.TimerGettimeArgs, error) {
  var result types.TimerGettimeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerGettimeArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'TimerGettime': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerGettimeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.TimerId)
      if err != nil {
        return types.TimerGettimeArgs{}, err
      }
    case 1:
      var dataCurrValue uint64
      err = decoder.DecodeUint64(&dataCurrValue)
      if err != nil {
        return types.TimerGettimeArgs{}, err
      }
      result.CurrValue = uintptr(dataCurrValue)
    }
  }
  return result, nil
}

func ParseTimerGetoverrunArgs(log *logging.Logger, decoder *Decoder) (types.TimerGetoverrunArgs, error) {
  var result types.TimerGetoverrunArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerGetoverrunArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'TimerGetoverrun': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerGetoverrunArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.TimerId)
      if err != nil {
        return types.TimerGetoverrunArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseTimerDeleteArgs(log *logging.Logger, decoder *Decoder) (types.TimerDeleteArgs, error) {
  var result types.TimerDeleteArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerDeleteArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'TimerDelete': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerDeleteArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.TimerId)
      if err != nil {
        return types.TimerDeleteArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseClockSettimeArgs(log *logging.Logger, decoder *Decoder) (types.ClockSettimeArgs, error) {
  var result types.ClockSettimeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ClockSettimeArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ClockSettime': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ClockSettimeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Clockid)
      if err != nil {
        return types.ClockSettimeArgs{}, err
      }
    case 1:
      result.Tp, err = decoder.ReadTimespec()
      if err != nil {
        return types.ClockSettimeArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseClockGettimeArgs(log *logging.Logger, decoder *Decoder) (types.ClockGettimeArgs, error) {
  var result types.ClockGettimeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ClockGettimeArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ClockGettime': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ClockGettimeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Clockid)
      if err != nil {
        return types.ClockGettimeArgs{}, err
      }
    case 1:
      result.Tp, err = decoder.ReadTimespec()
      if err != nil {
        return types.ClockGettimeArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseClockGetresArgs(log *logging.Logger, decoder *Decoder) (types.ClockGetresArgs, error) {
  var result types.ClockGetresArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ClockGetresArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ClockGetres': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ClockGetresArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Clockid)
      if err != nil {
        return types.ClockGetresArgs{}, err
      }
    case 1:
      result.Res, err = decoder.ReadTimespec()
      if err != nil {
        return types.ClockGetresArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseClockNanosleepArgs(log *logging.Logger, decoder *Decoder) (types.ClockNanosleepArgs, error) {
  var result types.ClockNanosleepArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ClockNanosleepArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'ClockNanosleep': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ClockNanosleepArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Clockid)
      if err != nil {
        return types.ClockNanosleepArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.ClockNanosleepArgs{}, err
      }
    case 2:
      result.Request, err = decoder.ReadTimespec()
      if err != nil {
        return types.ClockNanosleepArgs{}, err
      }
    case 3:
      result.Remain, err = decoder.ReadTimespec()
      if err != nil {
        return types.ClockNanosleepArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseExitGroupArgs(log *logging.Logger, decoder *Decoder) (types.ExitGroupArgs, error) {
  var result types.ExitGroupArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ExitGroupArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'ExitGroup': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ExitGroupArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Status)
      if err != nil {
        return types.ExitGroupArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseEpollWaitArgs(log *logging.Logger, decoder *Decoder) (types.EpollWaitArgs, error) {
  var result types.EpollWaitArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.EpollWaitArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'EpollWait': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.EpollWaitArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Epfd)
      if err != nil {
        return types.EpollWaitArgs{}, err
      }
    case 1:
      var dataEvents uint64
      err = decoder.DecodeUint64(&dataEvents)
      if err != nil {
        return types.EpollWaitArgs{}, err
      }
      result.Events = uintptr(dataEvents)
    case 2:
      err = decoder.DecodeInt32(&result.Maxevents)
      if err != nil {
        return types.EpollWaitArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Timeout)
      if err != nil {
        return types.EpollWaitArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseEpollCtlArgs(log *logging.Logger, decoder *Decoder) (types.EpollCtlArgs, error) {
  var result types.EpollCtlArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.EpollCtlArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'EpollCtl': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.EpollCtlArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Epfd)
      if err != nil {
        return types.EpollCtlArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Op)
      if err != nil {
        return types.EpollCtlArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.EpollCtlArgs{}, err
      }
    case 3:
      var dataEvent uint64
      err = decoder.DecodeUint64(&dataEvent)
      if err != nil {
        return types.EpollCtlArgs{}, err
      }
      result.Event = uintptr(dataEvent)
    }
  }
  return result, nil
}

func ParseTgkillArgs(log *logging.Logger, decoder *Decoder) (types.TgkillArgs, error) {
  var result types.TgkillArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TgkillArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Tgkill': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TgkillArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Tgid)
      if err != nil {
        return types.TgkillArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Tid)
      if err != nil {
        return types.TgkillArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Sig)
      if err != nil {
        return types.TgkillArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseUtimesArgs(log *logging.Logger, decoder *Decoder) (types.UtimesArgs, error) {
  var result types.UtimesArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UtimesArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Utimes': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UtimesArgs{}, err
    }

    switch currArg {
    case 0:
      result.Filename, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.UtimesArgs{}, err
      }
    case 1:
      var dataTimes uint64
      err = decoder.DecodeUint64(&dataTimes)
      if err != nil {
        return types.UtimesArgs{}, err
      }
      result.Times = uintptr(dataTimes)
    }
  }
  return result, nil
}

func ParseVserverArgs(log *logging.Logger, decoder *Decoder) (types.VserverArgs, error) {
  return types.VserverArgs{}, nil
}

func ParseMbindArgs(log *logging.Logger, decoder *Decoder) (types.MbindArgs, error) {
  var result types.MbindArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MbindArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Mbind': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MbindArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.MbindArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.MbindArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Mode)
      if err != nil {
        return types.MbindArgs{}, err
      }
    case 3:
      var dataNodemask uint64
      err = decoder.DecodeUint64(&dataNodemask)
      if err != nil {
        return types.MbindArgs{}, err
      }
      result.Nodemask = uintptr(dataNodemask)
    case 4:
      err = decoder.DecodeUint64(&result.Maxnode)
      if err != nil {
        return types.MbindArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.MbindArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetMempolicyArgs(log *logging.Logger, decoder *Decoder) (types.SetMempolicyArgs, error) {
  var result types.SetMempolicyArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetMempolicyArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SetMempolicy': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetMempolicyArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Mode)
      if err != nil {
        return types.SetMempolicyArgs{}, err
      }
    case 1:
      var dataNodemask uint64
      err = decoder.DecodeUint64(&dataNodemask)
      if err != nil {
        return types.SetMempolicyArgs{}, err
      }
      result.Nodemask = uintptr(dataNodemask)
    case 2:
      err = decoder.DecodeUint64(&result.Maxnode)
      if err != nil {
        return types.SetMempolicyArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetMempolicyArgs(log *logging.Logger, decoder *Decoder) (types.GetMempolicyArgs, error) {
  var result types.GetMempolicyArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetMempolicyArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'GetMempolicy': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetMempolicyArgs{}, err
    }

    switch currArg {
    case 0:
      var dataMode uint64
      err = decoder.DecodeUint64(&dataMode)
      if err != nil {
        return types.GetMempolicyArgs{}, err
      }
      result.Mode = uintptr(dataMode)
    case 1:
      var dataNodemask uint64
      err = decoder.DecodeUint64(&dataNodemask)
      if err != nil {
        return types.GetMempolicyArgs{}, err
      }
      result.Nodemask = uintptr(dataNodemask)
    case 2:
      err = decoder.DecodeUint64(&result.Maxnode)
      if err != nil {
        return types.GetMempolicyArgs{}, err
      }
    case 3:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.GetMempolicyArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 4:
      err = decoder.DecodeUint64(&result.Flags)
      if err != nil {
        return types.GetMempolicyArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMqOpenArgs(log *logging.Logger, decoder *Decoder) (types.MqOpenArgs, error) {
  var result types.MqOpenArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MqOpenArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'MqOpen': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MqOpenArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MqOpenArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Oflag)
      if err != nil {
        return types.MqOpenArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.MqOpenArgs{}, err
      }
    case 3:
      var dataAttr uint64
      err = decoder.DecodeUint64(&dataAttr)
      if err != nil {
        return types.MqOpenArgs{}, err
      }
      result.Attr = uintptr(dataAttr)
    }
  }
  return result, nil
}

func ParseMqUnlinkArgs(log *logging.Logger, decoder *Decoder) (types.MqUnlinkArgs, error) {
  var result types.MqUnlinkArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MqUnlinkArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'MqUnlink': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MqUnlinkArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MqUnlinkArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMqTimedsendArgs(log *logging.Logger, decoder *Decoder) (types.MqTimedsendArgs, error) {
  var result types.MqTimedsendArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MqTimedsendArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'MqTimedsend': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MqTimedsendArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Mqdes)
      if err != nil {
        return types.MqTimedsendArgs{}, err
      }
    case 1:
      result.MsgPtr, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MqTimedsendArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.MsgLen)
      if err != nil {
        return types.MqTimedsendArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.MsgPrio)
      if err != nil {
        return types.MqTimedsendArgs{}, err
      }
    case 4:
      result.AbsTimeout, err = decoder.ReadTimespec()
      if err != nil {
        return types.MqTimedsendArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMqTimedreceiveArgs(log *logging.Logger, decoder *Decoder) (types.MqTimedreceiveArgs, error) {
  var result types.MqTimedreceiveArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MqTimedreceiveArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'MqTimedreceive': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MqTimedreceiveArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Mqdes)
      if err != nil {
        return types.MqTimedreceiveArgs{}, err
      }
    case 1:
      result.MsgPtr, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MqTimedreceiveArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.MsgLen)
      if err != nil {
        return types.MqTimedreceiveArgs{}, err
      }
    case 3:
      var dataMsgPrio uint64
      err = decoder.DecodeUint64(&dataMsgPrio)
      if err != nil {
        return types.MqTimedreceiveArgs{}, err
      }
      result.MsgPrio = uintptr(dataMsgPrio)
    case 4:
      result.AbsTimeout, err = decoder.ReadTimespec()
      if err != nil {
        return types.MqTimedreceiveArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMqNotifyArgs(log *logging.Logger, decoder *Decoder) (types.MqNotifyArgs, error) {
  var result types.MqNotifyArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MqNotifyArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'MqNotify': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MqNotifyArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Mqdes)
      if err != nil {
        return types.MqNotifyArgs{}, err
      }
    case 1:
      var dataSevp uint64
      err = decoder.DecodeUint64(&dataSevp)
      if err != nil {
        return types.MqNotifyArgs{}, err
      }
      result.Sevp = uintptr(dataSevp)
    }
  }
  return result, nil
}

func ParseMqGetsetattrArgs(log *logging.Logger, decoder *Decoder) (types.MqGetsetattrArgs, error) {
  var result types.MqGetsetattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MqGetsetattrArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'MqGetsetattr': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MqGetsetattrArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Mqdes)
      if err != nil {
        return types.MqGetsetattrArgs{}, err
      }
    case 1:
      var dataNewattr uint64
      err = decoder.DecodeUint64(&dataNewattr)
      if err != nil {
        return types.MqGetsetattrArgs{}, err
      }
      result.Newattr = uintptr(dataNewattr)
    case 2:
      var dataOldattr uint64
      err = decoder.DecodeUint64(&dataOldattr)
      if err != nil {
        return types.MqGetsetattrArgs{}, err
      }
      result.Oldattr = uintptr(dataOldattr)
    }
  }
  return result, nil
}

func ParseKexecLoadArgs(log *logging.Logger, decoder *Decoder) (types.KexecLoadArgs, error) {
  var result types.KexecLoadArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.KexecLoadArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'KexecLoad': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.KexecLoadArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.Entry)
      if err != nil {
        return types.KexecLoadArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.NrSegments)
      if err != nil {
        return types.KexecLoadArgs{}, err
      }
    case 2:
      var dataSegments uint64
      err = decoder.DecodeUint64(&dataSegments)
      if err != nil {
        return types.KexecLoadArgs{}, err
      }
      result.Segments = uintptr(dataSegments)
    case 3:
      err = decoder.DecodeUint64(&result.Flags)
      if err != nil {
        return types.KexecLoadArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseWaitidArgs(log *logging.Logger, decoder *Decoder) (types.WaitidArgs, error) {
  var result types.WaitidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.WaitidArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Waitid': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.WaitidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Idtype)
      if err != nil {
        return types.WaitidArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Id)
      if err != nil {
        return types.WaitidArgs{}, err
      }
    case 2:
      var dataInfop uint64
      err = decoder.DecodeUint64(&dataInfop)
      if err != nil {
        return types.WaitidArgs{}, err
      }
      result.Infop = uintptr(dataInfop)
    case 3:
      err = decoder.DecodeInt32(&result.Options)
      if err != nil {
        return types.WaitidArgs{}, err
      }
    case 4:
      var dataRusage uint64
      err = decoder.DecodeUint64(&dataRusage)
      if err != nil {
        return types.WaitidArgs{}, err
      }
      result.Rusage = uintptr(dataRusage)
    }
  }
  return result, nil
}

func ParseAddKeyArgs(log *logging.Logger, decoder *Decoder) (types.AddKeyArgs, error) {
  var result types.AddKeyArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.AddKeyArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'AddKey': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.AddKeyArgs{}, err
    }

    switch currArg {
    case 0:
      result.Type, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.AddKeyArgs{}, err
      }
    case 1:
      result.Description, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.AddKeyArgs{}, err
      }
    case 2:
      var dataPayload uint64
      err = decoder.DecodeUint64(&dataPayload)
      if err != nil {
        return types.AddKeyArgs{}, err
      }
      result.Payload = uintptr(dataPayload)
    case 3:
      err = decoder.DecodeUint64(&result.Plen)
      if err != nil {
        return types.AddKeyArgs{}, err
      }
    case 4:
      err = decoder.DecodeInt32(&result.Keyring)
      if err != nil {
        return types.AddKeyArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRequestKeyArgs(log *logging.Logger, decoder *Decoder) (types.RequestKeyArgs, error) {
  var result types.RequestKeyArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RequestKeyArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'RequestKey': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RequestKeyArgs{}, err
    }

    switch currArg {
    case 0:
      result.Type, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.RequestKeyArgs{}, err
      }
    case 1:
      result.Description, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.RequestKeyArgs{}, err
      }
    case 2:
      result.CalloutInfo, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.RequestKeyArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.DestKeyring)
      if err != nil {
        return types.RequestKeyArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseKeyctlArgs(log *logging.Logger, decoder *Decoder) (types.KeyctlArgs, error) {
  var result types.KeyctlArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.KeyctlArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Keyctl': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.KeyctlArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Operation)
      if err != nil {
        return types.KeyctlArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Arg2)
      if err != nil {
        return types.KeyctlArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Arg3)
      if err != nil {
        return types.KeyctlArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Arg4)
      if err != nil {
        return types.KeyctlArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Arg5)
      if err != nil {
        return types.KeyctlArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseIoprioSetArgs(log *logging.Logger, decoder *Decoder) (types.IoprioSetArgs, error) {
  var result types.IoprioSetArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoprioSetArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'IoprioSet': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoprioSetArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Which)
      if err != nil {
        return types.IoprioSetArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Who)
      if err != nil {
        return types.IoprioSetArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Ioprio)
      if err != nil {
        return types.IoprioSetArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseIoprioGetArgs(log *logging.Logger, decoder *Decoder) (types.IoprioGetArgs, error) {
  var result types.IoprioGetArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoprioGetArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'IoprioGet': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoprioGetArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Which)
      if err != nil {
        return types.IoprioGetArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Who)
      if err != nil {
        return types.IoprioGetArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseInotifyInitArgs(log *logging.Logger, decoder *Decoder) (types.InotifyInitArgs, error) {
  return types.InotifyInitArgs{}, nil
}

func ParseInotifyAddWatchArgs(log *logging.Logger, decoder *Decoder) (types.InotifyAddWatchArgs, error) {
  var result types.InotifyAddWatchArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.InotifyAddWatchArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'InotifyAddWatch': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.InotifyAddWatchArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.InotifyAddWatchArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.InotifyAddWatchArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Mask)
      if err != nil {
        return types.InotifyAddWatchArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseInotifyRmWatchArgs(log *logging.Logger, decoder *Decoder) (types.InotifyRmWatchArgs, error) {
  var result types.InotifyRmWatchArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.InotifyRmWatchArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'InotifyRmWatch': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.InotifyRmWatchArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.InotifyRmWatchArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Wd)
      if err != nil {
        return types.InotifyRmWatchArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMigratePagesArgs(log *logging.Logger, decoder *Decoder) (types.MigratePagesArgs, error) {
  var result types.MigratePagesArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MigratePagesArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'MigratePages': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MigratePagesArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.MigratePagesArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Maxnode)
      if err != nil {
        return types.MigratePagesArgs{}, err
      }
    case 2:
      var dataOldNodes uint64
      err = decoder.DecodeUint64(&dataOldNodes)
      if err != nil {
        return types.MigratePagesArgs{}, err
      }
      result.OldNodes = uintptr(dataOldNodes)
    case 3:
      var dataNewNodes uint64
      err = decoder.DecodeUint64(&dataNewNodes)
      if err != nil {
        return types.MigratePagesArgs{}, err
      }
      result.NewNodes = uintptr(dataNewNodes)
    }
  }
  return result, nil
}

func ParseOpenatArgs(log *logging.Logger, decoder *Decoder) (types.OpenatArgs, error) {
  var result types.OpenatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OpenatArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Openat': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OpenatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.OpenatArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.OpenatArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.OpenatArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.OpenatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMkdiratArgs(log *logging.Logger, decoder *Decoder) (types.MkdiratArgs, error) {
  var result types.MkdiratArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MkdiratArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Mkdirat': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MkdiratArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.MkdiratArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MkdiratArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.MkdiratArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMknodatArgs(log *logging.Logger, decoder *Decoder) (types.MknodatArgs, error) {
  var result types.MknodatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MknodatArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Mknodat': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MknodatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.MknodatArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MknodatArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.MknodatArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.MknodatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFchownatArgs(log *logging.Logger, decoder *Decoder) (types.FchownatArgs, error) {
  var result types.FchownatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FchownatArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Fchownat': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FchownatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.FchownatArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FchownatArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Owner)
      if err != nil {
        return types.FchownatArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Group)
      if err != nil {
        return types.FchownatArgs{}, err
      }
    case 4:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.FchownatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFutimesatArgs(log *logging.Logger, decoder *Decoder) (types.FutimesatArgs, error) {
  var result types.FutimesatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FutimesatArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Futimesat': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FutimesatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.FutimesatArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FutimesatArgs{}, err
      }
    case 2:
      var dataTimes uint64
      err = decoder.DecodeUint64(&dataTimes)
      if err != nil {
        return types.FutimesatArgs{}, err
      }
      result.Times = uintptr(dataTimes)
    }
  }
  return result, nil
}

func ParseNewfstatatArgs(log *logging.Logger, decoder *Decoder) (types.NewfstatatArgs, error) {
  var result types.NewfstatatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NewfstatatArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Newfstatat': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NewfstatatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.NewfstatatArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NewfstatatArgs{}, err
      }
    case 2:
      var dataStatbuf uint64
      err = decoder.DecodeUint64(&dataStatbuf)
      if err != nil {
        return types.NewfstatatArgs{}, err
      }
      result.Statbuf = uintptr(dataStatbuf)
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.NewfstatatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseUnlinkatArgs(log *logging.Logger, decoder *Decoder) (types.UnlinkatArgs, error) {
  var result types.UnlinkatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UnlinkatArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Unlinkat': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UnlinkatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.UnlinkatArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.UnlinkatArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.UnlinkatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRenameatArgs(log *logging.Logger, decoder *Decoder) (types.RenameatArgs, error) {
  var result types.RenameatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RenameatArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Renameat': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RenameatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Olddirfd)
      if err != nil {
        return types.RenameatArgs{}, err
      }
    case 1:
      result.Oldpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.RenameatArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Newdirfd)
      if err != nil {
        return types.RenameatArgs{}, err
      }
    case 3:
      result.Newpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.RenameatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseLinkatArgs(log *logging.Logger, decoder *Decoder) (types.LinkatArgs, error) {
  var result types.LinkatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LinkatArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Linkat': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LinkatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Olddirfd)
      if err != nil {
        return types.LinkatArgs{}, err
      }
    case 1:
      result.Oldpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LinkatArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Newdirfd)
      if err != nil {
        return types.LinkatArgs{}, err
      }
    case 3:
      result.Newpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LinkatArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.LinkatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSymlinkatArgs(log *logging.Logger, decoder *Decoder) (types.SymlinkatArgs, error) {
  var result types.SymlinkatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SymlinkatArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Symlinkat': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SymlinkatArgs{}, err
    }

    switch currArg {
    case 0:
      result.Target, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SymlinkatArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Newdirfd)
      if err != nil {
        return types.SymlinkatArgs{}, err
      }
    case 2:
      result.Linkpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SymlinkatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseReadlinkatArgs(log *logging.Logger, decoder *Decoder) (types.ReadlinkatArgs, error) {
  var result types.ReadlinkatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ReadlinkatArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Readlinkat': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ReadlinkatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.ReadlinkatArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ReadlinkatArgs{}, err
      }
    case 2:
      result.Buf, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ReadlinkatArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Bufsiz)
      if err != nil {
        return types.ReadlinkatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFchmodatArgs(log *logging.Logger, decoder *Decoder) (types.FchmodatArgs, error) {
  var result types.FchmodatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FchmodatArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Fchmodat': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FchmodatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.FchmodatArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FchmodatArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.FchmodatArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.FchmodatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFaccessatArgs(log *logging.Logger, decoder *Decoder) (types.FaccessatArgs, error) {
  var result types.FaccessatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FaccessatArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Faccessat': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FaccessatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.FaccessatArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FaccessatArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Mode)
      if err != nil {
        return types.FaccessatArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.FaccessatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePselect6Args(log *logging.Logger, decoder *Decoder) (types.Pselect6Args, error) {
  var result types.Pselect6Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Pselect6Args{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Pselect6': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Pselect6Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Nfds)
      if err != nil {
        return types.Pselect6Args{}, err
      }
    case 1:
      var dataReadfds uint64
      err = decoder.DecodeUint64(&dataReadfds)
      if err != nil {
        return types.Pselect6Args{}, err
      }
      result.Readfds = uintptr(dataReadfds)
    case 2:
      var dataWritefds uint64
      err = decoder.DecodeUint64(&dataWritefds)
      if err != nil {
        return types.Pselect6Args{}, err
      }
      result.Writefds = uintptr(dataWritefds)
    case 3:
      var dataExceptfds uint64
      err = decoder.DecodeUint64(&dataExceptfds)
      if err != nil {
        return types.Pselect6Args{}, err
      }
      result.Exceptfds = uintptr(dataExceptfds)
    case 4:
      result.Timeout, err = decoder.ReadTimespec()
      if err != nil {
        return types.Pselect6Args{}, err
      }
    case 5:
      var dataSigmask uint64
      err = decoder.DecodeUint64(&dataSigmask)
      if err != nil {
        return types.Pselect6Args{}, err
      }
      result.Sigmask = uintptr(dataSigmask)
    }
  }
  return result, nil
}

func ParsePpollArgs(log *logging.Logger, decoder *Decoder) (types.PpollArgs, error) {
  var result types.PpollArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PpollArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Ppoll': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PpollArgs{}, err
    }

    switch currArg {
    case 0:
      var dataFds uint64
      err = decoder.DecodeUint64(&dataFds)
      if err != nil {
        return types.PpollArgs{}, err
      }
      result.Fds = uintptr(dataFds)
    case 1:
      err = decoder.DecodeUint32(&result.Nfds)
      if err != nil {
        return types.PpollArgs{}, err
      }
    case 2:
      result.TmoP, err = decoder.ReadTimespec()
      if err != nil {
        return types.PpollArgs{}, err
      }
    case 3:
      var dataSigmask uint64
      err = decoder.DecodeUint64(&dataSigmask)
      if err != nil {
        return types.PpollArgs{}, err
      }
      result.Sigmask = uintptr(dataSigmask)
    case 4:
      err = decoder.DecodeUint64(&result.Sigsetsize)
      if err != nil {
        return types.PpollArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseUnshareArgs(log *logging.Logger, decoder *Decoder) (types.UnshareArgs, error) {
  var result types.UnshareArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UnshareArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Unshare': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UnshareArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.UnshareArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetRobustListArgs(log *logging.Logger, decoder *Decoder) (types.SetRobustListArgs, error) {
  var result types.SetRobustListArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetRobustListArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SetRobustList': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetRobustListArgs{}, err
    }

    switch currArg {
    case 0:
      var dataHead uint64
      err = decoder.DecodeUint64(&dataHead)
      if err != nil {
        return types.SetRobustListArgs{}, err
      }
      result.Head = uintptr(dataHead)
    case 1:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.SetRobustListArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetRobustListArgs(log *logging.Logger, decoder *Decoder) (types.GetRobustListArgs, error) {
  var result types.GetRobustListArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetRobustListArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'GetRobustList': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetRobustListArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.GetRobustListArgs{}, err
      }
    case 1:
      var dataHeadPtr uint64
      err = decoder.DecodeUint64(&dataHeadPtr)
      if err != nil {
        return types.GetRobustListArgs{}, err
      }
      result.HeadPtr = uintptr(dataHeadPtr)
    case 2:
      var dataLenPtr uint64
      err = decoder.DecodeUint64(&dataLenPtr)
      if err != nil {
        return types.GetRobustListArgs{}, err
      }
      result.LenPtr = uintptr(dataLenPtr)
    }
  }
  return result, nil
}

func ParseSpliceArgs(log *logging.Logger, decoder *Decoder) (types.SpliceArgs, error) {
  var result types.SpliceArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SpliceArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Splice': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SpliceArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.FdIn)
      if err != nil {
        return types.SpliceArgs{}, err
      }
    case 1:
      var dataOffIn uint64
      err = decoder.DecodeUint64(&dataOffIn)
      if err != nil {
        return types.SpliceArgs{}, err
      }
      result.OffIn = uintptr(dataOffIn)
    case 2:
      err = decoder.DecodeInt32(&result.FdOut)
      if err != nil {
        return types.SpliceArgs{}, err
      }
    case 3:
      var dataOffOut uint64
      err = decoder.DecodeUint64(&dataOffOut)
      if err != nil {
        return types.SpliceArgs{}, err
      }
      result.OffOut = uintptr(dataOffOut)
    case 4:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.SpliceArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.SpliceArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseTeeArgs(log *logging.Logger, decoder *Decoder) (types.TeeArgs, error) {
  var result types.TeeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TeeArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Tee': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TeeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.FdIn)
      if err != nil {
        return types.TeeArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.FdOut)
      if err != nil {
        return types.TeeArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.TeeArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.TeeArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSyncFileRangeArgs(log *logging.Logger, decoder *Decoder) (types.SyncFileRangeArgs, error) {
  var result types.SyncFileRangeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SyncFileRangeArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'SyncFileRange': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SyncFileRangeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.SyncFileRangeArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Offset)
      if err != nil {
        return types.SyncFileRangeArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Nbytes)
      if err != nil {
        return types.SyncFileRangeArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.SyncFileRangeArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseVmspliceArgs(log *logging.Logger, decoder *Decoder) (types.VmspliceArgs, error) {
  var result types.VmspliceArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.VmspliceArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Vmsplice': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.VmspliceArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.VmspliceArgs{}, err
      }
    case 1:
      var dataIov uint64
      err = decoder.DecodeUint64(&dataIov)
      if err != nil {
        return types.VmspliceArgs{}, err
      }
      result.Iov = uintptr(dataIov)
    case 2:
      err = decoder.DecodeUint64(&result.NrSegs)
      if err != nil {
        return types.VmspliceArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.VmspliceArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMovePagesArgs(log *logging.Logger, decoder *Decoder) (types.MovePagesArgs, error) {
  var result types.MovePagesArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MovePagesArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'MovePages': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MovePagesArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.MovePagesArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.MovePagesArgs{}, err
      }
    case 2:
      var dataPages uint64
      err = decoder.DecodeUint64(&dataPages)
      if err != nil {
        return types.MovePagesArgs{}, err
      }
      result.Pages = uintptr(dataPages)
    case 3:
      var dataNodes uint64
      err = decoder.DecodeUint64(&dataNodes)
      if err != nil {
        return types.MovePagesArgs{}, err
      }
      result.Nodes = uintptr(dataNodes)
    case 4:
      var dataStatus uint64
      err = decoder.DecodeUint64(&dataStatus)
      if err != nil {
        return types.MovePagesArgs{}, err
      }
      result.Status = uintptr(dataStatus)
    case 5:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.MovePagesArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseUtimensatArgs(log *logging.Logger, decoder *Decoder) (types.UtimensatArgs, error) {
  var result types.UtimensatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UtimensatArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Utimensat': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UtimensatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.UtimensatArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.UtimensatArgs{}, err
      }
    case 2:
      result.Times, err = decoder.ReadTimespec()
      if err != nil {
        return types.UtimensatArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.UtimensatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseEpollPwaitArgs(log *logging.Logger, decoder *Decoder) (types.EpollPwaitArgs, error) {
  var result types.EpollPwaitArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.EpollPwaitArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'EpollPwait': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.EpollPwaitArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Epfd)
      if err != nil {
        return types.EpollPwaitArgs{}, err
      }
    case 1:
      var dataEvents uint64
      err = decoder.DecodeUint64(&dataEvents)
      if err != nil {
        return types.EpollPwaitArgs{}, err
      }
      result.Events = uintptr(dataEvents)
    case 2:
      err = decoder.DecodeInt32(&result.Maxevents)
      if err != nil {
        return types.EpollPwaitArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Timeout)
      if err != nil {
        return types.EpollPwaitArgs{}, err
      }
    case 4:
      var dataSigmask uint64
      err = decoder.DecodeUint64(&dataSigmask)
      if err != nil {
        return types.EpollPwaitArgs{}, err
      }
      result.Sigmask = uintptr(dataSigmask)
    case 5:
      err = decoder.DecodeUint64(&result.Sigsetsize)
      if err != nil {
        return types.EpollPwaitArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSignalfdArgs(log *logging.Logger, decoder *Decoder) (types.SignalfdArgs, error) {
  var result types.SignalfdArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SignalfdArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Signalfd': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SignalfdArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.SignalfdArgs{}, err
      }
    case 1:
      var dataMask uint64
      err = decoder.DecodeUint64(&dataMask)
      if err != nil {
        return types.SignalfdArgs{}, err
      }
      result.Mask = uintptr(dataMask)
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.SignalfdArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseTimerfdCreateArgs(log *logging.Logger, decoder *Decoder) (types.TimerfdCreateArgs, error) {
  var result types.TimerfdCreateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerfdCreateArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'TimerfdCreate': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerfdCreateArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Clockid)
      if err != nil {
        return types.TimerfdCreateArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.TimerfdCreateArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseEventfdArgs(log *logging.Logger, decoder *Decoder) (types.EventfdArgs, error) {
  var result types.EventfdArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.EventfdArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Eventfd': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.EventfdArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Initval)
      if err != nil {
        return types.EventfdArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.EventfdArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFallocateArgs(log *logging.Logger, decoder *Decoder) (types.FallocateArgs, error) {
  var result types.FallocateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FallocateArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Fallocate': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FallocateArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FallocateArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Mode)
      if err != nil {
        return types.FallocateArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Offset)
      if err != nil {
        return types.FallocateArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.FallocateArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseTimerfdSettimeArgs(log *logging.Logger, decoder *Decoder) (types.TimerfdSettimeArgs, error) {
  var result types.TimerfdSettimeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerfdSettimeArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'TimerfdSettime': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerfdSettimeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.TimerfdSettimeArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.TimerfdSettimeArgs{}, err
      }
    case 2:
      var dataNewValue uint64
      err = decoder.DecodeUint64(&dataNewValue)
      if err != nil {
        return types.TimerfdSettimeArgs{}, err
      }
      result.NewValue = uintptr(dataNewValue)
    case 3:
      var dataOldValue uint64
      err = decoder.DecodeUint64(&dataOldValue)
      if err != nil {
        return types.TimerfdSettimeArgs{}, err
      }
      result.OldValue = uintptr(dataOldValue)
    }
  }
  return result, nil
}

func ParseTimerfdGettimeArgs(log *logging.Logger, decoder *Decoder) (types.TimerfdGettimeArgs, error) {
  var result types.TimerfdGettimeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerfdGettimeArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'TimerfdGettime': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerfdGettimeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.TimerfdGettimeArgs{}, err
      }
    case 1:
      var dataCurrValue uint64
      err = decoder.DecodeUint64(&dataCurrValue)
      if err != nil {
        return types.TimerfdGettimeArgs{}, err
      }
      result.CurrValue = uintptr(dataCurrValue)
    }
  }
  return result, nil
}

func ParseAccept4Args(log *logging.Logger, decoder *Decoder) (types.Accept4Args, error) {
  var result types.Accept4Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Accept4Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Accept4': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Accept4Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.Accept4Args{}, err
      }
    case 1:
      result.Addr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.Accept4Args{}, err
      }
    case 2:
      var dataAddrlen uint64
      err = decoder.DecodeUint64(&dataAddrlen)
      if err != nil {
        return types.Accept4Args{}, err
      }
      result.Addrlen = uintptr(dataAddrlen)
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.Accept4Args{}, err
      }
    }
  }
  return result, nil
}

func ParseSignalfd4Args(log *logging.Logger, decoder *Decoder) (types.Signalfd4Args, error) {
  var result types.Signalfd4Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Signalfd4Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Signalfd4': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Signalfd4Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Signalfd4Args{}, err
      }
    case 1:
      var dataMask uint64
      err = decoder.DecodeUint64(&dataMask)
      if err != nil {
        return types.Signalfd4Args{}, err
      }
      result.Mask = uintptr(dataMask)
    case 2:
      err = decoder.DecodeUint64(&result.Sizemask)
      if err != nil {
        return types.Signalfd4Args{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.Signalfd4Args{}, err
      }
    }
  }
  return result, nil
}

func ParseEventfd2Args(log *logging.Logger, decoder *Decoder) (types.Eventfd2Args, error) {
  var result types.Eventfd2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Eventfd2Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Eventfd2': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Eventfd2Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Initval)
      if err != nil {
        return types.Eventfd2Args{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.Eventfd2Args{}, err
      }
    }
  }
  return result, nil
}

func ParseEpollCreate1Args(log *logging.Logger, decoder *Decoder) (types.EpollCreate1Args, error) {
  var result types.EpollCreate1Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.EpollCreate1Args{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'EpollCreate1': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.EpollCreate1Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.EpollCreate1Args{}, err
      }
    }
  }
  return result, nil
}

func ParseDup3Args(log *logging.Logger, decoder *Decoder) (types.Dup3Args, error) {
  var result types.Dup3Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Dup3Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Dup3': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Dup3Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Oldfd)
      if err != nil {
        return types.Dup3Args{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Newfd)
      if err != nil {
        return types.Dup3Args{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.Dup3Args{}, err
      }
    }
  }
  return result, nil
}

func ParsePipe2Args(log *logging.Logger, decoder *Decoder) (types.Pipe2Args, error) {
  var result types.Pipe2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Pipe2Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Pipe2': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Pipe2Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeIntArray(result.Pipefd[:], 2)
      if err != nil {
        return types.Pipe2Args{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.Pipe2Args{}, err
      }
    }
  }
  return result, nil
}

func ParseInotifyInit1Args(log *logging.Logger, decoder *Decoder) (types.InotifyInit1Args, error) {
  var result types.InotifyInit1Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.InotifyInit1Args{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'InotifyInit1': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.InotifyInit1Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.InotifyInit1Args{}, err
      }
    }
  }
  return result, nil
}

func ParsePreadvArgs(log *logging.Logger, decoder *Decoder) (types.PreadvArgs, error) {
  var result types.PreadvArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PreadvArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Preadv': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PreadvArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.PreadvArgs{}, err
      }
    case 1:
      var dataIov uint64
      err = decoder.DecodeUint64(&dataIov)
      if err != nil {
        return types.PreadvArgs{}, err
      }
      result.Iov = uintptr(dataIov)
    case 2:
      err = decoder.DecodeUint64(&result.Iovcnt)
      if err != nil {
        return types.PreadvArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.PosL)
      if err != nil {
        return types.PreadvArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.PosH)
      if err != nil {
        return types.PreadvArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePwritevArgs(log *logging.Logger, decoder *Decoder) (types.PwritevArgs, error) {
  var result types.PwritevArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PwritevArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Pwritev': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PwritevArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.PwritevArgs{}, err
      }
    case 1:
      var dataIov uint64
      err = decoder.DecodeUint64(&dataIov)
      if err != nil {
        return types.PwritevArgs{}, err
      }
      result.Iov = uintptr(dataIov)
    case 2:
      err = decoder.DecodeUint64(&result.Iovcnt)
      if err != nil {
        return types.PwritevArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.PosL)
      if err != nil {
        return types.PwritevArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.PosH)
      if err != nil {
        return types.PwritevArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRtTgsigqueueinfoArgs(log *logging.Logger, decoder *Decoder) (types.RtTgsigqueueinfoArgs, error) {
  var result types.RtTgsigqueueinfoArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RtTgsigqueueinfoArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'RtTgsigqueueinfo': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RtTgsigqueueinfoArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Tgid)
      if err != nil {
        return types.RtTgsigqueueinfoArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Tid)
      if err != nil {
        return types.RtTgsigqueueinfoArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Sig)
      if err != nil {
        return types.RtTgsigqueueinfoArgs{}, err
      }
    case 3:
      var dataInfo uint64
      err = decoder.DecodeUint64(&dataInfo)
      if err != nil {
        return types.RtTgsigqueueinfoArgs{}, err
      }
      result.Info = uintptr(dataInfo)
    }
  }
  return result, nil
}

func ParsePerfEventOpenArgs(log *logging.Logger, decoder *Decoder) (types.PerfEventOpenArgs, error) {
  var result types.PerfEventOpenArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PerfEventOpenArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'PerfEventOpen': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PerfEventOpenArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAttr uint64
      err = decoder.DecodeUint64(&dataAttr)
      if err != nil {
        return types.PerfEventOpenArgs{}, err
      }
      result.Attr = uintptr(dataAttr)
    case 1:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.PerfEventOpenArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Cpu)
      if err != nil {
        return types.PerfEventOpenArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.GroupFd)
      if err != nil {
        return types.PerfEventOpenArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Flags)
      if err != nil {
        return types.PerfEventOpenArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRecvmmsgArgs(log *logging.Logger, decoder *Decoder) (types.RecvmmsgArgs, error) {
  var result types.RecvmmsgArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RecvmmsgArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Recvmmsg': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RecvmmsgArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.RecvmmsgArgs{}, err
      }
    case 1:
      var dataMsgvec uint64
      err = decoder.DecodeUint64(&dataMsgvec)
      if err != nil {
        return types.RecvmmsgArgs{}, err
      }
      result.Msgvec = uintptr(dataMsgvec)
    case 2:
      err = decoder.DecodeUint32(&result.Vlen)
      if err != nil {
        return types.RecvmmsgArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.RecvmmsgArgs{}, err
      }
    case 4:
      result.Timeout, err = decoder.ReadTimespec()
      if err != nil {
        return types.RecvmmsgArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFanotifyInitArgs(log *logging.Logger, decoder *Decoder) (types.FanotifyInitArgs, error) {
  var result types.FanotifyInitArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FanotifyInitArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'FanotifyInit': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FanotifyInitArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.FanotifyInitArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.EventFFlags)
      if err != nil {
        return types.FanotifyInitArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFanotifyMarkArgs(log *logging.Logger, decoder *Decoder) (types.FanotifyMarkArgs, error) {
  var result types.FanotifyMarkArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FanotifyMarkArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'FanotifyMark': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FanotifyMarkArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.FanotifyFd)
      if err != nil {
        return types.FanotifyMarkArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.FanotifyMarkArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Mask)
      if err != nil {
        return types.FanotifyMarkArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.FanotifyMarkArgs{}, err
      }
    case 4:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FanotifyMarkArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePrlimit64Args(log *logging.Logger, decoder *Decoder) (types.Prlimit64Args, error) {
  var result types.Prlimit64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Prlimit64Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Prlimit64': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Prlimit64Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.Prlimit64Args{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Resource)
      if err != nil {
        return types.Prlimit64Args{}, err
      }
    case 2:
      var dataNewLimit uint64
      err = decoder.DecodeUint64(&dataNewLimit)
      if err != nil {
        return types.Prlimit64Args{}, err
      }
      result.NewLimit = uintptr(dataNewLimit)
    case 3:
      var dataOldLimit uint64
      err = decoder.DecodeUint64(&dataOldLimit)
      if err != nil {
        return types.Prlimit64Args{}, err
      }
      result.OldLimit = uintptr(dataOldLimit)
    }
  }
  return result, nil
}

func ParseNameToHandleAtArgs(log *logging.Logger, decoder *Decoder) (types.NameToHandleAtArgs, error) {
  var result types.NameToHandleAtArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NameToHandleAtArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'NameToHandleAt': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NameToHandleAtArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.NameToHandleAtArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NameToHandleAtArgs{}, err
      }
    case 2:
      var dataHandle uint64
      err = decoder.DecodeUint64(&dataHandle)
      if err != nil {
        return types.NameToHandleAtArgs{}, err
      }
      result.Handle = uintptr(dataHandle)
    case 3:
      var dataMountId uint64
      err = decoder.DecodeUint64(&dataMountId)
      if err != nil {
        return types.NameToHandleAtArgs{}, err
      }
      result.MountId = uintptr(dataMountId)
    case 4:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.NameToHandleAtArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseOpenByHandleAtArgs(log *logging.Logger, decoder *Decoder) (types.OpenByHandleAtArgs, error) {
  var result types.OpenByHandleAtArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OpenByHandleAtArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'OpenByHandleAt': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OpenByHandleAtArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.MountFd)
      if err != nil {
        return types.OpenByHandleAtArgs{}, err
      }
    case 1:
      var dataHandle uint64
      err = decoder.DecodeUint64(&dataHandle)
      if err != nil {
        return types.OpenByHandleAtArgs{}, err
      }
      result.Handle = uintptr(dataHandle)
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.OpenByHandleAtArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseClockAdjtimeArgs(log *logging.Logger, decoder *Decoder) (types.ClockAdjtimeArgs, error) {
  var result types.ClockAdjtimeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ClockAdjtimeArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ClockAdjtime': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ClockAdjtimeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.ClkId)
      if err != nil {
        return types.ClockAdjtimeArgs{}, err
      }
    case 1:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.ClockAdjtimeArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    }
  }
  return result, nil
}

func ParseSyncfsArgs(log *logging.Logger, decoder *Decoder) (types.SyncfsArgs, error) {
  var result types.SyncfsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SyncfsArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Syncfs': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SyncfsArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.SyncfsArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSendmmsgArgs(log *logging.Logger, decoder *Decoder) (types.SendmmsgArgs, error) {
  var result types.SendmmsgArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SendmmsgArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Sendmmsg': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SendmmsgArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.SendmmsgArgs{}, err
      }
    case 1:
      var dataMsgvec uint64
      err = decoder.DecodeUint64(&dataMsgvec)
      if err != nil {
        return types.SendmmsgArgs{}, err
      }
      result.Msgvec = uintptr(dataMsgvec)
    case 2:
      err = decoder.DecodeUint32(&result.Vlen)
      if err != nil {
        return types.SendmmsgArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.SendmmsgArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSetnsArgs(log *logging.Logger, decoder *Decoder) (types.SetnsArgs, error) {
  var result types.SetnsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SetnsArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Setns': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SetnsArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.SetnsArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Nstype)
      if err != nil {
        return types.SetnsArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseGetcpuArgs(log *logging.Logger, decoder *Decoder) (types.GetcpuArgs, error) {
  var result types.GetcpuArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetcpuArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Getcpu': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetcpuArgs{}, err
    }

    switch currArg {
    case 0:
      var dataCpu uint64
      err = decoder.DecodeUint64(&dataCpu)
      if err != nil {
        return types.GetcpuArgs{}, err
      }
      result.Cpu = uintptr(dataCpu)
    case 1:
      var dataNode uint64
      err = decoder.DecodeUint64(&dataNode)
      if err != nil {
        return types.GetcpuArgs{}, err
      }
      result.Node = uintptr(dataNode)
    case 2:
      var dataTcache uint64
      err = decoder.DecodeUint64(&dataTcache)
      if err != nil {
        return types.GetcpuArgs{}, err
      }
      result.Tcache = uintptr(dataTcache)
    }
  }
  return result, nil
}

func ParseProcessVmReadvArgs(log *logging.Logger, decoder *Decoder) (types.ProcessVmReadvArgs, error) {
  var result types.ProcessVmReadvArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ProcessVmReadvArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'ProcessVmReadv': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ProcessVmReadvArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.ProcessVmReadvArgs{}, err
      }
    case 1:
      var dataLocalIov uint64
      err = decoder.DecodeUint64(&dataLocalIov)
      if err != nil {
        return types.ProcessVmReadvArgs{}, err
      }
      result.LocalIov = uintptr(dataLocalIov)
    case 2:
      err = decoder.DecodeUint64(&result.Liovcnt)
      if err != nil {
        return types.ProcessVmReadvArgs{}, err
      }
    case 3:
      var dataRemoteIov uint64
      err = decoder.DecodeUint64(&dataRemoteIov)
      if err != nil {
        return types.ProcessVmReadvArgs{}, err
      }
      result.RemoteIov = uintptr(dataRemoteIov)
    case 4:
      err = decoder.DecodeUint64(&result.Riovcnt)
      if err != nil {
        return types.ProcessVmReadvArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint64(&result.Flags)
      if err != nil {
        return types.ProcessVmReadvArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseProcessVmWritevArgs(log *logging.Logger, decoder *Decoder) (types.ProcessVmWritevArgs, error) {
  var result types.ProcessVmWritevArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ProcessVmWritevArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'ProcessVmWritev': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ProcessVmWritevArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.ProcessVmWritevArgs{}, err
      }
    case 1:
      var dataLocalIov uint64
      err = decoder.DecodeUint64(&dataLocalIov)
      if err != nil {
        return types.ProcessVmWritevArgs{}, err
      }
      result.LocalIov = uintptr(dataLocalIov)
    case 2:
      err = decoder.DecodeUint64(&result.Liovcnt)
      if err != nil {
        return types.ProcessVmWritevArgs{}, err
      }
    case 3:
      var dataRemoteIov uint64
      err = decoder.DecodeUint64(&dataRemoteIov)
      if err != nil {
        return types.ProcessVmWritevArgs{}, err
      }
      result.RemoteIov = uintptr(dataRemoteIov)
    case 4:
      err = decoder.DecodeUint64(&result.Riovcnt)
      if err != nil {
        return types.ProcessVmWritevArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint64(&result.Flags)
      if err != nil {
        return types.ProcessVmWritevArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseKcmpArgs(log *logging.Logger, decoder *Decoder) (types.KcmpArgs, error) {
  var result types.KcmpArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.KcmpArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Kcmp': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.KcmpArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid1)
      if err != nil {
        return types.KcmpArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Pid2)
      if err != nil {
        return types.KcmpArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Type)
      if err != nil {
        return types.KcmpArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Idx1)
      if err != nil {
        return types.KcmpArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Idx2)
      if err != nil {
        return types.KcmpArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFinitModuleArgs(log *logging.Logger, decoder *Decoder) (types.FinitModuleArgs, error) {
  var result types.FinitModuleArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FinitModuleArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'FinitModule': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FinitModuleArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.FinitModuleArgs{}, err
      }
    case 1:
      result.ParamValues, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FinitModuleArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.FinitModuleArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedSetattrArgs(log *logging.Logger, decoder *Decoder) (types.SchedSetattrArgs, error) {
  var result types.SchedSetattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedSetattrArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SchedSetattr': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedSetattrArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SchedSetattrArgs{}, err
      }
    case 1:
      var dataAttr uint64
      err = decoder.DecodeUint64(&dataAttr)
      if err != nil {
        return types.SchedSetattrArgs{}, err
      }
      result.Attr = uintptr(dataAttr)
    case 2:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.SchedSetattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedGetattrArgs(log *logging.Logger, decoder *Decoder) (types.SchedGetattrArgs, error) {
  var result types.SchedGetattrArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedGetattrArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'SchedGetattr': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedGetattrArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SchedGetattrArgs{}, err
      }
    case 1:
      var dataAttr uint64
      err = decoder.DecodeUint64(&dataAttr)
      if err != nil {
        return types.SchedGetattrArgs{}, err
      }
      result.Attr = uintptr(dataAttr)
    case 2:
      err = decoder.DecodeUint32(&result.Size)
      if err != nil {
        return types.SchedGetattrArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.SchedGetattrArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRenameat2Args(log *logging.Logger, decoder *Decoder) (types.Renameat2Args, error) {
  var result types.Renameat2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Renameat2Args{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Renameat2': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Renameat2Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Olddirfd)
      if err != nil {
        return types.Renameat2Args{}, err
      }
    case 1:
      result.Oldpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.Renameat2Args{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Newdirfd)
      if err != nil {
        return types.Renameat2Args{}, err
      }
    case 3:
      result.Newpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.Renameat2Args{}, err
      }
    case 4:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.Renameat2Args{}, err
      }
    }
  }
  return result, nil
}

func ParseSeccompArgs(log *logging.Logger, decoder *Decoder) (types.SeccompArgs, error) {
  var result types.SeccompArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SeccompArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Seccomp': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SeccompArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Operation)
      if err != nil {
        return types.SeccompArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.SeccompArgs{}, err
      }
    case 2:
      var dataArgs uint64
      err = decoder.DecodeUint64(&dataArgs)
      if err != nil {
        return types.SeccompArgs{}, err
      }
      result.Args = uintptr(dataArgs)
    }
  }
  return result, nil
}

func ParseGetrandomArgs(log *logging.Logger, decoder *Decoder) (types.GetrandomArgs, error) {
  var result types.GetrandomArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.GetrandomArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Getrandom': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.GetrandomArgs{}, err
    }

    switch currArg {
    case 0:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.GetrandomArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    case 1:
      err = decoder.DecodeUint64(&result.Buflen)
      if err != nil {
        return types.GetrandomArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.GetrandomArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMemfdCreateArgs(log *logging.Logger, decoder *Decoder) (types.MemfdCreateArgs, error) {
  var result types.MemfdCreateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MemfdCreateArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'MemfdCreate': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MemfdCreateArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MemfdCreateArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.MemfdCreateArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseKexecFileLoadArgs(log *logging.Logger, decoder *Decoder) (types.KexecFileLoadArgs, error) {
  var result types.KexecFileLoadArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.KexecFileLoadArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'KexecFileLoad': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.KexecFileLoadArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.KernelFd)
      if err != nil {
        return types.KexecFileLoadArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.InitrdFd)
      if err != nil {
        return types.KexecFileLoadArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.CmdlineLen)
      if err != nil {
        return types.KexecFileLoadArgs{}, err
      }
    case 3:
      result.Cmdline, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.KexecFileLoadArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Flags)
      if err != nil {
        return types.KexecFileLoadArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseBpfArgs(log *logging.Logger, decoder *Decoder) (types.BpfArgs, error) {
  var result types.BpfArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.BpfArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Bpf': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.BpfArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Cmd)
      if err != nil {
        return types.BpfArgs{}, err
      }
    case 1:
      var dataAttr uint64
      err = decoder.DecodeUint64(&dataAttr)
      if err != nil {
        return types.BpfArgs{}, err
      }
      result.Attr = uintptr(dataAttr)
    case 2:
      err = decoder.DecodeUint32(&result.Size)
      if err != nil {
        return types.BpfArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseExecveatArgs(log *logging.Logger, decoder *Decoder) (types.ExecveatArgs, error) {
  var result types.ExecveatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ExecveatArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Execveat': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ExecveatArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.ExecveatArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ExecveatArgs{}, err
      }
    case 2:
      result.Argv, err = decoder.ReadStringArrayFromBuff()
      if err != nil {
        return types.ExecveatArgs{}, err
      }
    case 3:
      result.Envp, err = decoder.ReadStringArrayFromBuff()
      if err != nil {
        return types.ExecveatArgs{}, err
      }
    case 4:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.ExecveatArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseUserfaultfdArgs(log *logging.Logger, decoder *Decoder) (types.UserfaultfdArgs, error) {
  var result types.UserfaultfdArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UserfaultfdArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Userfaultfd': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UserfaultfdArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.UserfaultfdArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMembarrierArgs(log *logging.Logger, decoder *Decoder) (types.MembarrierArgs, error) {
  var result types.MembarrierArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MembarrierArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Membarrier': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MembarrierArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Cmd)
      if err != nil {
        return types.MembarrierArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.MembarrierArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMlock2Args(log *logging.Logger, decoder *Decoder) (types.Mlock2Args, error) {
  var result types.Mlock2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Mlock2Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Mlock2': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Mlock2Args{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.Mlock2Args{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.Mlock2Args{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.Mlock2Args{}, err
      }
    }
  }
  return result, nil
}

func ParseCopyFileRangeArgs(log *logging.Logger, decoder *Decoder) (types.CopyFileRangeArgs, error) {
  var result types.CopyFileRangeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CopyFileRangeArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'CopyFileRange': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CopyFileRangeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.FdIn)
      if err != nil {
        return types.CopyFileRangeArgs{}, err
      }
    case 1:
      var dataOffIn uint64
      err = decoder.DecodeUint64(&dataOffIn)
      if err != nil {
        return types.CopyFileRangeArgs{}, err
      }
      result.OffIn = uintptr(dataOffIn)
    case 2:
      err = decoder.DecodeInt32(&result.FdOut)
      if err != nil {
        return types.CopyFileRangeArgs{}, err
      }
    case 3:
      var dataOffOut uint64
      err = decoder.DecodeUint64(&dataOffOut)
      if err != nil {
        return types.CopyFileRangeArgs{}, err
      }
      result.OffOut = uintptr(dataOffOut)
    case 4:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.CopyFileRangeArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.CopyFileRangeArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePreadv2Args(log *logging.Logger, decoder *Decoder) (types.Preadv2Args, error) {
  var result types.Preadv2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Preadv2Args{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Preadv2': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Preadv2Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Preadv2Args{}, err
      }
    case 1:
      var dataIov uint64
      err = decoder.DecodeUint64(&dataIov)
      if err != nil {
        return types.Preadv2Args{}, err
      }
      result.Iov = uintptr(dataIov)
    case 2:
      err = decoder.DecodeUint64(&result.Iovcnt)
      if err != nil {
        return types.Preadv2Args{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.PosL)
      if err != nil {
        return types.Preadv2Args{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.PosH)
      if err != nil {
        return types.Preadv2Args{}, err
      }
    case 5:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.Preadv2Args{}, err
      }
    }
  }
  return result, nil
}

func ParsePwritev2Args(log *logging.Logger, decoder *Decoder) (types.Pwritev2Args, error) {
  var result types.Pwritev2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Pwritev2Args{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Pwritev2': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Pwritev2Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Pwritev2Args{}, err
      }
    case 1:
      var dataIov uint64
      err = decoder.DecodeUint64(&dataIov)
      if err != nil {
        return types.Pwritev2Args{}, err
      }
      result.Iov = uintptr(dataIov)
    case 2:
      err = decoder.DecodeUint64(&result.Iovcnt)
      if err != nil {
        return types.Pwritev2Args{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.PosL)
      if err != nil {
        return types.Pwritev2Args{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.PosH)
      if err != nil {
        return types.Pwritev2Args{}, err
      }
    case 5:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.Pwritev2Args{}, err
      }
    }
  }
  return result, nil
}

func ParsePkeyMprotectArgs(log *logging.Logger, decoder *Decoder) (types.PkeyMprotectArgs, error) {
  var result types.PkeyMprotectArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PkeyMprotectArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'PkeyMprotect': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PkeyMprotectArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.PkeyMprotectArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.PkeyMprotectArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Prot)
      if err != nil {
        return types.PkeyMprotectArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Pkey)
      if err != nil {
        return types.PkeyMprotectArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePkeyAllocArgs(log *logging.Logger, decoder *Decoder) (types.PkeyAllocArgs, error) {
  var result types.PkeyAllocArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PkeyAllocArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'PkeyAlloc': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PkeyAllocArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.PkeyAllocArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.AccessRights)
      if err != nil {
        return types.PkeyAllocArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePkeyFreeArgs(log *logging.Logger, decoder *Decoder) (types.PkeyFreeArgs, error) {
  var result types.PkeyFreeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PkeyFreeArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'PkeyFree': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PkeyFreeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pkey)
      if err != nil {
        return types.PkeyFreeArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseStatxArgs(log *logging.Logger, decoder *Decoder) (types.StatxArgs, error) {
  var result types.StatxArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.StatxArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Statx': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.StatxArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.StatxArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.StatxArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.StatxArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Mask)
      if err != nil {
        return types.StatxArgs{}, err
      }
    case 4:
      var dataStatxbuf uint64
      err = decoder.DecodeUint64(&dataStatxbuf)
      if err != nil {
        return types.StatxArgs{}, err
      }
      result.Statxbuf = uintptr(dataStatxbuf)
    }
  }
  return result, nil
}

func ParseIoPgeteventsArgs(log *logging.Logger, decoder *Decoder) (types.IoPgeteventsArgs, error) {
  var result types.IoPgeteventsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoPgeteventsArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'IoPgetevents': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoPgeteventsArgs{}, err
    }

    switch currArg {
    case 0:
      var dataCtxId uint64
      err = decoder.DecodeUint64(&dataCtxId)
      if err != nil {
        return types.IoPgeteventsArgs{}, err
      }
      result.CtxId = uintptr(dataCtxId)
    case 1:
      err = decoder.DecodeInt64(&result.MinNr)
      if err != nil {
        return types.IoPgeteventsArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt64(&result.Nr)
      if err != nil {
        return types.IoPgeteventsArgs{}, err
      }
    case 3:
      var dataEvents uint64
      err = decoder.DecodeUint64(&dataEvents)
      if err != nil {
        return types.IoPgeteventsArgs{}, err
      }
      result.Events = uintptr(dataEvents)
    case 4:
      result.Timeout, err = decoder.ReadTimespec()
      if err != nil {
        return types.IoPgeteventsArgs{}, err
      }
    case 5:
      var dataUsig uint64
      err = decoder.DecodeUint64(&dataUsig)
      if err != nil {
        return types.IoPgeteventsArgs{}, err
      }
      result.Usig = uintptr(dataUsig)
    }
  }
  return result, nil
}

func ParseRseqArgs(log *logging.Logger, decoder *Decoder) (types.RseqArgs, error) {
  var result types.RseqArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RseqArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Rseq': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RseqArgs{}, err
    }

    switch currArg {
    case 0:
      var dataRseq uint64
      err = decoder.DecodeUint64(&dataRseq)
      if err != nil {
        return types.RseqArgs{}, err
      }
      result.Rseq = uintptr(dataRseq)
    case 1:
      err = decoder.DecodeUint32(&result.RseqLen)
      if err != nil {
        return types.RseqArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.RseqArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Sig)
      if err != nil {
        return types.RseqArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePidfdSendSignalArgs(log *logging.Logger, decoder *Decoder) (types.PidfdSendSignalArgs, error) {
  var result types.PidfdSendSignalArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PidfdSendSignalArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'PidfdSendSignal': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PidfdSendSignalArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pidfd)
      if err != nil {
        return types.PidfdSendSignalArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Sig)
      if err != nil {
        return types.PidfdSendSignalArgs{}, err
      }
    case 2:
      var dataInfo uint64
      err = decoder.DecodeUint64(&dataInfo)
      if err != nil {
        return types.PidfdSendSignalArgs{}, err
      }
      result.Info = uintptr(dataInfo)
    case 3:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.PidfdSendSignalArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseIoUringSetupArgs(log *logging.Logger, decoder *Decoder) (types.IoUringSetupArgs, error) {
  var result types.IoUringSetupArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoUringSetupArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'IoUringSetup': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoUringSetupArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Entries)
      if err != nil {
        return types.IoUringSetupArgs{}, err
      }
    case 1:
      var dataP uint64
      err = decoder.DecodeUint64(&dataP)
      if err != nil {
        return types.IoUringSetupArgs{}, err
      }
      result.P = uintptr(dataP)
    }
  }
  return result, nil
}

func ParseIoUringEnterArgs(log *logging.Logger, decoder *Decoder) (types.IoUringEnterArgs, error) {
  var result types.IoUringEnterArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoUringEnterArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'IoUringEnter': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoUringEnterArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Fd)
      if err != nil {
        return types.IoUringEnterArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.ToSubmit)
      if err != nil {
        return types.IoUringEnterArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.MinComplete)
      if err != nil {
        return types.IoUringEnterArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.IoUringEnterArgs{}, err
      }
    case 4:
      var dataSig uint64
      err = decoder.DecodeUint64(&dataSig)
      if err != nil {
        return types.IoUringEnterArgs{}, err
      }
      result.Sig = uintptr(dataSig)
    }
  }
  return result, nil
}

func ParseIoUringRegisterArgs(log *logging.Logger, decoder *Decoder) (types.IoUringRegisterArgs, error) {
  var result types.IoUringRegisterArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IoUringRegisterArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'IoUringRegister': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IoUringRegisterArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Fd)
      if err != nil {
        return types.IoUringRegisterArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Opcode)
      if err != nil {
        return types.IoUringRegisterArgs{}, err
      }
    case 2:
      var dataArg uint64
      err = decoder.DecodeUint64(&dataArg)
      if err != nil {
        return types.IoUringRegisterArgs{}, err
      }
      result.Arg = uintptr(dataArg)
    case 3:
      err = decoder.DecodeUint32(&result.NrArgs)
      if err != nil {
        return types.IoUringRegisterArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseOpenTreeArgs(log *logging.Logger, decoder *Decoder) (types.OpenTreeArgs, error) {
  var result types.OpenTreeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OpenTreeArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'OpenTree': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OpenTreeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dfd)
      if err != nil {
        return types.OpenTreeArgs{}, err
      }
    case 1:
      result.Filename, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.OpenTreeArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.OpenTreeArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMoveMountArgs(log *logging.Logger, decoder *Decoder) (types.MoveMountArgs, error) {
  var result types.MoveMountArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MoveMountArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'MoveMount': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MoveMountArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.FromDfd)
      if err != nil {
        return types.MoveMountArgs{}, err
      }
    case 1:
      result.FromPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MoveMountArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.ToDfd)
      if err != nil {
        return types.MoveMountArgs{}, err
      }
    case 3:
      result.ToPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MoveMountArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.MoveMountArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFsopenArgs(log *logging.Logger, decoder *Decoder) (types.FsopenArgs, error) {
  var result types.FsopenArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FsopenArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Fsopen': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FsopenArgs{}, err
    }

    switch currArg {
    case 0:
      result.Fsname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FsopenArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.FsopenArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFsconfigArgs(log *logging.Logger, decoder *Decoder) (types.FsconfigArgs, error) {
  var result types.FsconfigArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FsconfigArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Fsconfig': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FsconfigArgs{}, err
    }

    switch currArg {
    case 0:
      var dataFsFd uint64
      err = decoder.DecodeUint64(&dataFsFd)
      if err != nil {
        return types.FsconfigArgs{}, err
      }
      result.FsFd = uintptr(dataFsFd)
    case 1:
      err = decoder.DecodeUint32(&result.Cmd)
      if err != nil {
        return types.FsconfigArgs{}, err
      }
    case 2:
      result.Key, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FsconfigArgs{}, err
      }
    case 3:
      var dataValue uint64
      err = decoder.DecodeUint64(&dataValue)
      if err != nil {
        return types.FsconfigArgs{}, err
      }
      result.Value = uintptr(dataValue)
    case 4:
      err = decoder.DecodeInt32(&result.Aux)
      if err != nil {
        return types.FsconfigArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFsmountArgs(log *logging.Logger, decoder *Decoder) (types.FsmountArgs, error) {
  var result types.FsmountArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FsmountArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Fsmount': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FsmountArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fsfd)
      if err != nil {
        return types.FsmountArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.FsmountArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.MsFlags)
      if err != nil {
        return types.FsmountArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFspickArgs(log *logging.Logger, decoder *Decoder) (types.FspickArgs, error) {
  var result types.FspickArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FspickArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Fspick': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FspickArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.FspickArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FspickArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.FspickArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePidfdOpenArgs(log *logging.Logger, decoder *Decoder) (types.PidfdOpenArgs, error) {
  var result types.PidfdOpenArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PidfdOpenArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'PidfdOpen': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PidfdOpenArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.PidfdOpenArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.PidfdOpenArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseClone3Args(log *logging.Logger, decoder *Decoder) (types.Clone3Args, error) {
  var result types.Clone3Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Clone3Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Clone3': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Clone3Args{}, err
    }

    switch currArg {
    case 0:
      var dataClArgs uint64
      err = decoder.DecodeUint64(&dataClArgs)
      if err != nil {
        return types.Clone3Args{}, err
      }
      result.ClArgs = uintptr(dataClArgs)
    case 1:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.Clone3Args{}, err
      }
    }
  }
  return result, nil
}

func ParseCloseRangeArgs(log *logging.Logger, decoder *Decoder) (types.CloseRangeArgs, error) {
  var result types.CloseRangeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CloseRangeArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'CloseRange': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CloseRangeArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.First)
      if err != nil {
        return types.CloseRangeArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Last)
      if err != nil {
        return types.CloseRangeArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseOpenat2Args(log *logging.Logger, decoder *Decoder) (types.Openat2Args, error) {
  var result types.Openat2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Openat2Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Openat2': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Openat2Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dirfd)
      if err != nil {
        return types.Openat2Args{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.Openat2Args{}, err
      }
    case 2:
      var dataHow uint64
      err = decoder.DecodeUint64(&dataHow)
      if err != nil {
        return types.Openat2Args{}, err
      }
      result.How = uintptr(dataHow)
    case 3:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.Openat2Args{}, err
      }
    }
  }
  return result, nil
}

func ParsePidfdGetfdArgs(log *logging.Logger, decoder *Decoder) (types.PidfdGetfdArgs, error) {
  var result types.PidfdGetfdArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PidfdGetfdArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'PidfdGetfd': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PidfdGetfdArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pidfd)
      if err != nil {
        return types.PidfdGetfdArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Targetfd)
      if err != nil {
        return types.PidfdGetfdArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.PidfdGetfdArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFaccessat2Args(log *logging.Logger, decoder *Decoder) (types.Faccessat2Args, error) {
  var result types.Faccessat2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Faccessat2Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Faccessat2': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Faccessat2Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Faccessat2Args{}, err
      }
    case 1:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.Faccessat2Args{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Mode)
      if err != nil {
        return types.Faccessat2Args{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Flag)
      if err != nil {
        return types.Faccessat2Args{}, err
      }
    }
  }
  return result, nil
}

func ParseProcessMadviseArgs(log *logging.Logger, decoder *Decoder) (types.ProcessMadviseArgs, error) {
  var result types.ProcessMadviseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ProcessMadviseArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'ProcessMadvise': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ProcessMadviseArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pidfd)
      if err != nil {
        return types.ProcessMadviseArgs{}, err
      }
    case 1:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.ProcessMadviseArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 2:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.ProcessMadviseArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Advice)
      if err != nil {
        return types.ProcessMadviseArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Flags)
      if err != nil {
        return types.ProcessMadviseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseEpollPwait2Args(log *logging.Logger, decoder *Decoder) (types.EpollPwait2Args, error) {
  var result types.EpollPwait2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.EpollPwait2Args{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'EpollPwait2': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.EpollPwait2Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.EpollPwait2Args{}, err
      }
    case 1:
      var dataEvents uint64
      err = decoder.DecodeUint64(&dataEvents)
      if err != nil {
        return types.EpollPwait2Args{}, err
      }
      result.Events = uintptr(dataEvents)
    case 2:
      err = decoder.DecodeInt32(&result.Maxevents)
      if err != nil {
        return types.EpollPwait2Args{}, err
      }
    case 3:
      result.Timeout, err = decoder.ReadTimespec()
      if err != nil {
        return types.EpollPwait2Args{}, err
      }
    case 4:
      var dataSigset uint64
      err = decoder.DecodeUint64(&dataSigset)
      if err != nil {
        return types.EpollPwait2Args{}, err
      }
      result.Sigset = uintptr(dataSigset)
    }
  }
  return result, nil
}

func ParseMountSetattArgs(log *logging.Logger, decoder *Decoder) (types.MountSetattArgs, error) {
  var result types.MountSetattArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MountSetattArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'MountSetatt': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MountSetattArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Dfd)
      if err != nil {
        return types.MountSetattArgs{}, err
      }
    case 1:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MountSetattArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.MountSetattArgs{}, err
      }
    case 3:
      var dataUattr uint64
      err = decoder.DecodeUint64(&dataUattr)
      if err != nil {
        return types.MountSetattArgs{}, err
      }
      result.Uattr = uintptr(dataUattr)
    case 4:
      err = decoder.DecodeUint64(&result.Usize)
      if err != nil {
        return types.MountSetattArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseQuotactlFdArgs(log *logging.Logger, decoder *Decoder) (types.QuotactlFdArgs, error) {
  var result types.QuotactlFdArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.QuotactlFdArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'QuotactlFd': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.QuotactlFdArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Fd)
      if err != nil {
        return types.QuotactlFdArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Cmd)
      if err != nil {
        return types.QuotactlFdArgs{}, err
      }
    case 2:
      var dataId uint64
      err = decoder.DecodeUint64(&dataId)
      if err != nil {
        return types.QuotactlFdArgs{}, err
      }
      result.Id = uintptr(dataId)
    case 3:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.QuotactlFdArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    }
  }
  return result, nil
}

func ParseLandlockCreateRulesetArgs(log *logging.Logger, decoder *Decoder) (types.LandlockCreateRulesetArgs, error) {
  var result types.LandlockCreateRulesetArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LandlockCreateRulesetArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'LandlockCreateRuleset': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LandlockCreateRulesetArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAttr uint64
      err = decoder.DecodeUint64(&dataAttr)
      if err != nil {
        return types.LandlockCreateRulesetArgs{}, err
      }
      result.Attr = uintptr(dataAttr)
    case 1:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.LandlockCreateRulesetArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.LandlockCreateRulesetArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseLandlockAddRuleArgs(log *logging.Logger, decoder *Decoder) (types.LandlockAddRuleArgs, error) {
  var result types.LandlockAddRuleArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LandlockAddRuleArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'LandlockAddRule': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LandlockAddRuleArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.RulesetFd)
      if err != nil {
        return types.LandlockAddRuleArgs{}, err
      }
    case 1:
      var dataRuleType uint64
      err = decoder.DecodeUint64(&dataRuleType)
      if err != nil {
        return types.LandlockAddRuleArgs{}, err
      }
      result.RuleType = uintptr(dataRuleType)
    case 2:
      var dataRuleAttr uint64
      err = decoder.DecodeUint64(&dataRuleAttr)
      if err != nil {
        return types.LandlockAddRuleArgs{}, err
      }
      result.RuleAttr = uintptr(dataRuleAttr)
    case 3:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.LandlockAddRuleArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseLandloclRestrictSetArgs(log *logging.Logger, decoder *Decoder) (types.LandloclRestrictSetArgs, error) {
  var result types.LandloclRestrictSetArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LandloclRestrictSetArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'LandloclRestrictSet': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LandloclRestrictSetArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.RulesetFd)
      if err != nil {
        return types.LandloclRestrictSetArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.LandloclRestrictSetArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMemfdSecretArgs(log *logging.Logger, decoder *Decoder) (types.MemfdSecretArgs, error) {
  var result types.MemfdSecretArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MemfdSecretArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'MemfdSecret': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MemfdSecretArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.MemfdSecretArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseProcessMreleaseArgs(log *logging.Logger, decoder *Decoder) (types.ProcessMreleaseArgs, error) {
  var result types.ProcessMreleaseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ProcessMreleaseArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ProcessMrelease': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ProcessMreleaseArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pidfd)
      if err != nil {
        return types.ProcessMreleaseArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.ProcessMreleaseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseWaitpidArgs(log *logging.Logger, decoder *Decoder) (types.WaitpidArgs, error) {
  var result types.WaitpidArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.WaitpidArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Waitpid': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.WaitpidArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.WaitpidArgs{}, err
      }
    case 1:
      var dataStatus uint64
      err = decoder.DecodeUint64(&dataStatus)
      if err != nil {
        return types.WaitpidArgs{}, err
      }
      result.Status = uintptr(dataStatus)
    case 2:
      err = decoder.DecodeInt32(&result.Options)
      if err != nil {
        return types.WaitpidArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseOldfstatArgs(log *logging.Logger, decoder *Decoder) (types.OldfstatArgs, error) {
  return types.OldfstatArgs{}, nil
}

func ParseBreakArgs(log *logging.Logger, decoder *Decoder) (types.BreakArgs, error) {
  return types.BreakArgs{}, nil
}

func ParseOldstatArgs(log *logging.Logger, decoder *Decoder) (types.OldstatArgs, error) {
  var result types.OldstatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OldstatArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Oldstat': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OldstatArgs{}, err
    }

    switch currArg {
    case 0:
      result.Filename, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.OldstatArgs{}, err
      }
    case 1:
      var dataStatbuf uint64
      err = decoder.DecodeUint64(&dataStatbuf)
      if err != nil {
        return types.OldstatArgs{}, err
      }
      result.Statbuf = uintptr(dataStatbuf)
    }
  }
  return result, nil
}

func ParseUmountArgs(log *logging.Logger, decoder *Decoder) (types.UmountArgs, error) {
  var result types.UmountArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UmountArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Umount': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UmountArgs{}, err
    }

    switch currArg {
    case 0:
      result.Target, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.UmountArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseStimeArgs(log *logging.Logger, decoder *Decoder) (types.StimeArgs, error) {
  var result types.StimeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.StimeArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Stime': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.StimeArgs{}, err
    }

    switch currArg {
    case 0:
      var dataT uint64
      err = decoder.DecodeUint64(&dataT)
      if err != nil {
        return types.StimeArgs{}, err
      }
      result.T = uintptr(dataT)
    }
  }
  return result, nil
}

func ParseSttyArgs(log *logging.Logger, decoder *Decoder) (types.SttyArgs, error) {
  return types.SttyArgs{}, nil
}

func ParseGttyArgs(log *logging.Logger, decoder *Decoder) (types.GttyArgs, error) {
  return types.GttyArgs{}, nil
}

func ParseNiceArgs(log *logging.Logger, decoder *Decoder) (types.NiceArgs, error) {
  var result types.NiceArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NiceArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Nice': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NiceArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Inc)
      if err != nil {
        return types.NiceArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFtimeArgs(log *logging.Logger, decoder *Decoder) (types.FtimeArgs, error) {
  return types.FtimeArgs{}, nil
}

func ParseProfArgs(log *logging.Logger, decoder *Decoder) (types.ProfArgs, error) {
  return types.ProfArgs{}, nil
}

func ParseSignalArgs(log *logging.Logger, decoder *Decoder) (types.SignalArgs, error) {
  var result types.SignalArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SignalArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Signal': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SignalArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Signum)
      if err != nil {
        return types.SignalArgs{}, err
      }
    case 1:
      var dataHandler uint64
      err = decoder.DecodeUint64(&dataHandler)
      if err != nil {
        return types.SignalArgs{}, err
      }
      result.Handler = uintptr(dataHandler)
    }
  }
  return result, nil
}

func ParseLockArgs(log *logging.Logger, decoder *Decoder) (types.LockArgs, error) {
  return types.LockArgs{}, nil
}

func ParseMpxArgs(log *logging.Logger, decoder *Decoder) (types.MpxArgs, error) {
  return types.MpxArgs{}, nil
}

func ParseUlimitArgs(log *logging.Logger, decoder *Decoder) (types.UlimitArgs, error) {
  return types.UlimitArgs{}, nil
}

func ParseOldoldunameArgs(log *logging.Logger, decoder *Decoder) (types.OldoldunameArgs, error) {
  var result types.OldoldunameArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OldoldunameArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Oldolduname': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OldoldunameArgs{}, err
    }

    switch currArg {
    case 0:
      var dataName uint64
      err = decoder.DecodeUint64(&dataName)
      if err != nil {
        return types.OldoldunameArgs{}, err
      }
      result.Name = uintptr(dataName)
    }
  }
  return result, nil
}

func ParseSigactionArgs(log *logging.Logger, decoder *Decoder) (types.SigactionArgs, error) {
  var result types.SigactionArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SigactionArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Sigaction': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SigactionArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sig)
      if err != nil {
        return types.SigactionArgs{}, err
      }
    case 1:
      var dataAct uint64
      err = decoder.DecodeUint64(&dataAct)
      if err != nil {
        return types.SigactionArgs{}, err
      }
      result.Act = uintptr(dataAct)
    case 2:
      var dataOact uint64
      err = decoder.DecodeUint64(&dataOact)
      if err != nil {
        return types.SigactionArgs{}, err
      }
      result.Oact = uintptr(dataOact)
    }
  }
  return result, nil
}

func ParseSgetmaskArgs(log *logging.Logger, decoder *Decoder) (types.SgetmaskArgs, error) {
  return types.SgetmaskArgs{}, nil
}

func ParseSsetmaskArgs(log *logging.Logger, decoder *Decoder) (types.SsetmaskArgs, error) {
  var result types.SsetmaskArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SsetmaskArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Ssetmask': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SsetmaskArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt64(&result.Newmask)
      if err != nil {
        return types.SsetmaskArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSigsuspendArgs(log *logging.Logger, decoder *Decoder) (types.SigsuspendArgs, error) {
  var result types.SigsuspendArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SigsuspendArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Sigsuspend': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SigsuspendArgs{}, err
    }

    switch currArg {
    case 0:
      var dataMask uint64
      err = decoder.DecodeUint64(&dataMask)
      if err != nil {
        return types.SigsuspendArgs{}, err
      }
      result.Mask = uintptr(dataMask)
    }
  }
  return result, nil
}

func ParseSigpendingArgs(log *logging.Logger, decoder *Decoder) (types.SigpendingArgs, error) {
  var result types.SigpendingArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SigpendingArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Sigpending': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SigpendingArgs{}, err
    }

    switch currArg {
    case 0:
      var dataSet uint64
      err = decoder.DecodeUint64(&dataSet)
      if err != nil {
        return types.SigpendingArgs{}, err
      }
      result.Set = uintptr(dataSet)
    }
  }
  return result, nil
}

func ParseOldlstatArgs(log *logging.Logger, decoder *Decoder) (types.OldlstatArgs, error) {
  var result types.OldlstatArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OldlstatArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Oldlstat': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OldlstatArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.OldlstatArgs{}, err
      }
    case 1:
      var dataStatbuf uint64
      err = decoder.DecodeUint64(&dataStatbuf)
      if err != nil {
        return types.OldlstatArgs{}, err
      }
      result.Statbuf = uintptr(dataStatbuf)
    }
  }
  return result, nil
}

func ParseReaddirArgs(log *logging.Logger, decoder *Decoder) (types.ReaddirArgs, error) {
  var result types.ReaddirArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ReaddirArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Readdir': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ReaddirArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Fd)
      if err != nil {
        return types.ReaddirArgs{}, err
      }
    case 1:
      var dataDirp uint64
      err = decoder.DecodeUint64(&dataDirp)
      if err != nil {
        return types.ReaddirArgs{}, err
      }
      result.Dirp = uintptr(dataDirp)
    case 2:
      err = decoder.DecodeUint32(&result.Count)
      if err != nil {
        return types.ReaddirArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseProfilArgs(log *logging.Logger, decoder *Decoder) (types.ProfilArgs, error) {
  return types.ProfilArgs{}, nil
}

func ParseSocketcallArgs(log *logging.Logger, decoder *Decoder) (types.SocketcallArgs, error) {
  var result types.SocketcallArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SocketcallArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Socketcall': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SocketcallArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Call)
      if err != nil {
        return types.SocketcallArgs{}, err
      }
    case 1:
      var dataArgs uint64
      err = decoder.DecodeUint64(&dataArgs)
      if err != nil {
        return types.SocketcallArgs{}, err
      }
      result.Args = uintptr(dataArgs)
    }
  }
  return result, nil
}

func ParseOldunameArgs(log *logging.Logger, decoder *Decoder) (types.OldunameArgs, error) {
  var result types.OldunameArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OldunameArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Olduname': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OldunameArgs{}, err
    }

    switch currArg {
    case 0:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.OldunameArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    }
  }
  return result, nil
}

func ParseIdleArgs(log *logging.Logger, decoder *Decoder) (types.IdleArgs, error) {
  return types.IdleArgs{}, nil
}

func ParseVm86oldArgs(log *logging.Logger, decoder *Decoder) (types.Vm86oldArgs, error) {
  var result types.Vm86oldArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Vm86oldArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Vm86old': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Vm86oldArgs{}, err
    }

    switch currArg {
    case 0:
      var dataInfo uint64
      err = decoder.DecodeUint64(&dataInfo)
      if err != nil {
        return types.Vm86oldArgs{}, err
      }
      result.Info = uintptr(dataInfo)
    }
  }
  return result, nil
}

func ParseIpcArgs(log *logging.Logger, decoder *Decoder) (types.IpcArgs, error) {
  var result types.IpcArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.IpcArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Ipc': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.IpcArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Call)
      if err != nil {
        return types.IpcArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.First)
      if err != nil {
        return types.IpcArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Second)
      if err != nil {
        return types.IpcArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Third)
      if err != nil {
        return types.IpcArgs{}, err
      }
    case 4:
      var dataPtr uint64
      err = decoder.DecodeUint64(&dataPtr)
      if err != nil {
        return types.IpcArgs{}, err
      }
      result.Ptr = uintptr(dataPtr)
    case 5:
      err = decoder.DecodeInt64(&result.Fifth)
      if err != nil {
        return types.IpcArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSigreturnArgs(log *logging.Logger, decoder *Decoder) (types.SigreturnArgs, error) {
  return types.SigreturnArgs{}, nil
}

func ParseSigprocmaskArgs(log *logging.Logger, decoder *Decoder) (types.SigprocmaskArgs, error) {
  var result types.SigprocmaskArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SigprocmaskArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Sigprocmask': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SigprocmaskArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.How)
      if err != nil {
        return types.SigprocmaskArgs{}, err
      }
    case 1:
      var dataSet uint64
      err = decoder.DecodeUint64(&dataSet)
      if err != nil {
        return types.SigprocmaskArgs{}, err
      }
      result.Set = uintptr(dataSet)
    case 2:
      var dataOldset uint64
      err = decoder.DecodeUint64(&dataOldset)
      if err != nil {
        return types.SigprocmaskArgs{}, err
      }
      result.Oldset = uintptr(dataOldset)
    }
  }
  return result, nil
}

func ParseBdflushArgs(log *logging.Logger, decoder *Decoder) (types.BdflushArgs, error) {
  return types.BdflushArgs{}, nil
}

func ParseAfs_syscallArgs(log *logging.Logger, decoder *Decoder) (types.Afs_syscallArgs, error) {
  return types.Afs_syscallArgs{}, nil
}

func ParseLlseekArgs(log *logging.Logger, decoder *Decoder) (types.LlseekArgs, error) {
  var result types.LlseekArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LlseekArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'Llseek': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LlseekArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Fd)
      if err != nil {
        return types.LlseekArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.OffsetHigh)
      if err != nil {
        return types.LlseekArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.OffsetLow)
      if err != nil {
        return types.LlseekArgs{}, err
      }
    case 3:
      var dataResult uint64
      err = decoder.DecodeUint64(&dataResult)
      if err != nil {
        return types.LlseekArgs{}, err
      }
      result.Result = uintptr(dataResult)
    case 4:
      err = decoder.DecodeUint32(&result.Whence)
      if err != nil {
        return types.LlseekArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseOldSelectArgs(log *logging.Logger, decoder *Decoder) (types.OldSelectArgs, error) {
  var result types.OldSelectArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OldSelectArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'OldSelect': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OldSelectArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Nfds)
      if err != nil {
        return types.OldSelectArgs{}, err
      }
    case 1:
      var dataReadfds uint64
      err = decoder.DecodeUint64(&dataReadfds)
      if err != nil {
        return types.OldSelectArgs{}, err
      }
      result.Readfds = uintptr(dataReadfds)
    case 2:
      var dataWritefds uint64
      err = decoder.DecodeUint64(&dataWritefds)
      if err != nil {
        return types.OldSelectArgs{}, err
      }
      result.Writefds = uintptr(dataWritefds)
    case 3:
      var dataExceptfds uint64
      err = decoder.DecodeUint64(&dataExceptfds)
      if err != nil {
        return types.OldSelectArgs{}, err
      }
      result.Exceptfds = uintptr(dataExceptfds)
    case 4:
      var dataTimeout uint64
      err = decoder.DecodeUint64(&dataTimeout)
      if err != nil {
        return types.OldSelectArgs{}, err
      }
      result.Timeout = uintptr(dataTimeout)
    }
  }
  return result, nil
}

func ParseVm86Args(log *logging.Logger, decoder *Decoder) (types.Vm86Args, error) {
  var result types.Vm86Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Vm86Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Vm86': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Vm86Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.Fn)
      if err != nil {
        return types.Vm86Args{}, err
      }
    case 1:
      var dataV86 uint64
      err = decoder.DecodeUint64(&dataV86)
      if err != nil {
        return types.Vm86Args{}, err
      }
      result.V86 = uintptr(dataV86)
    }
  }
  return result, nil
}

func ParseOldGetrlimitArgs(log *logging.Logger, decoder *Decoder) (types.OldGetrlimitArgs, error) {
  var result types.OldGetrlimitArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OldGetrlimitArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'OldGetrlimit': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OldGetrlimitArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Resource)
      if err != nil {
        return types.OldGetrlimitArgs{}, err
      }
    case 1:
      var dataRlim uint64
      err = decoder.DecodeUint64(&dataRlim)
      if err != nil {
        return types.OldGetrlimitArgs{}, err
      }
      result.Rlim = uintptr(dataRlim)
    }
  }
  return result, nil
}

func ParseMmap2Args(log *logging.Logger, decoder *Decoder) (types.Mmap2Args, error) {
  var result types.Mmap2Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Mmap2Args{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Mmap2': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Mmap2Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.Addr)
      if err != nil {
        return types.Mmap2Args{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.Mmap2Args{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Prot)
      if err != nil {
        return types.Mmap2Args{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Flags)
      if err != nil {
        return types.Mmap2Args{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Fd)
      if err != nil {
        return types.Mmap2Args{}, err
      }
    case 5:
      err = decoder.DecodeUint64(&result.Pgoffset)
      if err != nil {
        return types.Mmap2Args{}, err
      }
    }
  }
  return result, nil
}

func ParseTruncate64Args(log *logging.Logger, decoder *Decoder) (types.Truncate64Args, error) {
  var result types.Truncate64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Truncate64Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Truncate64': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Truncate64Args{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.Truncate64Args{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.Truncate64Args{}, err
      }
    }
  }
  return result, nil
}

func ParseFtruncate64Args(log *logging.Logger, decoder *Decoder) (types.Ftruncate64Args, error) {
  var result types.Ftruncate64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Ftruncate64Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Ftruncate64': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Ftruncate64Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Ftruncate64Args{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.Ftruncate64Args{}, err
      }
    }
  }
  return result, nil
}

func ParseStat64Args(log *logging.Logger, decoder *Decoder) (types.Stat64Args, error) {
  var result types.Stat64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Stat64Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Stat64': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Stat64Args{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.Stat64Args{}, err
      }
    case 1:
      var dataStatbuf uint64
      err = decoder.DecodeUint64(&dataStatbuf)
      if err != nil {
        return types.Stat64Args{}, err
      }
      result.Statbuf = uintptr(dataStatbuf)
    }
  }
  return result, nil
}

func ParseLstat64Args(log *logging.Logger, decoder *Decoder) (types.Lstat64Args, error) {
  var result types.Lstat64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Lstat64Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Lstat64': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Lstat64Args{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.Lstat64Args{}, err
      }
    case 1:
      var dataStatbuf uint64
      err = decoder.DecodeUint64(&dataStatbuf)
      if err != nil {
        return types.Lstat64Args{}, err
      }
      result.Statbuf = uintptr(dataStatbuf)
    }
  }
  return result, nil
}

func ParseFstat64Args(log *logging.Logger, decoder *Decoder) (types.Fstat64Args, error) {
  var result types.Fstat64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Fstat64Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Fstat64': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Fstat64Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Fstat64Args{}, err
      }
    case 1:
      var dataStatbuf uint64
      err = decoder.DecodeUint64(&dataStatbuf)
      if err != nil {
        return types.Fstat64Args{}, err
      }
      result.Statbuf = uintptr(dataStatbuf)
    }
  }
  return result, nil
}

func ParseLchown16Args(log *logging.Logger, decoder *Decoder) (types.Lchown16Args, error) {
  var result types.Lchown16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Lchown16Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Lchown16': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Lchown16Args{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.Lchown16Args{}, err
      }
    case 1:
      var dataOwner uint64
      err = decoder.DecodeUint64(&dataOwner)
      if err != nil {
        return types.Lchown16Args{}, err
      }
      result.Owner = uintptr(dataOwner)
    case 2:
      var dataGroup uint64
      err = decoder.DecodeUint64(&dataGroup)
      if err != nil {
        return types.Lchown16Args{}, err
      }
      result.Group = uintptr(dataGroup)
    }
  }
  return result, nil
}

func ParseGetuid16Args(log *logging.Logger, decoder *Decoder) (types.Getuid16Args, error) {
  return types.Getuid16Args{}, nil
}

func ParseGetgid16Args(log *logging.Logger, decoder *Decoder) (types.Getgid16Args, error) {
  return types.Getgid16Args{}, nil
}

func ParseGeteuid16Args(log *logging.Logger, decoder *Decoder) (types.Geteuid16Args, error) {
  return types.Geteuid16Args{}, nil
}

func ParseGetegid16Args(log *logging.Logger, decoder *Decoder) (types.Getegid16Args, error) {
  return types.Getegid16Args{}, nil
}

func ParseSetreuid16Args(log *logging.Logger, decoder *Decoder) (types.Setreuid16Args, error) {
  var result types.Setreuid16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Setreuid16Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Setreuid16': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Setreuid16Args{}, err
    }

    switch currArg {
    case 0:
      var dataRuid uint64
      err = decoder.DecodeUint64(&dataRuid)
      if err != nil {
        return types.Setreuid16Args{}, err
      }
      result.Ruid = uintptr(dataRuid)
    case 1:
      var dataEuid uint64
      err = decoder.DecodeUint64(&dataEuid)
      if err != nil {
        return types.Setreuid16Args{}, err
      }
      result.Euid = uintptr(dataEuid)
    }
  }
  return result, nil
}

func ParseSetregid16Args(log *logging.Logger, decoder *Decoder) (types.Setregid16Args, error) {
  var result types.Setregid16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Setregid16Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Setregid16': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Setregid16Args{}, err
    }

    switch currArg {
    case 0:
      var dataRgid uint64
      err = decoder.DecodeUint64(&dataRgid)
      if err != nil {
        return types.Setregid16Args{}, err
      }
      result.Rgid = uintptr(dataRgid)
    case 1:
      var dataEgid uint64
      err = decoder.DecodeUint64(&dataEgid)
      if err != nil {
        return types.Setregid16Args{}, err
      }
      result.Egid = uintptr(dataEgid)
    }
  }
  return result, nil
}

func ParseGetgroups16Args(log *logging.Logger, decoder *Decoder) (types.Getgroups16Args, error) {
  var result types.Getgroups16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Getgroups16Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Getgroups16': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Getgroups16Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Size)
      if err != nil {
        return types.Getgroups16Args{}, err
      }
    case 1:
      var dataList uint64
      err = decoder.DecodeUint64(&dataList)
      if err != nil {
        return types.Getgroups16Args{}, err
      }
      result.List = uintptr(dataList)
    }
  }
  return result, nil
}

func ParseSetgroups16Args(log *logging.Logger, decoder *Decoder) (types.Setgroups16Args, error) {
  var result types.Setgroups16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Setgroups16Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'Setgroups16': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Setgroups16Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.Size)
      if err != nil {
        return types.Setgroups16Args{}, err
      }
    case 1:
      var dataList uint64
      err = decoder.DecodeUint64(&dataList)
      if err != nil {
        return types.Setgroups16Args{}, err
      }
      result.List = uintptr(dataList)
    }
  }
  return result, nil
}

func ParseFchown16Args(log *logging.Logger, decoder *Decoder) (types.Fchown16Args, error) {
  var result types.Fchown16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Fchown16Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Fchown16': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Fchown16Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Fd)
      if err != nil {
        return types.Fchown16Args{}, err
      }
    case 1:
      var dataUser uint64
      err = decoder.DecodeUint64(&dataUser)
      if err != nil {
        return types.Fchown16Args{}, err
      }
      result.User = uintptr(dataUser)
    case 2:
      var dataGroup uint64
      err = decoder.DecodeUint64(&dataGroup)
      if err != nil {
        return types.Fchown16Args{}, err
      }
      result.Group = uintptr(dataGroup)
    }
  }
  return result, nil
}

func ParseSetresuid16Args(log *logging.Logger, decoder *Decoder) (types.Setresuid16Args, error) {
  var result types.Setresuid16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Setresuid16Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Setresuid16': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Setresuid16Args{}, err
    }

    switch currArg {
    case 0:
      var dataRuid uint64
      err = decoder.DecodeUint64(&dataRuid)
      if err != nil {
        return types.Setresuid16Args{}, err
      }
      result.Ruid = uintptr(dataRuid)
    case 1:
      var dataEuid uint64
      err = decoder.DecodeUint64(&dataEuid)
      if err != nil {
        return types.Setresuid16Args{}, err
      }
      result.Euid = uintptr(dataEuid)
    case 2:
      var dataSuid uint64
      err = decoder.DecodeUint64(&dataSuid)
      if err != nil {
        return types.Setresuid16Args{}, err
      }
      result.Suid = uintptr(dataSuid)
    }
  }
  return result, nil
}

func ParseGetresuid16Args(log *logging.Logger, decoder *Decoder) (types.Getresuid16Args, error) {
  var result types.Getresuid16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Getresuid16Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Getresuid16': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Getresuid16Args{}, err
    }

    switch currArg {
    case 0:
      var dataRuid uint64
      err = decoder.DecodeUint64(&dataRuid)
      if err != nil {
        return types.Getresuid16Args{}, err
      }
      result.Ruid = uintptr(dataRuid)
    case 1:
      var dataEuid uint64
      err = decoder.DecodeUint64(&dataEuid)
      if err != nil {
        return types.Getresuid16Args{}, err
      }
      result.Euid = uintptr(dataEuid)
    case 2:
      var dataSuid uint64
      err = decoder.DecodeUint64(&dataSuid)
      if err != nil {
        return types.Getresuid16Args{}, err
      }
      result.Suid = uintptr(dataSuid)
    }
  }
  return result, nil
}

func ParseSetresgid16Args(log *logging.Logger, decoder *Decoder) (types.Setresgid16Args, error) {
  var result types.Setresgid16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Setresgid16Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Setresgid16': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Setresgid16Args{}, err
    }

    switch currArg {
    case 0:
      var dataRgid uint64
      err = decoder.DecodeUint64(&dataRgid)
      if err != nil {
        return types.Setresgid16Args{}, err
      }
      result.Rgid = uintptr(dataRgid)
    case 1:
      var dataEuid uint64
      err = decoder.DecodeUint64(&dataEuid)
      if err != nil {
        return types.Setresgid16Args{}, err
      }
      result.Euid = uintptr(dataEuid)
    case 2:
      var dataSuid uint64
      err = decoder.DecodeUint64(&dataSuid)
      if err != nil {
        return types.Setresgid16Args{}, err
      }
      result.Suid = uintptr(dataSuid)
    }
  }
  return result, nil
}

func ParseGetresgid16Args(log *logging.Logger, decoder *Decoder) (types.Getresgid16Args, error) {
  var result types.Getresgid16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Getresgid16Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Getresgid16': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Getresgid16Args{}, err
    }

    switch currArg {
    case 0:
      var dataRgid uint64
      err = decoder.DecodeUint64(&dataRgid)
      if err != nil {
        return types.Getresgid16Args{}, err
      }
      result.Rgid = uintptr(dataRgid)
    case 1:
      var dataEgid uint64
      err = decoder.DecodeUint64(&dataEgid)
      if err != nil {
        return types.Getresgid16Args{}, err
      }
      result.Egid = uintptr(dataEgid)
    case 2:
      var dataSgid uint64
      err = decoder.DecodeUint64(&dataSgid)
      if err != nil {
        return types.Getresgid16Args{}, err
      }
      result.Sgid = uintptr(dataSgid)
    }
  }
  return result, nil
}

func ParseChown16Args(log *logging.Logger, decoder *Decoder) (types.Chown16Args, error) {
  var result types.Chown16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Chown16Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Chown16': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Chown16Args{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.Chown16Args{}, err
      }
    case 1:
      var dataOwner uint64
      err = decoder.DecodeUint64(&dataOwner)
      if err != nil {
        return types.Chown16Args{}, err
      }
      result.Owner = uintptr(dataOwner)
    case 2:
      var dataGroup uint64
      err = decoder.DecodeUint64(&dataGroup)
      if err != nil {
        return types.Chown16Args{}, err
      }
      result.Group = uintptr(dataGroup)
    }
  }
  return result, nil
}

func ParseSetuid16Args(log *logging.Logger, decoder *Decoder) (types.Setuid16Args, error) {
  var result types.Setuid16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Setuid16Args{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Setuid16': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Setuid16Args{}, err
    }

    switch currArg {
    case 0:
      var dataUid uint64
      err = decoder.DecodeUint64(&dataUid)
      if err != nil {
        return types.Setuid16Args{}, err
      }
      result.Uid = uintptr(dataUid)
    }
  }
  return result, nil
}

func ParseSetgid16Args(log *logging.Logger, decoder *Decoder) (types.Setgid16Args, error) {
  var result types.Setgid16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Setgid16Args{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Setgid16': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Setgid16Args{}, err
    }

    switch currArg {
    case 0:
      var dataGid uint64
      err = decoder.DecodeUint64(&dataGid)
      if err != nil {
        return types.Setgid16Args{}, err
      }
      result.Gid = uintptr(dataGid)
    }
  }
  return result, nil
}

func ParseSetfsuid16Args(log *logging.Logger, decoder *Decoder) (types.Setfsuid16Args, error) {
  var result types.Setfsuid16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Setfsuid16Args{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Setfsuid16': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Setfsuid16Args{}, err
    }

    switch currArg {
    case 0:
      var dataFsuid uint64
      err = decoder.DecodeUint64(&dataFsuid)
      if err != nil {
        return types.Setfsuid16Args{}, err
      }
      result.Fsuid = uintptr(dataFsuid)
    }
  }
  return result, nil
}

func ParseSetfsgid16Args(log *logging.Logger, decoder *Decoder) (types.Setfsgid16Args, error) {
  var result types.Setfsgid16Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Setfsgid16Args{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'Setfsgid16': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Setfsgid16Args{}, err
    }

    switch currArg {
    case 0:
      var dataFsgid uint64
      err = decoder.DecodeUint64(&dataFsgid)
      if err != nil {
        return types.Setfsgid16Args{}, err
      }
      result.Fsgid = uintptr(dataFsgid)
    }
  }
  return result, nil
}

func ParseFcntl64Args(log *logging.Logger, decoder *Decoder) (types.Fcntl64Args, error) {
  var result types.Fcntl64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Fcntl64Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Fcntl64': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Fcntl64Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Fcntl64Args{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Cmd)
      if err != nil {
        return types.Fcntl64Args{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Arg)
      if err != nil {
        return types.Fcntl64Args{}, err
      }
    }
  }
  return result, nil
}

func ParseSendfile32Args(log *logging.Logger, decoder *Decoder) (types.Sendfile32Args, error) {
  var result types.Sendfile32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Sendfile32Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Sendfile32': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Sendfile32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.OutFd)
      if err != nil {
        return types.Sendfile32Args{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.InFd)
      if err != nil {
        return types.Sendfile32Args{}, err
      }
    case 2:
      var dataOffset uint64
      err = decoder.DecodeUint64(&dataOffset)
      if err != nil {
        return types.Sendfile32Args{}, err
      }
      result.Offset = uintptr(dataOffset)
    case 3:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.Sendfile32Args{}, err
      }
    }
  }
  return result, nil
}

func ParseStatfs64Args(log *logging.Logger, decoder *Decoder) (types.Statfs64Args, error) {
  var result types.Statfs64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Statfs64Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Statfs64': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Statfs64Args{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.Statfs64Args{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Sz)
      if err != nil {
        return types.Statfs64Args{}, err
      }
    case 2:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.Statfs64Args{}, err
      }
      result.Buf = uintptr(dataBuf)
    }
  }
  return result, nil
}

func ParseFstatfs64Args(log *logging.Logger, decoder *Decoder) (types.Fstatfs64Args, error) {
  var result types.Fstatfs64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Fstatfs64Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'Fstatfs64': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Fstatfs64Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Fstatfs64Args{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Sz)
      if err != nil {
        return types.Fstatfs64Args{}, err
      }
    case 2:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.Fstatfs64Args{}, err
      }
      result.Buf = uintptr(dataBuf)
    }
  }
  return result, nil
}

func ParseFadvise64_64Args(log *logging.Logger, decoder *Decoder) (types.Fadvise64_64Args, error) {
  var result types.Fadvise64_64Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Fadvise64_64Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'Fadvise64_64': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Fadvise64_64Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.Fadvise64_64Args{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Offset)
      if err != nil {
        return types.Fadvise64_64Args{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.Fadvise64_64Args{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Advice)
      if err != nil {
        return types.Fadvise64_64Args{}, err
      }
    }
  }
  return result, nil
}

func ParseClockGettime32Args(log *logging.Logger, decoder *Decoder) (types.ClockGettime32Args, error) {
  var result types.ClockGettime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ClockGettime32Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ClockGettime32': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ClockGettime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.WhichClock)
      if err != nil {
        return types.ClockGettime32Args{}, err
      }
    case 1:
      var dataTp uint64
      err = decoder.DecodeUint64(&dataTp)
      if err != nil {
        return types.ClockGettime32Args{}, err
      }
      result.Tp = uintptr(dataTp)
    }
  }
  return result, nil
}

func ParseClockSettime32Args(log *logging.Logger, decoder *Decoder) (types.ClockSettime32Args, error) {
  var result types.ClockSettime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ClockSettime32Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ClockSettime32': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ClockSettime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.WhichClock)
      if err != nil {
        return types.ClockSettime32Args{}, err
      }
    case 1:
      var dataTp uint64
      err = decoder.DecodeUint64(&dataTp)
      if err != nil {
        return types.ClockSettime32Args{}, err
      }
      result.Tp = uintptr(dataTp)
    }
  }
  return result, nil
}

func ParseClockAdjtime64Args(log *logging.Logger, decoder *Decoder) (types.ClockAdjtime64Args, error) {
  return types.ClockAdjtime64Args{}, nil
}

func ParseClockGetresTime32Args(log *logging.Logger, decoder *Decoder) (types.ClockGetresTime32Args, error) {
  var result types.ClockGetresTime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ClockGetresTime32Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ClockGetresTime32': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ClockGetresTime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.WhichClock)
      if err != nil {
        return types.ClockGetresTime32Args{}, err
      }
    case 1:
      var dataTp uint64
      err = decoder.DecodeUint64(&dataTp)
      if err != nil {
        return types.ClockGetresTime32Args{}, err
      }
      result.Tp = uintptr(dataTp)
    }
  }
  return result, nil
}

func ParseClockNanosleepTime32Args(log *logging.Logger, decoder *Decoder) (types.ClockNanosleepTime32Args, error) {
  var result types.ClockNanosleepTime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ClockNanosleepTime32Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'ClockNanosleepTime32': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ClockNanosleepTime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.WhichClock)
      if err != nil {
        return types.ClockNanosleepTime32Args{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.ClockNanosleepTime32Args{}, err
      }
    case 2:
      var dataRqtp uint64
      err = decoder.DecodeUint64(&dataRqtp)
      if err != nil {
        return types.ClockNanosleepTime32Args{}, err
      }
      result.Rqtp = uintptr(dataRqtp)
    case 3:
      var dataRmtp uint64
      err = decoder.DecodeUint64(&dataRmtp)
      if err != nil {
        return types.ClockNanosleepTime32Args{}, err
      }
      result.Rmtp = uintptr(dataRmtp)
    }
  }
  return result, nil
}

func ParseTimerGettime32Args(log *logging.Logger, decoder *Decoder) (types.TimerGettime32Args, error) {
  var result types.TimerGettime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerGettime32Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'TimerGettime32': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerGettime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.TimerId)
      if err != nil {
        return types.TimerGettime32Args{}, err
      }
    case 1:
      var dataSetting uint64
      err = decoder.DecodeUint64(&dataSetting)
      if err != nil {
        return types.TimerGettime32Args{}, err
      }
      result.Setting = uintptr(dataSetting)
    }
  }
  return result, nil
}

func ParseTimerSettime32Args(log *logging.Logger, decoder *Decoder) (types.TimerSettime32Args, error) {
  var result types.TimerSettime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerSettime32Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'TimerSettime32': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerSettime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.TimerId)
      if err != nil {
        return types.TimerSettime32Args{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.TimerSettime32Args{}, err
      }
    case 2:
      var dataNew uint64
      err = decoder.DecodeUint64(&dataNew)
      if err != nil {
        return types.TimerSettime32Args{}, err
      }
      result.New = uintptr(dataNew)
    case 3:
      var dataOld uint64
      err = decoder.DecodeUint64(&dataOld)
      if err != nil {
        return types.TimerSettime32Args{}, err
      }
      result.Old = uintptr(dataOld)
    }
  }
  return result, nil
}

func ParseTimerfdGettime32Args(log *logging.Logger, decoder *Decoder) (types.TimerfdGettime32Args, error) {
  var result types.TimerfdGettime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerfdGettime32Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'TimerfdGettime32': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerfdGettime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Ufd)
      if err != nil {
        return types.TimerfdGettime32Args{}, err
      }
    case 1:
      var dataOtmr uint64
      err = decoder.DecodeUint64(&dataOtmr)
      if err != nil {
        return types.TimerfdGettime32Args{}, err
      }
      result.Otmr = uintptr(dataOtmr)
    }
  }
  return result, nil
}

func ParseTimerfdSettime32Args(log *logging.Logger, decoder *Decoder) (types.TimerfdSettime32Args, error) {
  var result types.TimerfdSettime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TimerfdSettime32Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'TimerfdSettime32': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TimerfdSettime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Ufd)
      if err != nil {
        return types.TimerfdSettime32Args{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.TimerfdSettime32Args{}, err
      }
    case 2:
      var dataUtmr uint64
      err = decoder.DecodeUint64(&dataUtmr)
      if err != nil {
        return types.TimerfdSettime32Args{}, err
      }
      result.Utmr = uintptr(dataUtmr)
    case 3:
      var dataOtmr uint64
      err = decoder.DecodeUint64(&dataOtmr)
      if err != nil {
        return types.TimerfdSettime32Args{}, err
      }
      result.Otmr = uintptr(dataOtmr)
    }
  }
  return result, nil
}

func ParseUtimensatTime32Args(log *logging.Logger, decoder *Decoder) (types.UtimensatTime32Args, error) {
  var result types.UtimensatTime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.UtimensatTime32Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'UtimensatTime32': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.UtimensatTime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Dfd)
      if err != nil {
        return types.UtimensatTime32Args{}, err
      }
    case 1:
      result.Filename, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.UtimensatTime32Args{}, err
      }
    case 2:
      var dataT uint64
      err = decoder.DecodeUint64(&dataT)
      if err != nil {
        return types.UtimensatTime32Args{}, err
      }
      result.T = uintptr(dataT)
    case 3:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.UtimensatTime32Args{}, err
      }
    }
  }
  return result, nil
}

func ParsePselect6Time32Args(log *logging.Logger, decoder *Decoder) (types.Pselect6Time32Args, error) {
  var result types.Pselect6Time32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.Pselect6Time32Args{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'Pselect6Time32': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.Pselect6Time32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.N)
      if err != nil {
        return types.Pselect6Time32Args{}, err
      }
    case 1:
      var dataInp uint64
      err = decoder.DecodeUint64(&dataInp)
      if err != nil {
        return types.Pselect6Time32Args{}, err
      }
      result.Inp = uintptr(dataInp)
    case 2:
      var dataOutp uint64
      err = decoder.DecodeUint64(&dataOutp)
      if err != nil {
        return types.Pselect6Time32Args{}, err
      }
      result.Outp = uintptr(dataOutp)
    case 3:
      var dataExp uint64
      err = decoder.DecodeUint64(&dataExp)
      if err != nil {
        return types.Pselect6Time32Args{}, err
      }
      result.Exp = uintptr(dataExp)
    case 4:
      var dataTsp uint64
      err = decoder.DecodeUint64(&dataTsp)
      if err != nil {
        return types.Pselect6Time32Args{}, err
      }
      result.Tsp = uintptr(dataTsp)
    case 5:
      var dataSig uint64
      err = decoder.DecodeUint64(&dataSig)
      if err != nil {
        return types.Pselect6Time32Args{}, err
      }
      result.Sig = uintptr(dataSig)
    }
  }
  return result, nil
}

func ParsePpollTime32Args(log *logging.Logger, decoder *Decoder) (types.PpollTime32Args, error) {
  var result types.PpollTime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PpollTime32Args{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'PpollTime32': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PpollTime32Args{}, err
    }

    switch currArg {
    case 0:
      var dataUfds uint64
      err = decoder.DecodeUint64(&dataUfds)
      if err != nil {
        return types.PpollTime32Args{}, err
      }
      result.Ufds = uintptr(dataUfds)
    case 1:
      err = decoder.DecodeUint32(&result.Nfds)
      if err != nil {
        return types.PpollTime32Args{}, err
      }
    case 2:
      var dataTsp uint64
      err = decoder.DecodeUint64(&dataTsp)
      if err != nil {
        return types.PpollTime32Args{}, err
      }
      result.Tsp = uintptr(dataTsp)
    case 3:
      var dataSigmask uint64
      err = decoder.DecodeUint64(&dataSigmask)
      if err != nil {
        return types.PpollTime32Args{}, err
      }
      result.Sigmask = uintptr(dataSigmask)
    case 4:
      err = decoder.DecodeUint64(&result.Sigsetsize)
      if err != nil {
        return types.PpollTime32Args{}, err
      }
    }
  }
  return result, nil
}

func ParseIoPgeteventsTime32Args(log *logging.Logger, decoder *Decoder) (types.IoPgeteventsTime32Args, error) {
  return types.IoPgeteventsTime32Args{}, nil
}

func ParseRecvmmsgTime32Args(log *logging.Logger, decoder *Decoder) (types.RecvmmsgTime32Args, error) {
  var result types.RecvmmsgTime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RecvmmsgTime32Args{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'RecvmmsgTime32': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RecvmmsgTime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.RecvmmsgTime32Args{}, err
      }
    case 1:
      var dataMmsg uint64
      err = decoder.DecodeUint64(&dataMmsg)
      if err != nil {
        return types.RecvmmsgTime32Args{}, err
      }
      result.Mmsg = uintptr(dataMmsg)
    case 2:
      err = decoder.DecodeUint32(&result.Vlen)
      if err != nil {
        return types.RecvmmsgTime32Args{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.RecvmmsgTime32Args{}, err
      }
    case 4:
      var dataTimeout uint64
      err = decoder.DecodeUint64(&dataTimeout)
      if err != nil {
        return types.RecvmmsgTime32Args{}, err
      }
      result.Timeout = uintptr(dataTimeout)
    }
  }
  return result, nil
}

func ParseMqTimedsendTime32Args(log *logging.Logger, decoder *Decoder) (types.MqTimedsendTime32Args, error) {
  var result types.MqTimedsendTime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MqTimedsendTime32Args{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'MqTimedsendTime32': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MqTimedsendTime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Mqdes)
      if err != nil {
        return types.MqTimedsendTime32Args{}, err
      }
    case 1:
      result.UMsgPtr, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MqTimedsendTime32Args{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.MsgLen)
      if err != nil {
        return types.MqTimedsendTime32Args{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.MsgPrio)
      if err != nil {
        return types.MqTimedsendTime32Args{}, err
      }
    case 4:
      var dataUAbsTimeout uint64
      err = decoder.DecodeUint64(&dataUAbsTimeout)
      if err != nil {
        return types.MqTimedsendTime32Args{}, err
      }
      result.UAbsTimeout = uintptr(dataUAbsTimeout)
    }
  }
  return result, nil
}

func ParseMqTimedreceiveTime32Args(log *logging.Logger, decoder *Decoder) (types.MqTimedreceiveTime32Args, error) {
  var result types.MqTimedreceiveTime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MqTimedreceiveTime32Args{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'MqTimedreceiveTime32': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MqTimedreceiveTime32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Mqdes)
      if err != nil {
        return types.MqTimedreceiveTime32Args{}, err
      }
    case 1:
      result.UMsgPtr, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MqTimedreceiveTime32Args{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.MsgLen)
      if err != nil {
        return types.MqTimedreceiveTime32Args{}, err
      }
    case 3:
      var dataUMsgPrio uint64
      err = decoder.DecodeUint64(&dataUMsgPrio)
      if err != nil {
        return types.MqTimedreceiveTime32Args{}, err
      }
      result.UMsgPrio = uintptr(dataUMsgPrio)
    case 4:
      var dataUAbsTimeout uint64
      err = decoder.DecodeUint64(&dataUAbsTimeout)
      if err != nil {
        return types.MqTimedreceiveTime32Args{}, err
      }
      result.UAbsTimeout = uintptr(dataUAbsTimeout)
    }
  }
  return result, nil
}

func ParseRtSigtimedwaitTime32Args(log *logging.Logger, decoder *Decoder) (types.RtSigtimedwaitTime32Args, error) {
  var result types.RtSigtimedwaitTime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RtSigtimedwaitTime32Args{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'RtSigtimedwaitTime32': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RtSigtimedwaitTime32Args{}, err
    }

    switch currArg {
    case 0:
      var dataUthese uint64
      err = decoder.DecodeUint64(&dataUthese)
      if err != nil {
        return types.RtSigtimedwaitTime32Args{}, err
      }
      result.Uthese = uintptr(dataUthese)
    case 1:
      var dataUinfo uint64
      err = decoder.DecodeUint64(&dataUinfo)
      if err != nil {
        return types.RtSigtimedwaitTime32Args{}, err
      }
      result.Uinfo = uintptr(dataUinfo)
    case 2:
      var dataUts uint64
      err = decoder.DecodeUint64(&dataUts)
      if err != nil {
        return types.RtSigtimedwaitTime32Args{}, err
      }
      result.Uts = uintptr(dataUts)
    case 3:
      err = decoder.DecodeUint64(&result.Sigsetsize)
      if err != nil {
        return types.RtSigtimedwaitTime32Args{}, err
      }
    }
  }
  return result, nil
}

func ParseFutexTime32Args(log *logging.Logger, decoder *Decoder) (types.FutexTime32Args, error) {
  var result types.FutexTime32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FutexTime32Args{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'FutexTime32': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FutexTime32Args{}, err
    }

    switch currArg {
    case 0:
      var dataUaddr uint64
      err = decoder.DecodeUint64(&dataUaddr)
      if err != nil {
        return types.FutexTime32Args{}, err
      }
      result.Uaddr = uintptr(dataUaddr)
    case 1:
      err = decoder.DecodeInt32(&result.Op)
      if err != nil {
        return types.FutexTime32Args{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Val)
      if err != nil {
        return types.FutexTime32Args{}, err
      }
    case 3:
      var dataUtime uint64
      err = decoder.DecodeUint64(&dataUtime)
      if err != nil {
        return types.FutexTime32Args{}, err
      }
      result.Utime = uintptr(dataUtime)
    case 4:
      var dataUaddr2 uint64
      err = decoder.DecodeUint64(&dataUaddr2)
      if err != nil {
        return types.FutexTime32Args{}, err
      }
      result.Uaddr2 = uintptr(dataUaddr2)
    case 5:
      err = decoder.DecodeUint32(&result.Val3)
      if err != nil {
        return types.FutexTime32Args{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedRrGetInterval32Args(log *logging.Logger, decoder *Decoder) (types.SchedRrGetInterval32Args, error) {
  var result types.SchedRrGetInterval32Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedRrGetInterval32Args{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SchedRrGetInterval32': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedRrGetInterval32Args{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SchedRrGetInterval32Args{}, err
      }
    case 1:
      var dataInterval uint64
      err = decoder.DecodeUint64(&dataInterval)
      if err != nil {
        return types.SchedRrGetInterval32Args{}, err
      }
      result.Interval = uintptr(dataInterval)
    }
  }
  return result, nil
}

func ParseSysEnterArgs(log *logging.Logger, decoder *Decoder) (types.SysEnterArgs, error) {
  var result types.SysEnterArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SysEnterArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'SysEnter': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SysEnterArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Syscall)
      if err != nil {
        return types.SysEnterArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSysExitArgs(log *logging.Logger, decoder *Decoder) (types.SysExitArgs, error) {
  var result types.SysExitArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SysExitArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'SysExit': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SysExitArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Syscall)
      if err != nil {
        return types.SysExitArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedProcessForkArgs(log *logging.Logger, decoder *Decoder) (types.SchedProcessForkArgs, error) {
  var result types.SchedProcessForkArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedProcessForkArgs{}, err
  }

  if numArgs != 9 {
    log.Warnf("unexpected number of args received when parsing 'SchedProcessFork': wanted 9, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedProcessForkArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.ParentTid)
      if err != nil {
        return types.SchedProcessForkArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.ParentNsTid)
      if err != nil {
        return types.SchedProcessForkArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.ParentPid)
      if err != nil {
        return types.SchedProcessForkArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.ParentNsPid)
      if err != nil {
        return types.SchedProcessForkArgs{}, err
      }
    case 4:
      err = decoder.DecodeInt32(&result.ChildTid)
      if err != nil {
        return types.SchedProcessForkArgs{}, err
      }
    case 5:
      err = decoder.DecodeInt32(&result.ChildNsTid)
      if err != nil {
        return types.SchedProcessForkArgs{}, err
      }
    case 6:
      err = decoder.DecodeInt32(&result.ChildPid)
      if err != nil {
        return types.SchedProcessForkArgs{}, err
      }
    case 7:
      err = decoder.DecodeInt32(&result.ChildNsPid)
      if err != nil {
        return types.SchedProcessForkArgs{}, err
      }
    case 8:
      err = decoder.DecodeUint64(&result.StartTime)
      if err != nil {
        return types.SchedProcessForkArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedProcessExecArgs(log *logging.Logger, decoder *Decoder) (types.SchedProcessExecArgs, error) {
  var result types.SchedProcessExecArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedProcessExecArgs{}, err
  }

  if numArgs != 16 {
    log.Warnf("unexpected number of args received when parsing 'SchedProcessExec': wanted 16, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedProcessExecArgs{}, err
    }

    switch currArg {
    case 0:
      result.Cmdpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Ctime)
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint16(&result.InodeMode)
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 6:
      result.InterpreterPathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 7:
      err = decoder.DecodeUint32(&result.InterpreterDev)
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 8:
      err = decoder.DecodeUint64(&result.InterpreterInode)
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 9:
      err = decoder.DecodeUint64(&result.InterpreterCtime)
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 10:
      result.Argv, err = decoder.ReadArgsArrayFromBuff()
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 11:
      result.Interp, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 12:
      err = decoder.DecodeUint16(&result.StdinType)
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 13:
      result.StdinPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 14:
      err = decoder.DecodeInt32(&result.InvokedFromKernel)
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    case 15:
      result.Env, err = decoder.ReadArgsArrayFromBuff()
      if err != nil {
        return types.SchedProcessExecArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedProcessExitArgs(log *logging.Logger, decoder *Decoder) (types.SchedProcessExitArgs, error) {
  var result types.SchedProcessExitArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedProcessExitArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SchedProcessExit': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedProcessExitArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt64(&result.ExitCode)
      if err != nil {
        return types.SchedProcessExitArgs{}, err
      }
    case 1:
      err = decoder.DecodeBool(&result.ProcessGroupExit)
      if err != nil {
        return types.SchedProcessExitArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSchedSwitchArgs(log *logging.Logger, decoder *Decoder) (types.SchedSwitchArgs, error) {
  var result types.SchedSwitchArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SchedSwitchArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'SchedSwitch': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SchedSwitchArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Cpu)
      if err != nil {
        return types.SchedSwitchArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.PrevTid)
      if err != nil {
        return types.SchedSwitchArgs{}, err
      }
    case 2:
      result.PrevComm, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SchedSwitchArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.NextTid)
      if err != nil {
        return types.SchedSwitchArgs{}, err
      }
    case 4:
      result.NextComm, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SchedSwitchArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseProcessOomKilledArgs(log *logging.Logger, decoder *Decoder) (types.ProcessOomKilledArgs, error) {
  var result types.ProcessOomKilledArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ProcessOomKilledArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ProcessOomKilled': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ProcessOomKilledArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt64(&result.ExitCode)
      if err != nil {
        return types.ProcessOomKilledArgs{}, err
      }
    case 1:
      err = decoder.DecodeBool(&result.ProcessGroupExit)
      if err != nil {
        return types.ProcessOomKilledArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseDoExitArgs(log *logging.Logger, decoder *Decoder) (types.DoExitArgs, error) {
  return types.DoExitArgs{}, nil
}

func ParseCapCapableArgs(log *logging.Logger, decoder *Decoder) (types.CapCapableArgs, error) {
  var result types.CapCapableArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CapCapableArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'CapCapable': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CapCapableArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Cap)
      if err != nil {
        return types.CapCapableArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseVfsWriteArgs(log *logging.Logger, decoder *Decoder) (types.VfsWriteArgs, error) {
  var result types.VfsWriteArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.VfsWriteArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'VfsWrite': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.VfsWriteArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.VfsWriteArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.VfsWriteArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.VfsWriteArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.VfsWriteArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Pos)
      if err != nil {
        return types.VfsWriteArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseVfsWritevArgs(log *logging.Logger, decoder *Decoder) (types.VfsWritevArgs, error) {
  var result types.VfsWritevArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.VfsWritevArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'VfsWritev': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.VfsWritevArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.VfsWritevArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.VfsWritevArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.VfsWritevArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Vlen)
      if err != nil {
        return types.VfsWritevArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Pos)
      if err != nil {
        return types.VfsWritevArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMemProtAlertArgs(log *logging.Logger, decoder *Decoder) (types.MemProtAlertArgs, error) {
  var result types.MemProtAlertArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MemProtAlertArgs{}, err
  }

  if numArgs != 9 {
    log.Warnf("unexpected number of args received when parsing 'MemProtAlert': wanted 9, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MemProtAlertArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Alert)
      if err != nil {
        return types.MemProtAlertArgs{}, err
      }
    case 1:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.MemProtAlertArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 2:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.MemProtAlertArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Prot)
      if err != nil {
        return types.MemProtAlertArgs{}, err
      }
    case 4:
      err = decoder.DecodeInt32(&result.PrevProt)
      if err != nil {
        return types.MemProtAlertArgs{}, err
      }
    case 5:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MemProtAlertArgs{}, err
      }
    case 6:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.MemProtAlertArgs{}, err
      }
    case 7:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.MemProtAlertArgs{}, err
      }
    case 8:
      err = decoder.DecodeUint64(&result.Ctime)
      if err != nil {
        return types.MemProtAlertArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseCommitCredsArgs(log *logging.Logger, decoder *Decoder) (types.CommitCredsArgs, error) {
  var result types.CommitCredsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CommitCredsArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'CommitCreds': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CommitCredsArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeSlimCred(&result.OldCred)
      if err != nil {
        return types.CommitCredsArgs{}, err
      }
    case 1:
      err = decoder.DecodeSlimCred(&result.NewCred)
      if err != nil {
        return types.CommitCredsArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSwitchTaskNSArgs(log *logging.Logger, decoder *Decoder) (types.SwitchTaskNSArgs, error) {
  var result types.SwitchTaskNSArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SwitchTaskNSArgs{}, err
  }

  if numArgs != 7 {
    log.Warnf("unexpected number of args received when parsing 'SwitchTaskNS': wanted 7, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SwitchTaskNSArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.SwitchTaskNSArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.NewMnt)
      if err != nil {
        return types.SwitchTaskNSArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.NewPid)
      if err != nil {
        return types.SwitchTaskNSArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.NewUts)
      if err != nil {
        return types.SwitchTaskNSArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint32(&result.NewIpc)
      if err != nil {
        return types.SwitchTaskNSArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint32(&result.NewNet)
      if err != nil {
        return types.SwitchTaskNSArgs{}, err
      }
    case 6:
      err = decoder.DecodeUint32(&result.NewCgroup)
      if err != nil {
        return types.SwitchTaskNSArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseMagicWriteArgs(log *logging.Logger, decoder *Decoder) (types.MagicWriteArgs, error) {
  var result types.MagicWriteArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.MagicWriteArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'MagicWrite': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.MagicWriteArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.MagicWriteArgs{}, err
      }
    case 1:
      result.Bytes, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.MagicWrite))
      if err != nil {
        return types.MagicWriteArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.MagicWriteArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.MagicWriteArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseCgroupAttachTaskArgs(log *logging.Logger, decoder *Decoder) (types.CgroupAttachTaskArgs, error) {
  var result types.CgroupAttachTaskArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CgroupAttachTaskArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'CgroupAttachTask': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CgroupAttachTaskArgs{}, err
    }

    switch currArg {
    case 0:
      result.CgroupPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.CgroupAttachTaskArgs{}, err
      }
    case 1:
      result.Comm, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.CgroupAttachTaskArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Pid)
      if err != nil {
        return types.CgroupAttachTaskArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseCgroupMkdirArgs(log *logging.Logger, decoder *Decoder) (types.CgroupMkdirArgs, error) {
  var result types.CgroupMkdirArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CgroupMkdirArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'CgroupMkdir': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CgroupMkdirArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.CgroupId)
      if err != nil {
        return types.CgroupMkdirArgs{}, err
      }
    case 1:
      result.CgroupPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.CgroupMkdirArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.HierarchyId)
      if err != nil {
        return types.CgroupMkdirArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseCgroupRmdirArgs(log *logging.Logger, decoder *Decoder) (types.CgroupRmdirArgs, error) {
  var result types.CgroupRmdirArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CgroupRmdirArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'CgroupRmdir': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CgroupRmdirArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.CgroupId)
      if err != nil {
        return types.CgroupRmdirArgs{}, err
      }
    case 1:
      result.CgroupPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.CgroupRmdirArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.HierarchyId)
      if err != nil {
        return types.CgroupRmdirArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecurityFileOpenArgs(log *logging.Logger, decoder *Decoder) (types.SecurityFileOpenArgs, error) {
  var result types.SecurityFileOpenArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecurityFileOpenArgs{}, err
  }

  if numArgs != 6 {
    log.Warnf("unexpected number of args received when parsing 'SecurityFileOpen': wanted 6, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecurityFileOpenArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityFileOpenArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.SecurityFileOpenArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.SecurityFileOpenArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.SecurityFileOpenArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Ctime)
      if err != nil {
        return types.SecurityFileOpenArgs{}, err
      }
    case 5:
      result.SyscallPathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityFileOpenArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecurityInodeUnlinkArgs(log *logging.Logger, decoder *Decoder) (types.SecurityInodeUnlinkArgs, error) {
  var result types.SecurityInodeUnlinkArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecurityInodeUnlinkArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'SecurityInodeUnlink': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecurityInodeUnlinkArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityInodeUnlinkArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.SecurityInodeUnlinkArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.SecurityInodeUnlinkArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Ctime)
      if err != nil {
        return types.SecurityInodeUnlinkArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecuritySocketCreateArgs(log *logging.Logger, decoder *Decoder) (types.SecuritySocketCreateArgs, error) {
  var result types.SecuritySocketCreateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecuritySocketCreateArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'SecuritySocketCreate': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecuritySocketCreateArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Family)
      if err != nil {
        return types.SecuritySocketCreateArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Type)
      if err != nil {
        return types.SecuritySocketCreateArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Protocol)
      if err != nil {
        return types.SecuritySocketCreateArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Kern)
      if err != nil {
        return types.SecuritySocketCreateArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecuritySocketListenArgs(log *logging.Logger, decoder *Decoder) (types.SecuritySocketListenArgs, error) {
  var result types.SecuritySocketListenArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecuritySocketListenArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SecuritySocketListen': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecuritySocketListenArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.SecuritySocketListenArgs{}, err
      }
    case 1:
      result.LocalAddr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.SecuritySocketListenArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Backlog)
      if err != nil {
        return types.SecuritySocketListenArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecuritySocketConnectArgs(log *logging.Logger, decoder *Decoder) (types.SecuritySocketConnectArgs, error) {
  var result types.SecuritySocketConnectArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecuritySocketConnectArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SecuritySocketConnect': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecuritySocketConnectArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.SecuritySocketConnectArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Type)
      if err != nil {
        return types.SecuritySocketConnectArgs{}, err
      }
    case 2:
      result.RemoteAddr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.SecuritySocketConnectArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecuritySocketAcceptArgs(log *logging.Logger, decoder *Decoder) (types.SecuritySocketAcceptArgs, error) {
  var result types.SecuritySocketAcceptArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecuritySocketAcceptArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SecuritySocketAccept': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecuritySocketAcceptArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.SecuritySocketAcceptArgs{}, err
      }
    case 1:
      result.LocalAddr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.SecuritySocketAcceptArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecuritySocketBindArgs(log *logging.Logger, decoder *Decoder) (types.SecuritySocketBindArgs, error) {
  var result types.SecuritySocketBindArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecuritySocketBindArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SecuritySocketBind': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecuritySocketBindArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.SecuritySocketBindArgs{}, err
      }
    case 1:
      result.LocalAddr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.SecuritySocketBindArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecuritySocketSetsockoptArgs(log *logging.Logger, decoder *Decoder) (types.SecuritySocketSetsockoptArgs, error) {
  var result types.SecuritySocketSetsockoptArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecuritySocketSetsockoptArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'SecuritySocketSetsockopt': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecuritySocketSetsockoptArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.SecuritySocketSetsockoptArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Level)
      if err != nil {
        return types.SecuritySocketSetsockoptArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Optname)
      if err != nil {
        return types.SecuritySocketSetsockoptArgs{}, err
      }
    case 3:
      result.LocalAddr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.SecuritySocketSetsockoptArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecuritySbMountArgs(log *logging.Logger, decoder *Decoder) (types.SecuritySbMountArgs, error) {
  var result types.SecuritySbMountArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecuritySbMountArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'SecuritySbMount': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecuritySbMountArgs{}, err
    }

    switch currArg {
    case 0:
      result.DevName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecuritySbMountArgs{}, err
      }
    case 1:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecuritySbMountArgs{}, err
      }
    case 2:
      result.Type, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecuritySbMountArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Flags)
      if err != nil {
        return types.SecuritySbMountArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecurityBPFArgs(log *logging.Logger, decoder *Decoder) (types.SecurityBPFArgs, error) {
  var result types.SecurityBPFArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecurityBPFArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'SecurityBPF': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecurityBPFArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Cmd)
      if err != nil {
        return types.SecurityBPFArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecurityBPFMapArgs(log *logging.Logger, decoder *Decoder) (types.SecurityBPFMapArgs, error) {
  var result types.SecurityBPFMapArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecurityBPFMapArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SecurityBPFMap': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecurityBPFMapArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.MapId)
      if err != nil {
        return types.SecurityBPFMapArgs{}, err
      }
    case 1:
      result.MapName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityBPFMapArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecurityKernelReadFileArgs(log *logging.Logger, decoder *Decoder) (types.SecurityKernelReadFileArgs, error) {
  var result types.SecurityKernelReadFileArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecurityKernelReadFileArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'SecurityKernelReadFile': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecurityKernelReadFileArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityKernelReadFileArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.SecurityKernelReadFileArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.SecurityKernelReadFileArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Type)
      if err != nil {
        return types.SecurityKernelReadFileArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Ctime)
      if err != nil {
        return types.SecurityKernelReadFileArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecurityPostReadFileArgs(log *logging.Logger, decoder *Decoder) (types.SecurityPostReadFileArgs, error) {
  var result types.SecurityPostReadFileArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecurityPostReadFileArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SecurityPostReadFile': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecurityPostReadFileArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityPostReadFileArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt64(&result.Size)
      if err != nil {
        return types.SecurityPostReadFileArgs{}, err
      }
    case 2:
      err = decoder.DecodeInt32(&result.Type)
      if err != nil {
        return types.SecurityPostReadFileArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecurityInodeMknodArgs(log *logging.Logger, decoder *Decoder) (types.SecurityInodeMknodArgs, error) {
  var result types.SecurityInodeMknodArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecurityInodeMknodArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SecurityInodeMknod': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecurityInodeMknodArgs{}, err
    }

    switch currArg {
    case 0:
      result.FileName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityInodeMknodArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint16(&result.Mode)
      if err != nil {
        return types.SecurityInodeMknodArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.SecurityInodeMknodArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecurityInodeSymlinkEventIdArgs(log *logging.Logger, decoder *Decoder) (types.SecurityInodeSymlinkEventIdArgs, error) {
  var result types.SecurityInodeSymlinkEventIdArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecurityInodeSymlinkEventIdArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SecurityInodeSymlinkEventId': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecurityInodeSymlinkEventIdArgs{}, err
    }

    switch currArg {
    case 0:
      result.Linkpath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityInodeSymlinkEventIdArgs{}, err
      }
    case 1:
      result.Target, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityInodeSymlinkEventIdArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecurityMmapFileArgs(log *logging.Logger, decoder *Decoder) (types.SecurityMmapFileArgs, error) {
  var result types.SecurityMmapFileArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecurityMmapFileArgs{}, err
  }

  if numArgs != 7 {
    log.Warnf("unexpected number of args received when parsing 'SecurityMmapFile': wanted 7, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecurityMmapFileArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityMmapFileArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.SecurityMmapFileArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.SecurityMmapFileArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.SecurityMmapFileArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Ctime)
      if err != nil {
        return types.SecurityMmapFileArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint64(&result.Prot)
      if err != nil {
        return types.SecurityMmapFileArgs{}, err
      }
    case 6:
      err = decoder.DecodeUint64(&result.MmapFlags)
      if err != nil {
        return types.SecurityMmapFileArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseDoMmapArgs(log *logging.Logger, decoder *Decoder) (types.DoMmapArgs, error) {
  var result types.DoMmapArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.DoMmapArgs{}, err
  }

  if numArgs != 10 {
    log.Warnf("unexpected number of args received when parsing 'DoMmap': wanted 10, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.DoMmapArgs{}, err
    }

    switch currArg {
    case 0:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.DoMmapArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 1:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DoMmapArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.DoMmapArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.DoMmapArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.DoMmapArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint64(&result.Ctime)
      if err != nil {
        return types.DoMmapArgs{}, err
      }
    case 6:
      err = decoder.DecodeUint64(&result.Pgoff)
      if err != nil {
        return types.DoMmapArgs{}, err
      }
    case 7:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.DoMmapArgs{}, err
      }
    case 8:
      err = decoder.DecodeUint64(&result.Prot)
      if err != nil {
        return types.DoMmapArgs{}, err
      }
    case 9:
      err = decoder.DecodeUint64(&result.MmapFlags)
      if err != nil {
        return types.DoMmapArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecurityFileMprotectArgs(log *logging.Logger, decoder *Decoder) (types.SecurityFileMprotectArgs, error) {
  var result types.SecurityFileMprotectArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecurityFileMprotectArgs{}, err
  }

  if numArgs != 7 {
    log.Warnf("unexpected number of args received when parsing 'SecurityFileMprotect': wanted 7, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecurityFileMprotectArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityFileMprotectArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Prot)
      if err != nil {
        return types.SecurityFileMprotectArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Ctime)
      if err != nil {
        return types.SecurityFileMprotectArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.PrevProt)
      if err != nil {
        return types.SecurityFileMprotectArgs{}, err
      }
    case 4:
      var dataAddr uint64
      err = decoder.DecodeUint64(&dataAddr)
      if err != nil {
        return types.SecurityFileMprotectArgs{}, err
      }
      result.Addr = uintptr(dataAddr)
    case 5:
      err = decoder.DecodeUint64(&result.Len)
      if err != nil {
        return types.SecurityFileMprotectArgs{}, err
      }
    case 6:
      err = decoder.DecodeInt32(&result.Pkey)
      if err != nil {
        return types.SecurityFileMprotectArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseInitNamespacesArgs(log *logging.Logger, decoder *Decoder) (types.InitNamespacesArgs, error) {
  var result types.InitNamespacesArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.InitNamespacesArgs{}, err
  }

  if numArgs != 10 {
    log.Warnf("unexpected number of args received when parsing 'InitNamespaces': wanted 10, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.InitNamespacesArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.Cgroup)
      if err != nil {
        return types.InitNamespacesArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Ipc)
      if err != nil {
        return types.InitNamespacesArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Mnt)
      if err != nil {
        return types.InitNamespacesArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Net)
      if err != nil {
        return types.InitNamespacesArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint32(&result.Pid)
      if err != nil {
        return types.InitNamespacesArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint32(&result.PidForChildren)
      if err != nil {
        return types.InitNamespacesArgs{}, err
      }
    case 6:
      err = decoder.DecodeUint32(&result.Time)
      if err != nil {
        return types.InitNamespacesArgs{}, err
      }
    case 7:
      err = decoder.DecodeUint32(&result.TimeForChildren)
      if err != nil {
        return types.InitNamespacesArgs{}, err
      }
    case 8:
      err = decoder.DecodeUint32(&result.User)
      if err != nil {
        return types.InitNamespacesArgs{}, err
      }
    case 9:
      err = decoder.DecodeUint32(&result.Uts)
      if err != nil {
        return types.InitNamespacesArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSocketDupArgs(log *logging.Logger, decoder *Decoder) (types.SocketDupArgs, error) {
  var result types.SocketDupArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SocketDupArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SocketDup': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SocketDupArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Oldfd)
      if err != nil {
        return types.SocketDupArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Newfd)
      if err != nil {
        return types.SocketDupArgs{}, err
      }
    case 2:
      result.RemoteAddr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.SocketDupArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseHiddenInodesArgs(log *logging.Logger, decoder *Decoder) (types.HiddenInodesArgs, error) {
  var result types.HiddenInodesArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.HiddenInodesArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'HiddenInodes': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.HiddenInodesArgs{}, err
    }

    switch currArg {
    case 0:
      result.HiddenProcess, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.HiddenInodesArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseKernelWriteArgs(log *logging.Logger, decoder *Decoder) (types.KernelWriteArgs, error) {
  var result types.KernelWriteArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.KernelWriteArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'KernelWrite': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.KernelWriteArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.KernelWriteArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.KernelWriteArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.KernelWriteArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.KernelWriteArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Pos)
      if err != nil {
        return types.KernelWriteArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseDirtyPipeSpliceArgs(log *logging.Logger, decoder *Decoder) (types.DirtyPipeSpliceArgs, error) {
  var result types.DirtyPipeSpliceArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.DirtyPipeSpliceArgs{}, err
  }

  if numArgs != 7 {
    log.Warnf("unexpected number of args received when parsing 'DirtyPipeSplice': wanted 7, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.DirtyPipeSpliceArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.InodeIn)
      if err != nil {
        return types.DirtyPipeSpliceArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint16(&result.InFileType)
      if err != nil {
        return types.DirtyPipeSpliceArgs{}, err
      }
    case 2:
      result.InFilePath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DirtyPipeSpliceArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.ExposedDataStartOffset)
      if err != nil {
        return types.DirtyPipeSpliceArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.ExposedDataLen)
      if err != nil {
        return types.DirtyPipeSpliceArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint64(&result.InodeOut)
      if err != nil {
        return types.DirtyPipeSpliceArgs{}, err
      }
    case 6:
      err = decoder.DecodeUint32(&result.OutPipeLastBufferFlags)
      if err != nil {
        return types.DirtyPipeSpliceArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseContainerCreateArgs(log *logging.Logger, decoder *Decoder) (types.ContainerCreateArgs, error) {
  var result types.ContainerCreateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ContainerCreateArgs{}, err
  }

  if numArgs != 10 {
    log.Warnf("unexpected number of args received when parsing 'ContainerCreate': wanted 10, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ContainerCreateArgs{}, err
    }

    switch currArg {
    case 0:
      result.Runtime, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ContainerCreateArgs{}, err
      }
    case 1:
      result.ContainerId, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ContainerCreateArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Ctime)
      if err != nil {
        return types.ContainerCreateArgs{}, err
      }
    case 3:
      result.ContainerImage, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ContainerCreateArgs{}, err
      }
    case 4:
      result.ContainerImageDigest, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ContainerCreateArgs{}, err
      }
    case 5:
      result.ContainerName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ContainerCreateArgs{}, err
      }
    case 6:
      result.PodName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ContainerCreateArgs{}, err
      }
    case 7:
      result.PodNamespace, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ContainerCreateArgs{}, err
      }
    case 8:
      result.PodUid, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ContainerCreateArgs{}, err
      }
    case 9:
      err = decoder.DecodeBool(&result.PodSandbox)
      if err != nil {
        return types.ContainerCreateArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseContainerRemoveArgs(log *logging.Logger, decoder *Decoder) (types.ContainerRemoveArgs, error) {
  var result types.ContainerRemoveArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ContainerRemoveArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ContainerRemove': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ContainerRemoveArgs{}, err
    }

    switch currArg {
    case 0:
      result.Runtime, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ContainerRemoveArgs{}, err
      }
    case 1:
      result.ContainerId, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ContainerRemoveArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseExistingContainerArgs(log *logging.Logger, decoder *Decoder) (types.ExistingContainerArgs, error) {
  var result types.ExistingContainerArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ExistingContainerArgs{}, err
  }

  if numArgs != 10 {
    log.Warnf("unexpected number of args received when parsing 'ExistingContainer': wanted 10, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ExistingContainerArgs{}, err
    }

    switch currArg {
    case 0:
      result.Runtime, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ExistingContainerArgs{}, err
      }
    case 1:
      result.ContainerId, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ExistingContainerArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Ctime)
      if err != nil {
        return types.ExistingContainerArgs{}, err
      }
    case 3:
      result.ContainerImage, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ExistingContainerArgs{}, err
      }
    case 4:
      result.ContainerImageDigest, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ExistingContainerArgs{}, err
      }
    case 5:
      result.ContainerName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ExistingContainerArgs{}, err
      }
    case 6:
      result.PodName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ExistingContainerArgs{}, err
      }
    case 7:
      result.PodNamespace, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ExistingContainerArgs{}, err
      }
    case 8:
      result.PodUid, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ExistingContainerArgs{}, err
      }
    case 9:
      err = decoder.DecodeBool(&result.PodSandbox)
      if err != nil {
        return types.ExistingContainerArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseProcCreateArgs(log *logging.Logger, decoder *Decoder) (types.ProcCreateArgs, error) {
  var result types.ProcCreateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ProcCreateArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'ProcCreate': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ProcCreateArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ProcCreateArgs{}, err
      }
    case 1:
      var dataProcOpsAddr uint64
      err = decoder.DecodeUint64(&dataProcOpsAddr)
      if err != nil {
        return types.ProcCreateArgs{}, err
      }
      result.ProcOpsAddr = uintptr(dataProcOpsAddr)
    }
  }
  return result, nil
}

func ParseKprobeAttachArgs(log *logging.Logger, decoder *Decoder) (types.KprobeAttachArgs, error) {
  var result types.KprobeAttachArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.KprobeAttachArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'KprobeAttach': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.KprobeAttachArgs{}, err
    }

    switch currArg {
    case 0:
      result.SymbolName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.KprobeAttachArgs{}, err
      }
    case 1:
      var dataPreHandlerAddr uint64
      err = decoder.DecodeUint64(&dataPreHandlerAddr)
      if err != nil {
        return types.KprobeAttachArgs{}, err
      }
      result.PreHandlerAddr = uintptr(dataPreHandlerAddr)
    case 2:
      var dataPostHandlerAddr uint64
      err = decoder.DecodeUint64(&dataPostHandlerAddr)
      if err != nil {
        return types.KprobeAttachArgs{}, err
      }
      result.PostHandlerAddr = uintptr(dataPostHandlerAddr)
    }
  }
  return result, nil
}

func ParseCallUsermodeHelperArgs(log *logging.Logger, decoder *Decoder) (types.CallUsermodeHelperArgs, error) {
  var result types.CallUsermodeHelperArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.CallUsermodeHelperArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'CallUsermodeHelper': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.CallUsermodeHelperArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.CallUsermodeHelperArgs{}, err
      }
    case 1:
      result.Argv, err = decoder.ReadStringArrayFromBuff()
      if err != nil {
        return types.CallUsermodeHelperArgs{}, err
      }
    case 2:
      result.Envp, err = decoder.ReadStringArrayFromBuff()
      if err != nil {
        return types.CallUsermodeHelperArgs{}, err
      }
    case 3:
      err = decoder.DecodeInt32(&result.Wait)
      if err != nil {
        return types.CallUsermodeHelperArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseDebugfsCreateFileArgs(log *logging.Logger, decoder *Decoder) (types.DebugfsCreateFileArgs, error) {
  var result types.DebugfsCreateFileArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.DebugfsCreateFileArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'DebugfsCreateFile': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.DebugfsCreateFileArgs{}, err
    }

    switch currArg {
    case 0:
      result.FileName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DebugfsCreateFileArgs{}, err
      }
    case 1:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DebugfsCreateFileArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.DebugfsCreateFileArgs{}, err
      }
    case 3:
      var dataProcOpsAddr uint64
      err = decoder.DecodeUint64(&dataProcOpsAddr)
      if err != nil {
        return types.DebugfsCreateFileArgs{}, err
      }
      result.ProcOpsAddr = uintptr(dataProcOpsAddr)
    }
  }
  return result, nil
}

func ParsePrintSyscallTableArgs(log *logging.Logger, decoder *Decoder) (types.PrintSyscallTableArgs, error) {
  var result types.PrintSyscallTableArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PrintSyscallTableArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'PrintSyscallTable': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PrintSyscallTableArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64Array(&result.SyscallsAddresses)
      if err != nil {
        return types.PrintSyscallTableArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.CallerContextId)
      if err != nil {
        return types.PrintSyscallTableArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseHiddenKernelModuleArgs(log *logging.Logger, decoder *Decoder) (types.HiddenKernelModuleArgs, error) {
  var result types.HiddenKernelModuleArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.HiddenKernelModuleArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'HiddenKernelModule': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.HiddenKernelModuleArgs{}, err
    }

    switch currArg {
    case 0:
      result.Address, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.HiddenKernelModuleArgs{}, err
      }
    case 1:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.HiddenKernelModuleArgs{}, err
      }
    case 2:
      result.Srcversion, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.HiddenKernelModuleArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseHiddenKernelModuleSeekerArgs(log *logging.Logger, decoder *Decoder) (types.HiddenKernelModuleSeekerArgs, error) {
  var result types.HiddenKernelModuleSeekerArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.HiddenKernelModuleSeekerArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'HiddenKernelModuleSeeker': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.HiddenKernelModuleSeekerArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.Address)
      if err != nil {
        return types.HiddenKernelModuleSeekerArgs{}, err
      }
    case 1:
      result.Name, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.HiddenKernelModuleSeeker))
      if err != nil {
        return types.HiddenKernelModuleSeekerArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Flags)
      if err != nil {
        return types.HiddenKernelModuleSeekerArgs{}, err
      }
    case 3:
      result.Srcversion, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.HiddenKernelModuleSeeker))
      if err != nil {
        return types.HiddenKernelModuleSeekerArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseHookedSyscallsArgs(log *logging.Logger, decoder *Decoder) (types.HookedSyscallsArgs, error) {
  var result types.HookedSyscallsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.HookedSyscallsArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'HookedSyscalls': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.HookedSyscallsArgs{}, err
    }

    switch currArg {
    case 0:
      var dataCheckSyscalls uint64
      err = decoder.DecodeUint64(&dataCheckSyscalls)
      if err != nil {
        return types.HookedSyscallsArgs{}, err
      }
      result.CheckSyscalls = uintptr(dataCheckSyscalls)
    case 1:
      var dataHookedSyscalls uint64
      err = decoder.DecodeUint64(&dataHookedSyscalls)
      if err != nil {
        return types.HookedSyscallsArgs{}, err
      }
      result.HookedSyscalls = uintptr(dataHookedSyscalls)
    }
  }
  return result, nil
}

func ParseDebugfsCreateDirArgs(log *logging.Logger, decoder *Decoder) (types.DebugfsCreateDirArgs, error) {
  var result types.DebugfsCreateDirArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.DebugfsCreateDirArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'DebugfsCreateDir': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.DebugfsCreateDirArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DebugfsCreateDirArgs{}, err
      }
    case 1:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DebugfsCreateDirArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseDeviceAddArgs(log *logging.Logger, decoder *Decoder) (types.DeviceAddArgs, error) {
  var result types.DeviceAddArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.DeviceAddArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'DeviceAdd': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.DeviceAddArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DeviceAddArgs{}, err
      }
    case 1:
      result.ParentName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DeviceAddArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseRegisterChrdevArgs(log *logging.Logger, decoder *Decoder) (types.RegisterChrdevArgs, error) {
  var result types.RegisterChrdevArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.RegisterChrdevArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'RegisterChrdev': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.RegisterChrdevArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.RequestedMajorNumber)
      if err != nil {
        return types.RegisterChrdevArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.GrantedMajorNumber)
      if err != nil {
        return types.RegisterChrdevArgs{}, err
      }
    case 2:
      result.CharDeviceName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.RegisterChrdevArgs{}, err
      }
    case 3:
      var dataCharDeviceFops uint64
      err = decoder.DecodeUint64(&dataCharDeviceFops)
      if err != nil {
        return types.RegisterChrdevArgs{}, err
      }
      result.CharDeviceFops = uintptr(dataCharDeviceFops)
    }
  }
  return result, nil
}

func ParseSharedObjectLoadedArgs(log *logging.Logger, decoder *Decoder) (types.SharedObjectLoadedArgs, error) {
  var result types.SharedObjectLoadedArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SharedObjectLoadedArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'SharedObjectLoaded': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SharedObjectLoadedArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SharedObjectLoadedArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.SharedObjectLoadedArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.SharedObjectLoadedArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.SharedObjectLoadedArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Ctime)
      if err != nil {
        return types.SharedObjectLoadedArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSymbolsLoadedArgs(log *logging.Logger, decoder *Decoder) (types.SymbolsLoadedArgs, error) {
  var result types.SymbolsLoadedArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SymbolsLoadedArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SymbolsLoaded': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SymbolsLoadedArgs{}, err
    }

    switch currArg {
    case 0:
      result.LibraryPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SymbolsLoadedArgs{}, err
      }
    case 1:
      result.Symbols, err = decoder.ReadStringArrayFromBuff()
      if err != nil {
        return types.SymbolsLoadedArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSymbolsCollisionArgs(log *logging.Logger, decoder *Decoder) (types.SymbolsCollisionArgs, error) {
  var result types.SymbolsCollisionArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SymbolsCollisionArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SymbolsCollision': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SymbolsCollisionArgs{}, err
    }

    switch currArg {
    case 0:
      result.LoadedPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SymbolsCollisionArgs{}, err
      }
    case 1:
      result.CollisionPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SymbolsCollisionArgs{}, err
      }
    case 2:
      result.Symbols, err = decoder.ReadStringArrayFromBuff()
      if err != nil {
        return types.SymbolsCollisionArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseCaptureFileWriteArgs(log *logging.Logger, decoder *Decoder) (types.CaptureFileWriteArgs, error) {
  return types.CaptureFileWriteArgs{}, nil
}

func ParseCaptureFileReadArgs(log *logging.Logger, decoder *Decoder) (types.CaptureFileReadArgs, error) {
  return types.CaptureFileReadArgs{}, nil
}

func ParseCaptureExecArgs(log *logging.Logger, decoder *Decoder) (types.CaptureExecArgs, error) {
  return types.CaptureExecArgs{}, nil
}

func ParseCaptureModuleArgs(log *logging.Logger, decoder *Decoder) (types.CaptureModuleArgs, error) {
  return types.CaptureModuleArgs{}, nil
}

func ParseCaptureMemArgs(log *logging.Logger, decoder *Decoder) (types.CaptureMemArgs, error) {
  return types.CaptureMemArgs{}, nil
}

func ParseCaptureBpfArgs(log *logging.Logger, decoder *Decoder) (types.CaptureBpfArgs, error) {
  return types.CaptureBpfArgs{}, nil
}

func ParseDoInitModuleArgs(log *logging.Logger, decoder *Decoder) (types.DoInitModuleArgs, error) {
  var result types.DoInitModuleArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.DoInitModuleArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'DoInitModule': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.DoInitModuleArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DoInitModuleArgs{}, err
      }
    case 1:
      result.Version, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DoInitModuleArgs{}, err
      }
    case 2:
      result.SrcVersion, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DoInitModuleArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseModuleLoadArgs(log *logging.Logger, decoder *Decoder) (types.ModuleLoadArgs, error) {
  var result types.ModuleLoadArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ModuleLoadArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'ModuleLoad': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ModuleLoadArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ModuleLoadArgs{}, err
      }
    case 1:
      result.Version, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ModuleLoadArgs{}, err
      }
    case 2:
      result.SrcVersion, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ModuleLoadArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseModuleFreeArgs(log *logging.Logger, decoder *Decoder) (types.ModuleFreeArgs, error) {
  var result types.ModuleFreeArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ModuleFreeArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'ModuleFree': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ModuleFreeArgs{}, err
    }

    switch currArg {
    case 0:
      result.Name, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ModuleFreeArgs{}, err
      }
    case 1:
      result.Version, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ModuleFreeArgs{}, err
      }
    case 2:
      result.SrcVersion, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ModuleFreeArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSocketAcceptArgs(log *logging.Logger, decoder *Decoder) (types.SocketAcceptArgs, error) {
  var result types.SocketAcceptArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SocketAcceptArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SocketAccept': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SocketAcceptArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sockfd)
      if err != nil {
        return types.SocketAcceptArgs{}, err
      }
    case 1:
      result.LocalAddr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.SocketAcceptArgs{}, err
      }
    case 2:
      result.RemoteAddr, err = decoder.ReadSockaddrFromBuff()
      if err != nil {
        return types.SocketAcceptArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseLoadElfPhdrsArgs(log *logging.Logger, decoder *Decoder) (types.LoadElfPhdrsArgs, error) {
  var result types.LoadElfPhdrsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.LoadElfPhdrsArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'LoadElfPhdrs': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.LoadElfPhdrsArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.LoadElfPhdrsArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.LoadElfPhdrsArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.LoadElfPhdrsArgs{}, err
      }
    }
  }
  return result, nil
}

func ParsePrintNetSeqOpsArgs(log *logging.Logger, decoder *Decoder) (types.PrintNetSeqOpsArgs, error) {
  var result types.PrintNetSeqOpsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PrintNetSeqOpsArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'PrintNetSeqOps': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PrintNetSeqOpsArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64Array(&result.NetSeqOps)
      if err != nil {
        return types.PrintNetSeqOpsArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.CallerContextId)
      if err != nil {
        return types.PrintNetSeqOpsArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseHookedSeqOpsArgs(log *logging.Logger, decoder *Decoder) (types.HookedSeqOpsArgs, error) {
  var result types.HookedSeqOpsArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.HookedSeqOpsArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'HookedSeqOps': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.HookedSeqOpsArgs{}, err
    }

    switch currArg {
    case 0:
      var dataHookedSeqOps uint64
      err = decoder.DecodeUint64(&dataHookedSeqOps)
      if err != nil {
        return types.HookedSeqOpsArgs{}, err
      }
      result.HookedSeqOps = uintptr(dataHookedSeqOps)
    }
  }
  return result, nil
}

func ParseTaskRenameArgs(log *logging.Logger, decoder *Decoder) (types.TaskRenameArgs, error) {
  var result types.TaskRenameArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TaskRenameArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'TaskRename': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TaskRenameArgs{}, err
    }

    switch currArg {
    case 0:
      result.OldName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.TaskRenameArgs{}, err
      }
    case 1:
      result.NewName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.TaskRenameArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSecurityInodeRenameArgs(log *logging.Logger, decoder *Decoder) (types.SecurityInodeRenameArgs, error) {
  var result types.SecurityInodeRenameArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SecurityInodeRenameArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'SecurityInodeRename': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SecurityInodeRenameArgs{}, err
    }

    switch currArg {
    case 0:
      result.OldPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityInodeRenameArgs{}, err
      }
    case 1:
      result.NewPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SecurityInodeRenameArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseDoSigactionArgs(log *logging.Logger, decoder *Decoder) (types.DoSigactionArgs, error) {
  var result types.DoSigactionArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.DoSigactionArgs{}, err
  }

  if numArgs != 11 {
    log.Warnf("unexpected number of args received when parsing 'DoSigaction': wanted 11, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.DoSigactionArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Sig)
      if err != nil {
        return types.DoSigactionArgs{}, err
      }
    case 1:
      err = decoder.DecodeBool(&result.IsSaInitialized)
      if err != nil {
        return types.DoSigactionArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.SaFlags)
      if err != nil {
        return types.DoSigactionArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.SaMask)
      if err != nil {
        return types.DoSigactionArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint8(&result.SaHandleMethod)
      if err != nil {
        return types.DoSigactionArgs{}, err
      }
    case 5:
      var dataSaHandler uint64
      err = decoder.DecodeUint64(&dataSaHandler)
      if err != nil {
        return types.DoSigactionArgs{}, err
      }
      result.SaHandler = uintptr(dataSaHandler)
    case 6:
      err = decoder.DecodeBool(&result.IsOldSaInitialized)
      if err != nil {
        return types.DoSigactionArgs{}, err
      }
    case 7:
      err = decoder.DecodeUint64(&result.OldSaFlags)
      if err != nil {
        return types.DoSigactionArgs{}, err
      }
    case 8:
      err = decoder.DecodeUint64(&result.OldSaMask)
      if err != nil {
        return types.DoSigactionArgs{}, err
      }
    case 9:
      err = decoder.DecodeUint8(&result.OldSaHandleMethod)
      if err != nil {
        return types.DoSigactionArgs{}, err
      }
    case 10:
      var dataOldSaHandler uint64
      err = decoder.DecodeUint64(&dataOldSaHandler)
      if err != nil {
        return types.DoSigactionArgs{}, err
      }
      result.OldSaHandler = uintptr(dataOldSaHandler)
    }
  }
  return result, nil
}

func ParseBpfAttachArgs(log *logging.Logger, decoder *Decoder) (types.BpfAttachArgs, error) {
  var result types.BpfAttachArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.BpfAttachArgs{}, err
  }

  if numArgs != 7 {
    log.Warnf("unexpected number of args received when parsing 'BpfAttach': wanted 7, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.BpfAttachArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.ProgType)
      if err != nil {
        return types.BpfAttachArgs{}, err
      }
    case 1:
      result.ProgName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.BpfAttachArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.ProgId)
      if err != nil {
        return types.BpfAttachArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64Array(&result.ProgHelpers)
      if err != nil {
        return types.BpfAttachArgs{}, err
      }
    case 4:
      result.SymbolName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.BpfAttachArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint64(&result.SymbolAddr)
      if err != nil {
        return types.BpfAttachArgs{}, err
      }
    case 6:
      err = decoder.DecodeInt32(&result.AttachType)
      if err != nil {
        return types.BpfAttachArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseKallsymsLookupNameArgs(log *logging.Logger, decoder *Decoder) (types.KallsymsLookupNameArgs, error) {
  var result types.KallsymsLookupNameArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.KallsymsLookupNameArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'KallsymsLookupName': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.KallsymsLookupNameArgs{}, err
    }

    switch currArg {
    case 0:
      result.SymbolName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.KallsymsLookupNameArgs{}, err
      }
    case 1:
      var dataSymbolAddress uint64
      err = decoder.DecodeUint64(&dataSymbolAddress)
      if err != nil {
        return types.KallsymsLookupNameArgs{}, err
      }
      result.SymbolAddress = uintptr(dataSymbolAddress)
    }
  }
  return result, nil
}

func ParsePrintMemDumpArgs(log *logging.Logger, decoder *Decoder) (types.PrintMemDumpArgs, error) {
  var result types.PrintMemDumpArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.PrintMemDumpArgs{}, err
  }

  if numArgs != 7 {
    log.Warnf("unexpected number of args received when parsing 'PrintMemDump': wanted 7, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.PrintMemDumpArgs{}, err
    }

    switch currArg {
    case 0:
      result.Bytes, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.PrintMemDump))
      if err != nil {
        return types.PrintMemDumpArgs{}, err
      }
    case 1:
      var dataAddress uint64
      err = decoder.DecodeUint64(&dataAddress)
      if err != nil {
        return types.PrintMemDumpArgs{}, err
      }
      result.Address = uintptr(dataAddress)
    case 2:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.PrintMemDumpArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.CallerContextId)
      if err != nil {
        return types.PrintMemDumpArgs{}, err
      }
    case 4:
      result.Arch, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.PrintMemDumpArgs{}, err
      }
    case 5:
      result.SymbolName, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.PrintMemDumpArgs{}, err
      }
    case 6:
      result.SymbolOwner, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.PrintMemDumpArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseVfsReadArgs(log *logging.Logger, decoder *Decoder) (types.VfsReadArgs, error) {
  var result types.VfsReadArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.VfsReadArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'VfsRead': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.VfsReadArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.VfsReadArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.VfsReadArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.VfsReadArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.VfsReadArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Pos)
      if err != nil {
        return types.VfsReadArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseVfsReadvArgs(log *logging.Logger, decoder *Decoder) (types.VfsReadvArgs, error) {
  var result types.VfsReadvArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.VfsReadvArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'VfsReadv': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.VfsReadvArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.VfsReadvArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.VfsReadvArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.VfsReadvArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Vlen)
      if err != nil {
        return types.VfsReadvArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Pos)
      if err != nil {
        return types.VfsReadvArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseVfsUtimesArgs(log *logging.Logger, decoder *Decoder) (types.VfsUtimesArgs, error) {
  var result types.VfsUtimesArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.VfsUtimesArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'VfsUtimes': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.VfsUtimesArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.VfsUtimesArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.VfsUtimesArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.VfsUtimesArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Atime)
      if err != nil {
        return types.VfsUtimesArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.Mtime)
      if err != nil {
        return types.VfsUtimesArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseDoTruncateArgs(log *logging.Logger, decoder *Decoder) (types.DoTruncateArgs, error) {
  var result types.DoTruncateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.DoTruncateArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'DoTruncate': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.DoTruncateArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.DoTruncateArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.DoTruncateArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.DoTruncateArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.Length)
      if err != nil {
        return types.DoTruncateArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseFileModificationArgs(log *logging.Logger, decoder *Decoder) (types.FileModificationArgs, error) {
  var result types.FileModificationArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.FileModificationArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'FileModification': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.FileModificationArgs{}, err
    }

    switch currArg {
    case 0:
      result.FilePath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.FileModificationArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.FileModificationArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.FileModificationArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.OldCtime)
      if err != nil {
        return types.FileModificationArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.NewCtime)
      if err != nil {
        return types.FileModificationArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseInotifyWatchArgs(log *logging.Logger, decoder *Decoder) (types.InotifyWatchArgs, error) {
  var result types.InotifyWatchArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.InotifyWatchArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'InotifyWatch': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.InotifyWatchArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.InotifyWatchArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.InotifyWatchArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.InotifyWatchArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseProcessExecuteFailedArgs(log *logging.Logger, decoder *Decoder) (types.ProcessExecuteFailedArgs, error) {
  var result types.ProcessExecuteFailedArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ProcessExecuteFailedArgs{}, err
  }

  if numArgs != 12 {
    log.Warnf("unexpected number of args received when parsing 'ProcessExecuteFailed': wanted 12, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ProcessExecuteFailedArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    case 1:
      result.BinaryPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.BinaryDeviceId)
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.BinaryInodeNumber)
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.BinaryCtime)
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint16(&result.BinaryInodeMode)
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    case 6:
      result.InterpreterPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    case 7:
      err = decoder.DecodeUint16(&result.StdinType)
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    case 8:
      result.StdinPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    case 9:
      err = decoder.DecodeInt32(&result.KernelInvoked)
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    case 10:
      result.BinaryArguments, err = decoder.ReadStringArrayFromBuff()
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    case 11:
      result.Environment, err = decoder.ReadStringArrayFromBuff()
      if err != nil {
        return types.ProcessExecuteFailedArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseTtyOpenArgs(log *logging.Logger, decoder *Decoder) (types.TtyOpenArgs, error) {
  var result types.TtyOpenArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.TtyOpenArgs{}, err
  }

  if numArgs != 4 {
    log.Warnf("unexpected number of args received when parsing 'TtyOpen': wanted 4, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.TtyOpenArgs{}, err
    }

    switch currArg {
    case 0:
      result.Path, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.TtyOpenArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint64(&result.Inode)
      if err != nil {
        return types.TtyOpenArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint16(&result.InodeMode)
      if err != nil {
        return types.TtyOpenArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint32(&result.Dev)
      if err != nil {
        return types.TtyOpenArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseNetPacketBaseArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketBaseArgs, error) {
  return types.NetPacketBaseArgs{}, nil
}

func ParseNetPacketIPBaseArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketIPBaseArgs, error) {
  var result types.NetPacketIPBaseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketIPBaseArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketIPBase': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketIPBaseArgs{}, err
    }

    switch currArg {
    case 0:
      result.Payload, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.NetPacketIPBase))
      if err != nil {
        return types.NetPacketIPBaseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseNetPacketIPv4Args(log *logging.Logger, decoder *Decoder) (types.NetPacketIPv4Args, error) {
  var result types.NetPacketIPv4Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketIPv4Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketIPv4': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketIPv4Args{}, err
    }

    switch currArg {
    case 0:
      result.Src, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketIPv4Args{}, err
      }
    case 1:
      result.Dst, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketIPv4Args{}, err
      }
    case 2:
      var dataProtoIpv4 uint64
      err = decoder.DecodeUint64(&dataProtoIpv4)
      if err != nil {
        return types.NetPacketIPv4Args{}, err
      }
      result.ProtoIpv4 = uintptr(dataProtoIpv4)
    }
  }
  return result, nil
}

func ParseNetPacketIPv6Args(log *logging.Logger, decoder *Decoder) (types.NetPacketIPv6Args, error) {
  var result types.NetPacketIPv6Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketIPv6Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketIPv6': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketIPv6Args{}, err
    }

    switch currArg {
    case 0:
      result.Src, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketIPv6Args{}, err
      }
    case 1:
      result.Dst, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketIPv6Args{}, err
      }
    case 2:
      var dataProtoIpv6 uint64
      err = decoder.DecodeUint64(&dataProtoIpv6)
      if err != nil {
        return types.NetPacketIPv6Args{}, err
      }
      result.ProtoIpv6 = uintptr(dataProtoIpv6)
    }
  }
  return result, nil
}

func ParseNetPacketTCPBaseArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketTCPBaseArgs, error) {
  var result types.NetPacketTCPBaseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketTCPBaseArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketTCPBase': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketTCPBaseArgs{}, err
    }

    switch currArg {
    case 0:
      result.Payload, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.NetPacketTCPBase))
      if err != nil {
        return types.NetPacketTCPBaseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseNetPacketTCPArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketTCPArgs, error) {
  var result types.NetPacketTCPArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketTCPArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketTCP': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketTCPArgs{}, err
    }

    switch currArg {
    case 0:
      result.Src, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketTCPArgs{}, err
      }
    case 1:
      result.Dst, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketTCPArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint16(&result.SrcPort)
      if err != nil {
        return types.NetPacketTCPArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint16(&result.DstPort)
      if err != nil {
        return types.NetPacketTCPArgs{}, err
      }
    case 4:
      var dataProtoTcp uint64
      err = decoder.DecodeUint64(&dataProtoTcp)
      if err != nil {
        return types.NetPacketTCPArgs{}, err
      }
      result.ProtoTcp = uintptr(dataProtoTcp)
    }
  }
  return result, nil
}

func ParseNetPacketUDPBaseArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketUDPBaseArgs, error) {
  var result types.NetPacketUDPBaseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketUDPBaseArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketUDPBase': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketUDPBaseArgs{}, err
    }

    switch currArg {
    case 0:
      result.Payload, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.NetPacketUDPBase))
      if err != nil {
        return types.NetPacketUDPBaseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseNetPacketUDPArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketUDPArgs, error) {
  var result types.NetPacketUDPArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketUDPArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketUDP': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketUDPArgs{}, err
    }

    switch currArg {
    case 0:
      result.Src, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketUDPArgs{}, err
      }
    case 1:
      result.Dst, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketUDPArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint16(&result.SrcPort)
      if err != nil {
        return types.NetPacketUDPArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint16(&result.DstPort)
      if err != nil {
        return types.NetPacketUDPArgs{}, err
      }
    case 4:
      var dataProtoUdp uint64
      err = decoder.DecodeUint64(&dataProtoUdp)
      if err != nil {
        return types.NetPacketUDPArgs{}, err
      }
      result.ProtoUdp = uintptr(dataProtoUdp)
    }
  }
  return result, nil
}

func ParseNetPacketICMPBaseArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketICMPBaseArgs, error) {
  var result types.NetPacketICMPBaseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketICMPBaseArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketICMPBase': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketICMPBaseArgs{}, err
    }

    switch currArg {
    case 0:
      result.Payload, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.NetPacketICMPBase))
      if err != nil {
        return types.NetPacketICMPBaseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseNetPacketICMPArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketICMPArgs, error) {
  var result types.NetPacketICMPArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketICMPArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketICMP': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketICMPArgs{}, err
    }

    switch currArg {
    case 0:
      result.Src, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketICMPArgs{}, err
      }
    case 1:
      result.Dst, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketICMPArgs{}, err
      }
    case 2:
      var dataProtoIcmp uint64
      err = decoder.DecodeUint64(&dataProtoIcmp)
      if err != nil {
        return types.NetPacketICMPArgs{}, err
      }
      result.ProtoIcmp = uintptr(dataProtoIcmp)
    }
  }
  return result, nil
}

func ParseNetPacketICMPv6BaseArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketICMPv6BaseArgs, error) {
  var result types.NetPacketICMPv6BaseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketICMPv6BaseArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketICMPv6Base': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketICMPv6BaseArgs{}, err
    }

    switch currArg {
    case 0:
      result.Payload, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.NetPacketICMPv6Base))
      if err != nil {
        return types.NetPacketICMPv6BaseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseNetPacketICMPv6Args(log *logging.Logger, decoder *Decoder) (types.NetPacketICMPv6Args, error) {
  var result types.NetPacketICMPv6Args
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketICMPv6Args{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketICMPv6': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketICMPv6Args{}, err
    }

    switch currArg {
    case 0:
      result.Src, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketICMPv6Args{}, err
      }
    case 1:
      result.Dst, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketICMPv6Args{}, err
      }
    case 2:
      var dataProtoIcmpv6 uint64
      err = decoder.DecodeUint64(&dataProtoIcmpv6)
      if err != nil {
        return types.NetPacketICMPv6Args{}, err
      }
      result.ProtoIcmpv6 = uintptr(dataProtoIcmpv6)
    }
  }
  return result, nil
}

func ParseNetPacketDNSBaseArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketDNSBaseArgs, error) {
  var result types.NetPacketDNSBaseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketDNSBaseArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketDNSBase': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketDNSBaseArgs{}, err
    }

    switch currArg {
    case 0:
      result.Payload, err = decoder.ReadProtoDNS()
      if err != nil {
        return types.NetPacketDNSBaseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseNetPacketDNSArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketDNSArgs, error) {
  var result types.NetPacketDNSArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketDNSArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketDNS': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketDNSArgs{}, err
    }

    switch currArg {
    case 0:
      result.Src, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketDNSArgs{}, err
      }
    case 1:
      result.Dst, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketDNSArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint16(&result.SrcPort)
      if err != nil {
        return types.NetPacketDNSArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint16(&result.DstPort)
      if err != nil {
        return types.NetPacketDNSArgs{}, err
      }
    case 4:
      var dataProtoDns uint64
      err = decoder.DecodeUint64(&dataProtoDns)
      if err != nil {
        return types.NetPacketDNSArgs{}, err
      }
      result.ProtoDns = uintptr(dataProtoDns)
    }
  }
  return result, nil
}

func ParseNetPacketDNSRequestArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketDNSRequestArgs, error) {
  var result types.NetPacketDNSRequestArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketDNSRequestArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketDNSRequest': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketDNSRequestArgs{}, err
    }

    switch currArg {
    case 0:
      var dataMetadata uint64
      err = decoder.DecodeUint64(&dataMetadata)
      if err != nil {
        return types.NetPacketDNSRequestArgs{}, err
      }
      result.Metadata = uintptr(dataMetadata)
    case 1:
      var dataDnsQuestions uint64
      err = decoder.DecodeUint64(&dataDnsQuestions)
      if err != nil {
        return types.NetPacketDNSRequestArgs{}, err
      }
      result.DnsQuestions = uintptr(dataDnsQuestions)
    }
  }
  return result, nil
}

func ParseNetPacketDNSResponseArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketDNSResponseArgs, error) {
  var result types.NetPacketDNSResponseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketDNSResponseArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketDNSResponse': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketDNSResponseArgs{}, err
    }

    switch currArg {
    case 0:
      var dataMetadata uint64
      err = decoder.DecodeUint64(&dataMetadata)
      if err != nil {
        return types.NetPacketDNSResponseArgs{}, err
      }
      result.Metadata = uintptr(dataMetadata)
    case 1:
      var dataDnsResponse uint64
      err = decoder.DecodeUint64(&dataDnsResponse)
      if err != nil {
        return types.NetPacketDNSResponseArgs{}, err
      }
      result.DnsResponse = uintptr(dataDnsResponse)
    }
  }
  return result, nil
}

func ParseNetPacketHTTPBaseArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketHTTPBaseArgs, error) {
  var result types.NetPacketHTTPBaseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketHTTPBaseArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketHTTPBase': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketHTTPBaseArgs{}, err
    }

    switch currArg {
    case 0:
      result.Payload, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.NetPacketHTTPBase))
      if err != nil {
        return types.NetPacketHTTPBaseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseNetPacketHTTPArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketHTTPArgs, error) {
  var result types.NetPacketHTTPArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketHTTPArgs{}, err
  }

  if numArgs != 5 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketHTTP': wanted 5, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketHTTPArgs{}, err
    }

    switch currArg {
    case 0:
      result.Src, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketHTTPArgs{}, err
      }
    case 1:
      result.Dst, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.NetPacketHTTPArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint16(&result.SrcPort)
      if err != nil {
        return types.NetPacketHTTPArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint16(&result.DstPort)
      if err != nil {
        return types.NetPacketHTTPArgs{}, err
      }
    case 4:
      var dataProtoHttp uint64
      err = decoder.DecodeUint64(&dataProtoHttp)
      if err != nil {
        return types.NetPacketHTTPArgs{}, err
      }
      result.ProtoHttp = uintptr(dataProtoHttp)
    }
  }
  return result, nil
}

func ParseNetPacketHTTPRequestArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketHTTPRequestArgs, error) {
  var result types.NetPacketHTTPRequestArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketHTTPRequestArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketHTTPRequest': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketHTTPRequestArgs{}, err
    }

    switch currArg {
    case 0:
      var dataMetadata uint64
      err = decoder.DecodeUint64(&dataMetadata)
      if err != nil {
        return types.NetPacketHTTPRequestArgs{}, err
      }
      result.Metadata = uintptr(dataMetadata)
    case 1:
      var dataHttpRequest uint64
      err = decoder.DecodeUint64(&dataHttpRequest)
      if err != nil {
        return types.NetPacketHTTPRequestArgs{}, err
      }
      result.HttpRequest = uintptr(dataHttpRequest)
    }
  }
  return result, nil
}

func ParseNetPacketHTTPResponseArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketHTTPResponseArgs, error) {
  var result types.NetPacketHTTPResponseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketHTTPResponseArgs{}, err
  }

  if numArgs != 2 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketHTTPResponse': wanted 2, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketHTTPResponseArgs{}, err
    }

    switch currArg {
    case 0:
      var dataMetadata uint64
      err = decoder.DecodeUint64(&dataMetadata)
      if err != nil {
        return types.NetPacketHTTPResponseArgs{}, err
      }
      result.Metadata = uintptr(dataMetadata)
    case 1:
      var dataHttpResponse uint64
      err = decoder.DecodeUint64(&dataHttpResponse)
      if err != nil {
        return types.NetPacketHTTPResponseArgs{}, err
      }
      result.HttpResponse = uintptr(dataHttpResponse)
    }
  }
  return result, nil
}

func ParseNetPacketSOCKS5BaseArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketSOCKS5BaseArgs, error) {
  var result types.NetPacketSOCKS5BaseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketSOCKS5BaseArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketSOCKS5Base': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketSOCKS5BaseArgs{}, err
    }

    switch currArg {
    case 0:
      result.Payload, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.NetPacketSOCKS5Base))
      if err != nil {
        return types.NetPacketSOCKS5BaseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseNetPacketCaptureArgs(log *logging.Logger, decoder *Decoder) (types.NetPacketCaptureArgs, error) {
  var result types.NetPacketCaptureArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetPacketCaptureArgs{}, err
  }

  if numArgs != 1 {
    log.Warnf("unexpected number of args received when parsing 'NetPacketCapture': wanted 1, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetPacketCaptureArgs{}, err
    }

    switch currArg {
    case 0:
      result.Payload, err = decoder.ReadMaxByteSliceFromBuff(eventMaxByteSliceBufferSize(events.NetPacketCapture))
      if err != nil {
        return types.NetPacketCaptureArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseCaptureNetPacketArgs(log *logging.Logger, decoder *Decoder) (types.CaptureNetPacketArgs, error) {
  return types.CaptureNetPacketArgs{}, nil
}

func ParseSockSetStateArgs(log *logging.Logger, decoder *Decoder) (types.SockSetStateArgs, error) {
  var result types.SockSetStateArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SockSetStateArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SockSetState': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SockSetStateArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint32(&result.OldState)
      if err != nil {
        return types.SockSetStateArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint32(&result.NewState)
      if err != nil {
        return types.SockSetStateArgs{}, err
      }
    case 2:
      result.Tuple, err = decoder.ReadAddrTuple()
      if err != nil {
        return types.SockSetStateArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseTrackSyscallStatsArgs(log *logging.Logger, decoder *Decoder) (types.TrackSyscallStatsArgs, error) {
  return types.TrackSyscallStatsArgs{}, nil
}

func ParseTestEventArgs(log *logging.Logger, decoder *Decoder) (types.TestEventArgs, error) {
  return types.TestEventArgs{}, nil
}

func ParseSignalCgroupMkdirArgs(log *logging.Logger, decoder *Decoder) (types.SignalCgroupMkdirArgs, error) {
  var result types.SignalCgroupMkdirArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SignalCgroupMkdirArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SignalCgroupMkdir': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SignalCgroupMkdirArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.CgroupId)
      if err != nil {
        return types.SignalCgroupMkdirArgs{}, err
      }
    case 1:
      result.CgroupPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SignalCgroupMkdirArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.HierarchyId)
      if err != nil {
        return types.SignalCgroupMkdirArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseSignalCgroupRmdirArgs(log *logging.Logger, decoder *Decoder) (types.SignalCgroupRmdirArgs, error) {
  var result types.SignalCgroupRmdirArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.SignalCgroupRmdirArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'SignalCgroupRmdir': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.SignalCgroupRmdirArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint64(&result.CgroupId)
      if err != nil {
        return types.SignalCgroupRmdirArgs{}, err
      }
    case 1:
      result.CgroupPath, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.SignalCgroupRmdirArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.HierarchyId)
      if err != nil {
        return types.SignalCgroupRmdirArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseNetFlowBaseArgs(log *logging.Logger, decoder *Decoder) (types.NetFlowBaseArgs, error) {
  var result types.NetFlowBaseArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.NetFlowBaseArgs{}, err
  }

  if numArgs != 7 {
    log.Warnf("unexpected number of args received when parsing 'NetFlowBase': wanted 7, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.NetFlowBaseArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeUint8(&result.Proto)
      if err != nil {
        return types.NetFlowBaseArgs{}, err
      }
    case 1:
      err = decoder.DecodeUint8(&result.Direction)
      if err != nil {
        return types.NetFlowBaseArgs{}, err
      }
    case 2:
      result.Tuple, err = decoder.ReadAddrTuple()
      if err != nil {
        return types.NetFlowBaseArgs{}, err
      }
    case 3:
      err = decoder.DecodeUint64(&result.TxBytes)
      if err != nil {
        return types.NetFlowBaseArgs{}, err
      }
    case 4:
      err = decoder.DecodeUint64(&result.RxBytes)
      if err != nil {
        return types.NetFlowBaseArgs{}, err
      }
    case 5:
      err = decoder.DecodeUint64(&result.TxPackets)
      if err != nil {
        return types.NetFlowBaseArgs{}, err
      }
    case 6:
      err = decoder.DecodeUint64(&result.RxPackets)
      if err != nil {
        return types.NetFlowBaseArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseArgs(log *logging.Logger, decoder *Decoder, event events.ID) (types.Args, error) {
  switch event {
  case events.Read:
    return ParseReadArgs(log, decoder)
  case events.Write:
    return ParseWriteArgs(log, decoder)
  case events.Open:
    return ParseOpenArgs(log, decoder)
  case events.Close:
    return ParseCloseArgs(log, decoder)
  case events.Stat:
    return ParseStatArgs(log, decoder)
  case events.Fstat:
    return ParseFstatArgs(log, decoder)
  case events.Lstat:
    return ParseLstatArgs(log, decoder)
  case events.Poll:
    return ParsePollArgs(log, decoder)
  case events.Lseek:
    return ParseLseekArgs(log, decoder)
  case events.Mmap:
    return ParseMmapArgs(log, decoder)
  case events.Mprotect:
    return ParseMprotectArgs(log, decoder)
  case events.Munmap:
    return ParseMunmapArgs(log, decoder)
  case events.Brk:
    return ParseBrkArgs(log, decoder)
  case events.RtSigaction:
    return ParseRtSigactionArgs(log, decoder)
  case events.RtSigprocmask:
    return ParseRtSigprocmaskArgs(log, decoder)
  case events.RtSigreturn:
    return ParseRtSigreturnArgs(log, decoder)
  case events.Ioctl:
    return ParseIoctlArgs(log, decoder)
  case events.Pread64:
    return ParsePread64Args(log, decoder)
  case events.Pwrite64:
    return ParsePwrite64Args(log, decoder)
  case events.Readv:
    return ParseReadvArgs(log, decoder)
  case events.Writev:
    return ParseWritevArgs(log, decoder)
  case events.Access:
    return ParseAccessArgs(log, decoder)
  case events.Pipe:
    return ParsePipeArgs(log, decoder)
  case events.Select:
    return ParseSelectArgs(log, decoder)
  case events.SchedYield:
    return ParseSchedYieldArgs(log, decoder)
  case events.Mremap:
    return ParseMremapArgs(log, decoder)
  case events.Msync:
    return ParseMsyncArgs(log, decoder)
  case events.Mincore:
    return ParseMincoreArgs(log, decoder)
  case events.Madvise:
    return ParseMadviseArgs(log, decoder)
  case events.Shmget:
    return ParseShmgetArgs(log, decoder)
  case events.Shmat:
    return ParseShmatArgs(log, decoder)
  case events.Shmctl:
    return ParseShmctlArgs(log, decoder)
  case events.Dup:
    return ParseDupArgs(log, decoder)
  case events.Dup2:
    return ParseDup2Args(log, decoder)
  case events.Pause:
    return ParsePauseArgs(log, decoder)
  case events.Nanosleep:
    return ParseNanosleepArgs(log, decoder)
  case events.Getitimer:
    return ParseGetitimerArgs(log, decoder)
  case events.Alarm:
    return ParseAlarmArgs(log, decoder)
  case events.Setitimer:
    return ParseSetitimerArgs(log, decoder)
  case events.Getpid:
    return ParseGetpidArgs(log, decoder)
  case events.Sendfile:
    return ParseSendfileArgs(log, decoder)
  case events.Socket:
    return ParseSocketArgs(log, decoder)
  case events.Connect:
    return ParseConnectArgs(log, decoder)
  case events.Accept:
    return ParseAcceptArgs(log, decoder)
  case events.Sendto:
    return ParseSendtoArgs(log, decoder)
  case events.Recvfrom:
    return ParseRecvfromArgs(log, decoder)
  case events.Sendmsg:
    return ParseSendmsgArgs(log, decoder)
  case events.Recvmsg:
    return ParseRecvmsgArgs(log, decoder)
  case events.Shutdown:
    return ParseShutdownArgs(log, decoder)
  case events.Bind:
    return ParseBindArgs(log, decoder)
  case events.Listen:
    return ParseListenArgs(log, decoder)
  case events.Getsockname:
    return ParseGetsocknameArgs(log, decoder)
  case events.Getpeername:
    return ParseGetpeernameArgs(log, decoder)
  case events.Socketpair:
    return ParseSocketpairArgs(log, decoder)
  case events.Setsockopt:
    return ParseSetsockoptArgs(log, decoder)
  case events.Getsockopt:
    return ParseGetsockoptArgs(log, decoder)
  case events.Clone:
    return ParseCloneArgs(log, decoder)
  case events.Fork:
    return ParseForkArgs(log, decoder)
  case events.Vfork:
    return ParseVforkArgs(log, decoder)
  case events.Execve:
    return ParseExecveArgs(log, decoder)
  case events.Exit:
    return ParseExitArgs(log, decoder)
  case events.Wait4:
    return ParseWait4Args(log, decoder)
  case events.Kill:
    return ParseKillArgs(log, decoder)
  case events.Uname:
    return ParseUnameArgs(log, decoder)
  case events.Semget:
    return ParseSemgetArgs(log, decoder)
  case events.Semop:
    return ParseSemopArgs(log, decoder)
  case events.Semctl:
    return ParseSemctlArgs(log, decoder)
  case events.Shmdt:
    return ParseShmdtArgs(log, decoder)
  case events.Msgget:
    return ParseMsggetArgs(log, decoder)
  case events.Msgsnd:
    return ParseMsgsndArgs(log, decoder)
  case events.Msgrcv:
    return ParseMsgrcvArgs(log, decoder)
  case events.Msgctl:
    return ParseMsgctlArgs(log, decoder)
  case events.Fcntl:
    return ParseFcntlArgs(log, decoder)
  case events.Flock:
    return ParseFlockArgs(log, decoder)
  case events.Fsync:
    return ParseFsyncArgs(log, decoder)
  case events.Fdatasync:
    return ParseFdatasyncArgs(log, decoder)
  case events.Truncate:
    return ParseTruncateArgs(log, decoder)
  case events.Ftruncate:
    return ParseFtruncateArgs(log, decoder)
  case events.Getdents:
    return ParseGetdentsArgs(log, decoder)
  case events.Getcwd:
    return ParseGetcwdArgs(log, decoder)
  case events.Chdir:
    return ParseChdirArgs(log, decoder)
  case events.Fchdir:
    return ParseFchdirArgs(log, decoder)
  case events.Rename:
    return ParseRenameArgs(log, decoder)
  case events.Mkdir:
    return ParseMkdirArgs(log, decoder)
  case events.Rmdir:
    return ParseRmdirArgs(log, decoder)
  case events.Creat:
    return ParseCreatArgs(log, decoder)
  case events.Link:
    return ParseLinkArgs(log, decoder)
  case events.Unlink:
    return ParseUnlinkArgs(log, decoder)
  case events.Symlink:
    return ParseSymlinkArgs(log, decoder)
  case events.Readlink:
    return ParseReadlinkArgs(log, decoder)
  case events.Chmod:
    return ParseChmodArgs(log, decoder)
  case events.Fchmod:
    return ParseFchmodArgs(log, decoder)
  case events.Chown:
    return ParseChownArgs(log, decoder)
  case events.Fchown:
    return ParseFchownArgs(log, decoder)
  case events.Lchown:
    return ParseLchownArgs(log, decoder)
  case events.Umask:
    return ParseUmaskArgs(log, decoder)
  case events.Gettimeofday:
    return ParseGettimeofdayArgs(log, decoder)
  case events.Getrlimit:
    return ParseGetrlimitArgs(log, decoder)
  case events.Getrusage:
    return ParseGetrusageArgs(log, decoder)
  case events.Sysinfo:
    return ParseSysinfoArgs(log, decoder)
  case events.Times:
    return ParseTimesArgs(log, decoder)
  case events.Ptrace:
    return ParsePtraceArgs(log, decoder)
  case events.Getuid:
    return ParseGetuidArgs(log, decoder)
  case events.Syslog:
    return ParseSyslogArgs(log, decoder)
  case events.Getgid:
    return ParseGetgidArgs(log, decoder)
  case events.Setuid:
    return ParseSetuidArgs(log, decoder)
  case events.Setgid:
    return ParseSetgidArgs(log, decoder)
  case events.Geteuid:
    return ParseGeteuidArgs(log, decoder)
  case events.Getegid:
    return ParseGetegidArgs(log, decoder)
  case events.Setpgid:
    return ParseSetpgidArgs(log, decoder)
  case events.Getppid:
    return ParseGetppidArgs(log, decoder)
  case events.Getpgrp:
    return ParseGetpgrpArgs(log, decoder)
  case events.Setsid:
    return ParseSetsidArgs(log, decoder)
  case events.Setreuid:
    return ParseSetreuidArgs(log, decoder)
  case events.Setregid:
    return ParseSetregidArgs(log, decoder)
  case events.Getgroups:
    return ParseGetgroupsArgs(log, decoder)
  case events.Setgroups:
    return ParseSetgroupsArgs(log, decoder)
  case events.Setresuid:
    return ParseSetresuidArgs(log, decoder)
  case events.Getresuid:
    return ParseGetresuidArgs(log, decoder)
  case events.Setresgid:
    return ParseSetresgidArgs(log, decoder)
  case events.Getresgid:
    return ParseGetresgidArgs(log, decoder)
  case events.Getpgid:
    return ParseGetpgidArgs(log, decoder)
  case events.Setfsuid:
    return ParseSetfsuidArgs(log, decoder)
  case events.Setfsgid:
    return ParseSetfsgidArgs(log, decoder)
  case events.Getsid:
    return ParseGetsidArgs(log, decoder)
  case events.Capget:
    return ParseCapgetArgs(log, decoder)
  case events.Capset:
    return ParseCapsetArgs(log, decoder)
  case events.RtSigpending:
    return ParseRtSigpendingArgs(log, decoder)
  case events.RtSigtimedwait:
    return ParseRtSigtimedwaitArgs(log, decoder)
  case events.RtSigqueueinfo:
    return ParseRtSigqueueinfoArgs(log, decoder)
  case events.RtSigsuspend:
    return ParseRtSigsuspendArgs(log, decoder)
  case events.Sigaltstack:
    return ParseSigaltstackArgs(log, decoder)
  case events.Utime:
    return ParseUtimeArgs(log, decoder)
  case events.Mknod:
    return ParseMknodArgs(log, decoder)
  case events.Uselib:
    return ParseUselibArgs(log, decoder)
  case events.Personality:
    return ParsePersonalityArgs(log, decoder)
  case events.Ustat:
    return ParseUstatArgs(log, decoder)
  case events.Statfs:
    return ParseStatfsArgs(log, decoder)
  case events.Fstatfs:
    return ParseFstatfsArgs(log, decoder)
  case events.Sysfs:
    return ParseSysfsArgs(log, decoder)
  case events.Getpriority:
    return ParseGetpriorityArgs(log, decoder)
  case events.Setpriority:
    return ParseSetpriorityArgs(log, decoder)
  case events.SchedSetparam:
    return ParseSchedSetparamArgs(log, decoder)
  case events.SchedGetparam:
    return ParseSchedGetparamArgs(log, decoder)
  case events.SchedSetscheduler:
    return ParseSchedSetschedulerArgs(log, decoder)
  case events.SchedGetscheduler:
    return ParseSchedGetschedulerArgs(log, decoder)
  case events.SchedGetPriorityMax:
    return ParseSchedGetPriorityMaxArgs(log, decoder)
  case events.SchedGetPriorityMin:
    return ParseSchedGetPriorityMinArgs(log, decoder)
  case events.SchedRrGetInterval:
    return ParseSchedRrGetIntervalArgs(log, decoder)
  case events.Mlock:
    return ParseMlockArgs(log, decoder)
  case events.Munlock:
    return ParseMunlockArgs(log, decoder)
  case events.Mlockall:
    return ParseMlockallArgs(log, decoder)
  case events.Munlockall:
    return ParseMunlockallArgs(log, decoder)
  case events.Vhangup:
    return ParseVhangupArgs(log, decoder)
  case events.ModifyLdt:
    return ParseModifyLdtArgs(log, decoder)
  case events.PivotRoot:
    return ParsePivotRootArgs(log, decoder)
  case events.Sysctl:
    return ParseSysctlArgs(log, decoder)
  case events.Prctl:
    return ParsePrctlArgs(log, decoder)
  case events.ArchPrctl:
    return ParseArchPrctlArgs(log, decoder)
  case events.Adjtimex:
    return ParseAdjtimexArgs(log, decoder)
  case events.Setrlimit:
    return ParseSetrlimitArgs(log, decoder)
  case events.Chroot:
    return ParseChrootArgs(log, decoder)
  case events.Sync:
    return ParseSyncArgs(log, decoder)
  case events.Acct:
    return ParseAcctArgs(log, decoder)
  case events.Settimeofday:
    return ParseSettimeofdayArgs(log, decoder)
  case events.Mount:
    return ParseMountArgs(log, decoder)
  case events.Umount2:
    return ParseUmount2Args(log, decoder)
  case events.Swapon:
    return ParseSwaponArgs(log, decoder)
  case events.Swapoff:
    return ParseSwapoffArgs(log, decoder)
  case events.Reboot:
    return ParseRebootArgs(log, decoder)
  case events.Sethostname:
    return ParseSethostnameArgs(log, decoder)
  case events.Setdomainname:
    return ParseSetdomainnameArgs(log, decoder)
  case events.Iopl:
    return ParseIoplArgs(log, decoder)
  case events.Ioperm:
    return ParseIopermArgs(log, decoder)
  case events.CreateModule:
    return ParseCreateModuleArgs(log, decoder)
  case events.InitModule:
    return ParseInitModuleArgs(log, decoder)
  case events.DeleteModule:
    return ParseDeleteModuleArgs(log, decoder)
  case events.GetKernelSyms:
    return ParseGetKernelSymsArgs(log, decoder)
  case events.QueryModule:
    return ParseQueryModuleArgs(log, decoder)
  case events.Quotactl:
    return ParseQuotactlArgs(log, decoder)
  case events.Nfsservctl:
    return ParseNfsservctlArgs(log, decoder)
  case events.Getpmsg:
    return ParseGetpmsgArgs(log, decoder)
  case events.Putpmsg:
    return ParsePutpmsgArgs(log, decoder)
  case events.Afs:
    return ParseAfsArgs(log, decoder)
  case events.Tuxcall:
    return ParseTuxcallArgs(log, decoder)
  case events.Security:
    return ParseSecurityArgs(log, decoder)
  case events.Gettid:
    return ParseGettidArgs(log, decoder)
  case events.Readahead:
    return ParseReadaheadArgs(log, decoder)
  case events.Setxattr:
    return ParseSetxattrArgs(log, decoder)
  case events.Lsetxattr:
    return ParseLsetxattrArgs(log, decoder)
  case events.Fsetxattr:
    return ParseFsetxattrArgs(log, decoder)
  case events.Getxattr:
    return ParseGetxattrArgs(log, decoder)
  case events.Lgetxattr:
    return ParseLgetxattrArgs(log, decoder)
  case events.Fgetxattr:
    return ParseFgetxattrArgs(log, decoder)
  case events.Listxattr:
    return ParseListxattrArgs(log, decoder)
  case events.Llistxattr:
    return ParseLlistxattrArgs(log, decoder)
  case events.Flistxattr:
    return ParseFlistxattrArgs(log, decoder)
  case events.Removexattr:
    return ParseRemovexattrArgs(log, decoder)
  case events.Lremovexattr:
    return ParseLremovexattrArgs(log, decoder)
  case events.Fremovexattr:
    return ParseFremovexattrArgs(log, decoder)
  case events.Tkill:
    return ParseTkillArgs(log, decoder)
  case events.Time:
    return ParseTimeArgs(log, decoder)
  case events.Futex:
    return ParseFutexArgs(log, decoder)
  case events.SchedSetaffinity:
    return ParseSchedSetaffinityArgs(log, decoder)
  case events.SchedGetaffinity:
    return ParseSchedGetaffinityArgs(log, decoder)
  case events.SetThreadArea:
    return ParseSetThreadAreaArgs(log, decoder)
  case events.IoSetup:
    return ParseIoSetupArgs(log, decoder)
  case events.IoDestroy:
    return ParseIoDestroyArgs(log, decoder)
  case events.IoGetevents:
    return ParseIoGeteventsArgs(log, decoder)
  case events.IoSubmit:
    return ParseIoSubmitArgs(log, decoder)
  case events.IoCancel:
    return ParseIoCancelArgs(log, decoder)
  case events.GetThreadArea:
    return ParseGetThreadAreaArgs(log, decoder)
  case events.LookupDcookie:
    return ParseLookupDcookieArgs(log, decoder)
  case events.EpollCreate:
    return ParseEpollCreateArgs(log, decoder)
  case events.EpollCtlOld:
    return ParseEpollCtlOldArgs(log, decoder)
  case events.EpollWaitOld:
    return ParseEpollWaitOldArgs(log, decoder)
  case events.RemapFilePages:
    return ParseRemapFilePagesArgs(log, decoder)
  case events.Getdents64:
    return ParseGetdents64Args(log, decoder)
  case events.SetTidAddress:
    return ParseSetTidAddressArgs(log, decoder)
  case events.RestartSyscall:
    return ParseRestartSyscallArgs(log, decoder)
  case events.Semtimedop:
    return ParseSemtimedopArgs(log, decoder)
  case events.Fadvise64:
    return ParseFadvise64Args(log, decoder)
  case events.TimerCreate:
    return ParseTimerCreateArgs(log, decoder)
  case events.TimerSettime:
    return ParseTimerSettimeArgs(log, decoder)
  case events.TimerGettime:
    return ParseTimerGettimeArgs(log, decoder)
  case events.TimerGetoverrun:
    return ParseTimerGetoverrunArgs(log, decoder)
  case events.TimerDelete:
    return ParseTimerDeleteArgs(log, decoder)
  case events.ClockSettime:
    return ParseClockSettimeArgs(log, decoder)
  case events.ClockGettime:
    return ParseClockGettimeArgs(log, decoder)
  case events.ClockGetres:
    return ParseClockGetresArgs(log, decoder)
  case events.ClockNanosleep:
    return ParseClockNanosleepArgs(log, decoder)
  case events.ExitGroup:
    return ParseExitGroupArgs(log, decoder)
  case events.EpollWait:
    return ParseEpollWaitArgs(log, decoder)
  case events.EpollCtl:
    return ParseEpollCtlArgs(log, decoder)
  case events.Tgkill:
    return ParseTgkillArgs(log, decoder)
  case events.Utimes:
    return ParseUtimesArgs(log, decoder)
  case events.Vserver:
    return ParseVserverArgs(log, decoder)
  case events.Mbind:
    return ParseMbindArgs(log, decoder)
  case events.SetMempolicy:
    return ParseSetMempolicyArgs(log, decoder)
  case events.GetMempolicy:
    return ParseGetMempolicyArgs(log, decoder)
  case events.MqOpen:
    return ParseMqOpenArgs(log, decoder)
  case events.MqUnlink:
    return ParseMqUnlinkArgs(log, decoder)
  case events.MqTimedsend:
    return ParseMqTimedsendArgs(log, decoder)
  case events.MqTimedreceive:
    return ParseMqTimedreceiveArgs(log, decoder)
  case events.MqNotify:
    return ParseMqNotifyArgs(log, decoder)
  case events.MqGetsetattr:
    return ParseMqGetsetattrArgs(log, decoder)
  case events.KexecLoad:
    return ParseKexecLoadArgs(log, decoder)
  case events.Waitid:
    return ParseWaitidArgs(log, decoder)
  case events.AddKey:
    return ParseAddKeyArgs(log, decoder)
  case events.RequestKey:
    return ParseRequestKeyArgs(log, decoder)
  case events.Keyctl:
    return ParseKeyctlArgs(log, decoder)
  case events.IoprioSet:
    return ParseIoprioSetArgs(log, decoder)
  case events.IoprioGet:
    return ParseIoprioGetArgs(log, decoder)
  case events.InotifyInit:
    return ParseInotifyInitArgs(log, decoder)
  case events.InotifyAddWatch:
    return ParseInotifyAddWatchArgs(log, decoder)
  case events.InotifyRmWatch:
    return ParseInotifyRmWatchArgs(log, decoder)
  case events.MigratePages:
    return ParseMigratePagesArgs(log, decoder)
  case events.Openat:
    return ParseOpenatArgs(log, decoder)
  case events.Mkdirat:
    return ParseMkdiratArgs(log, decoder)
  case events.Mknodat:
    return ParseMknodatArgs(log, decoder)
  case events.Fchownat:
    return ParseFchownatArgs(log, decoder)
  case events.Futimesat:
    return ParseFutimesatArgs(log, decoder)
  case events.Newfstatat:
    return ParseNewfstatatArgs(log, decoder)
  case events.Unlinkat:
    return ParseUnlinkatArgs(log, decoder)
  case events.Renameat:
    return ParseRenameatArgs(log, decoder)
  case events.Linkat:
    return ParseLinkatArgs(log, decoder)
  case events.Symlinkat:
    return ParseSymlinkatArgs(log, decoder)
  case events.Readlinkat:
    return ParseReadlinkatArgs(log, decoder)
  case events.Fchmodat:
    return ParseFchmodatArgs(log, decoder)
  case events.Faccessat:
    return ParseFaccessatArgs(log, decoder)
  case events.Pselect6:
    return ParsePselect6Args(log, decoder)
  case events.Ppoll:
    return ParsePpollArgs(log, decoder)
  case events.Unshare:
    return ParseUnshareArgs(log, decoder)
  case events.SetRobustList:
    return ParseSetRobustListArgs(log, decoder)
  case events.GetRobustList:
    return ParseGetRobustListArgs(log, decoder)
  case events.Splice:
    return ParseSpliceArgs(log, decoder)
  case events.Tee:
    return ParseTeeArgs(log, decoder)
  case events.SyncFileRange:
    return ParseSyncFileRangeArgs(log, decoder)
  case events.Vmsplice:
    return ParseVmspliceArgs(log, decoder)
  case events.MovePages:
    return ParseMovePagesArgs(log, decoder)
  case events.Utimensat:
    return ParseUtimensatArgs(log, decoder)
  case events.EpollPwait:
    return ParseEpollPwaitArgs(log, decoder)
  case events.Signalfd:
    return ParseSignalfdArgs(log, decoder)
  case events.TimerfdCreate:
    return ParseTimerfdCreateArgs(log, decoder)
  case events.Eventfd:
    return ParseEventfdArgs(log, decoder)
  case events.Fallocate:
    return ParseFallocateArgs(log, decoder)
  case events.TimerfdSettime:
    return ParseTimerfdSettimeArgs(log, decoder)
  case events.TimerfdGettime:
    return ParseTimerfdGettimeArgs(log, decoder)
  case events.Accept4:
    return ParseAccept4Args(log, decoder)
  case events.Signalfd4:
    return ParseSignalfd4Args(log, decoder)
  case events.Eventfd2:
    return ParseEventfd2Args(log, decoder)
  case events.EpollCreate1:
    return ParseEpollCreate1Args(log, decoder)
  case events.Dup3:
    return ParseDup3Args(log, decoder)
  case events.Pipe2:
    return ParsePipe2Args(log, decoder)
  case events.InotifyInit1:
    return ParseInotifyInit1Args(log, decoder)
  case events.Preadv:
    return ParsePreadvArgs(log, decoder)
  case events.Pwritev:
    return ParsePwritevArgs(log, decoder)
  case events.RtTgsigqueueinfo:
    return ParseRtTgsigqueueinfoArgs(log, decoder)
  case events.PerfEventOpen:
    return ParsePerfEventOpenArgs(log, decoder)
  case events.Recvmmsg:
    return ParseRecvmmsgArgs(log, decoder)
  case events.FanotifyInit:
    return ParseFanotifyInitArgs(log, decoder)
  case events.FanotifyMark:
    return ParseFanotifyMarkArgs(log, decoder)
  case events.Prlimit64:
    return ParsePrlimit64Args(log, decoder)
  case events.NameToHandleAt:
    return ParseNameToHandleAtArgs(log, decoder)
  case events.OpenByHandleAt:
    return ParseOpenByHandleAtArgs(log, decoder)
  case events.ClockAdjtime:
    return ParseClockAdjtimeArgs(log, decoder)
  case events.Syncfs:
    return ParseSyncfsArgs(log, decoder)
  case events.Sendmmsg:
    return ParseSendmmsgArgs(log, decoder)
  case events.Setns:
    return ParseSetnsArgs(log, decoder)
  case events.Getcpu:
    return ParseGetcpuArgs(log, decoder)
  case events.ProcessVmReadv:
    return ParseProcessVmReadvArgs(log, decoder)
  case events.ProcessVmWritev:
    return ParseProcessVmWritevArgs(log, decoder)
  case events.Kcmp:
    return ParseKcmpArgs(log, decoder)
  case events.FinitModule:
    return ParseFinitModuleArgs(log, decoder)
  case events.SchedSetattr:
    return ParseSchedSetattrArgs(log, decoder)
  case events.SchedGetattr:
    return ParseSchedGetattrArgs(log, decoder)
  case events.Renameat2:
    return ParseRenameat2Args(log, decoder)
  case events.Seccomp:
    return ParseSeccompArgs(log, decoder)
  case events.Getrandom:
    return ParseGetrandomArgs(log, decoder)
  case events.MemfdCreate:
    return ParseMemfdCreateArgs(log, decoder)
  case events.KexecFileLoad:
    return ParseKexecFileLoadArgs(log, decoder)
  case events.Bpf:
    return ParseBpfArgs(log, decoder)
  case events.Execveat:
    return ParseExecveatArgs(log, decoder)
  case events.Userfaultfd:
    return ParseUserfaultfdArgs(log, decoder)
  case events.Membarrier:
    return ParseMembarrierArgs(log, decoder)
  case events.Mlock2:
    return ParseMlock2Args(log, decoder)
  case events.CopyFileRange:
    return ParseCopyFileRangeArgs(log, decoder)
  case events.Preadv2:
    return ParsePreadv2Args(log, decoder)
  case events.Pwritev2:
    return ParsePwritev2Args(log, decoder)
  case events.PkeyMprotect:
    return ParsePkeyMprotectArgs(log, decoder)
  case events.PkeyAlloc:
    return ParsePkeyAllocArgs(log, decoder)
  case events.PkeyFree:
    return ParsePkeyFreeArgs(log, decoder)
  case events.Statx:
    return ParseStatxArgs(log, decoder)
  case events.IoPgetevents:
    return ParseIoPgeteventsArgs(log, decoder)
  case events.Rseq:
    return ParseRseqArgs(log, decoder)
  case events.PidfdSendSignal:
    return ParsePidfdSendSignalArgs(log, decoder)
  case events.IoUringSetup:
    return ParseIoUringSetupArgs(log, decoder)
  case events.IoUringEnter:
    return ParseIoUringEnterArgs(log, decoder)
  case events.IoUringRegister:
    return ParseIoUringRegisterArgs(log, decoder)
  case events.OpenTree:
    return ParseOpenTreeArgs(log, decoder)
  case events.MoveMount:
    return ParseMoveMountArgs(log, decoder)
  case events.Fsopen:
    return ParseFsopenArgs(log, decoder)
  case events.Fsconfig:
    return ParseFsconfigArgs(log, decoder)
  case events.Fsmount:
    return ParseFsmountArgs(log, decoder)
  case events.Fspick:
    return ParseFspickArgs(log, decoder)
  case events.PidfdOpen:
    return ParsePidfdOpenArgs(log, decoder)
  case events.Clone3:
    return ParseClone3Args(log, decoder)
  case events.CloseRange:
    return ParseCloseRangeArgs(log, decoder)
  case events.Openat2:
    return ParseOpenat2Args(log, decoder)
  case events.PidfdGetfd:
    return ParsePidfdGetfdArgs(log, decoder)
  case events.Faccessat2:
    return ParseFaccessat2Args(log, decoder)
  case events.ProcessMadvise:
    return ParseProcessMadviseArgs(log, decoder)
  case events.EpollPwait2:
    return ParseEpollPwait2Args(log, decoder)
  case events.MountSetatt:
    return ParseMountSetattArgs(log, decoder)
  case events.QuotactlFd:
    return ParseQuotactlFdArgs(log, decoder)
  case events.LandlockCreateRuleset:
    return ParseLandlockCreateRulesetArgs(log, decoder)
  case events.LandlockAddRule:
    return ParseLandlockAddRuleArgs(log, decoder)
  case events.LandloclRestrictSet:
    return ParseLandloclRestrictSetArgs(log, decoder)
  case events.MemfdSecret:
    return ParseMemfdSecretArgs(log, decoder)
  case events.ProcessMrelease:
    return ParseProcessMreleaseArgs(log, decoder)
  case events.Waitpid:
    return ParseWaitpidArgs(log, decoder)
  case events.Oldfstat:
    return ParseOldfstatArgs(log, decoder)
  case events.Break:
    return ParseBreakArgs(log, decoder)
  case events.Oldstat:
    return ParseOldstatArgs(log, decoder)
  case events.Umount:
    return ParseUmountArgs(log, decoder)
  case events.Stime:
    return ParseStimeArgs(log, decoder)
  case events.Stty:
    return ParseSttyArgs(log, decoder)
  case events.Gtty:
    return ParseGttyArgs(log, decoder)
  case events.Nice:
    return ParseNiceArgs(log, decoder)
  case events.Ftime:
    return ParseFtimeArgs(log, decoder)
  case events.Prof:
    return ParseProfArgs(log, decoder)
  case events.Signal:
    return ParseSignalArgs(log, decoder)
  case events.Lock:
    return ParseLockArgs(log, decoder)
  case events.Mpx:
    return ParseMpxArgs(log, decoder)
  case events.Ulimit:
    return ParseUlimitArgs(log, decoder)
  case events.Oldolduname:
    return ParseOldoldunameArgs(log, decoder)
  case events.Sigaction:
    return ParseSigactionArgs(log, decoder)
  case events.Sgetmask:
    return ParseSgetmaskArgs(log, decoder)
  case events.Ssetmask:
    return ParseSsetmaskArgs(log, decoder)
  case events.Sigsuspend:
    return ParseSigsuspendArgs(log, decoder)
  case events.Sigpending:
    return ParseSigpendingArgs(log, decoder)
  case events.Oldlstat:
    return ParseOldlstatArgs(log, decoder)
  case events.Readdir:
    return ParseReaddirArgs(log, decoder)
  case events.Profil:
    return ParseProfilArgs(log, decoder)
  case events.Socketcall:
    return ParseSocketcallArgs(log, decoder)
  case events.Olduname:
    return ParseOldunameArgs(log, decoder)
  case events.Idle:
    return ParseIdleArgs(log, decoder)
  case events.Vm86old:
    return ParseVm86oldArgs(log, decoder)
  case events.Ipc:
    return ParseIpcArgs(log, decoder)
  case events.Sigreturn:
    return ParseSigreturnArgs(log, decoder)
  case events.Sigprocmask:
    return ParseSigprocmaskArgs(log, decoder)
  case events.Bdflush:
    return ParseBdflushArgs(log, decoder)
  case events.Afs_syscall:
    return ParseAfs_syscallArgs(log, decoder)
  case events.Llseek:
    return ParseLlseekArgs(log, decoder)
  case events.OldSelect:
    return ParseOldSelectArgs(log, decoder)
  case events.Vm86:
    return ParseVm86Args(log, decoder)
  case events.OldGetrlimit:
    return ParseOldGetrlimitArgs(log, decoder)
  case events.Mmap2:
    return ParseMmap2Args(log, decoder)
  case events.Truncate64:
    return ParseTruncate64Args(log, decoder)
  case events.Ftruncate64:
    return ParseFtruncate64Args(log, decoder)
  case events.Stat64:
    return ParseStat64Args(log, decoder)
  case events.Lstat64:
    return ParseLstat64Args(log, decoder)
  case events.Fstat64:
    return ParseFstat64Args(log, decoder)
  case events.Lchown16:
    return ParseLchown16Args(log, decoder)
  case events.Getuid16:
    return ParseGetuid16Args(log, decoder)
  case events.Getgid16:
    return ParseGetgid16Args(log, decoder)
  case events.Geteuid16:
    return ParseGeteuid16Args(log, decoder)
  case events.Getegid16:
    return ParseGetegid16Args(log, decoder)
  case events.Setreuid16:
    return ParseSetreuid16Args(log, decoder)
  case events.Setregid16:
    return ParseSetregid16Args(log, decoder)
  case events.Getgroups16:
    return ParseGetgroups16Args(log, decoder)
  case events.Setgroups16:
    return ParseSetgroups16Args(log, decoder)
  case events.Fchown16:
    return ParseFchown16Args(log, decoder)
  case events.Setresuid16:
    return ParseSetresuid16Args(log, decoder)
  case events.Getresuid16:
    return ParseGetresuid16Args(log, decoder)
  case events.Setresgid16:
    return ParseSetresgid16Args(log, decoder)
  case events.Getresgid16:
    return ParseGetresgid16Args(log, decoder)
  case events.Chown16:
    return ParseChown16Args(log, decoder)
  case events.Setuid16:
    return ParseSetuid16Args(log, decoder)
  case events.Setgid16:
    return ParseSetgid16Args(log, decoder)
  case events.Setfsuid16:
    return ParseSetfsuid16Args(log, decoder)
  case events.Setfsgid16:
    return ParseSetfsgid16Args(log, decoder)
  case events.Fcntl64:
    return ParseFcntl64Args(log, decoder)
  case events.Sendfile32:
    return ParseSendfile32Args(log, decoder)
  case events.Statfs64:
    return ParseStatfs64Args(log, decoder)
  case events.Fstatfs64:
    return ParseFstatfs64Args(log, decoder)
  case events.Fadvise64_64:
    return ParseFadvise64_64Args(log, decoder)
  case events.ClockGettime32:
    return ParseClockGettime32Args(log, decoder)
  case events.ClockSettime32:
    return ParseClockSettime32Args(log, decoder)
  case events.ClockAdjtime64:
    return ParseClockAdjtime64Args(log, decoder)
  case events.ClockGetresTime32:
    return ParseClockGetresTime32Args(log, decoder)
  case events.ClockNanosleepTime32:
    return ParseClockNanosleepTime32Args(log, decoder)
  case events.TimerGettime32:
    return ParseTimerGettime32Args(log, decoder)
  case events.TimerSettime32:
    return ParseTimerSettime32Args(log, decoder)
  case events.TimerfdGettime32:
    return ParseTimerfdGettime32Args(log, decoder)
  case events.TimerfdSettime32:
    return ParseTimerfdSettime32Args(log, decoder)
  case events.UtimensatTime32:
    return ParseUtimensatTime32Args(log, decoder)
  case events.Pselect6Time32:
    return ParsePselect6Time32Args(log, decoder)
  case events.PpollTime32:
    return ParsePpollTime32Args(log, decoder)
  case events.IoPgeteventsTime32:
    return ParseIoPgeteventsTime32Args(log, decoder)
  case events.RecvmmsgTime32:
    return ParseRecvmmsgTime32Args(log, decoder)
  case events.MqTimedsendTime32:
    return ParseMqTimedsendTime32Args(log, decoder)
  case events.MqTimedreceiveTime32:
    return ParseMqTimedreceiveTime32Args(log, decoder)
  case events.RtSigtimedwaitTime32:
    return ParseRtSigtimedwaitTime32Args(log, decoder)
  case events.FutexTime32:
    return ParseFutexTime32Args(log, decoder)
  case events.SchedRrGetInterval32:
    return ParseSchedRrGetInterval32Args(log, decoder)
  case events.SysEnter:
    return ParseSysEnterArgs(log, decoder)
  case events.SysExit:
    return ParseSysExitArgs(log, decoder)
  case events.SchedProcessFork:
    return ParseSchedProcessForkArgs(log, decoder)
  case events.SchedProcessExec:
    return ParseSchedProcessExecArgs(log, decoder)
  case events.SchedProcessExit:
    return ParseSchedProcessExitArgs(log, decoder)
  case events.SchedSwitch:
    return ParseSchedSwitchArgs(log, decoder)
  case events.ProcessOomKilled:
    return ParseProcessOomKilledArgs(log, decoder)
  case events.DoExit:
    return ParseDoExitArgs(log, decoder)
  case events.CapCapable:
    return ParseCapCapableArgs(log, decoder)
  case events.VfsWrite:
    return ParseVfsWriteArgs(log, decoder)
  case events.VfsWritev:
    return ParseVfsWritevArgs(log, decoder)
  case events.MemProtAlert:
    return ParseMemProtAlertArgs(log, decoder)
  case events.CommitCreds:
    return ParseCommitCredsArgs(log, decoder)
  case events.SwitchTaskNS:
    return ParseSwitchTaskNSArgs(log, decoder)
  case events.MagicWrite:
    return ParseMagicWriteArgs(log, decoder)
  case events.CgroupAttachTask:
    return ParseCgroupAttachTaskArgs(log, decoder)
  case events.CgroupMkdir:
    return ParseCgroupMkdirArgs(log, decoder)
  case events.CgroupRmdir:
    return ParseCgroupRmdirArgs(log, decoder)
  case events.SecurityFileOpen:
    return ParseSecurityFileOpenArgs(log, decoder)
  case events.SecurityInodeUnlink:
    return ParseSecurityInodeUnlinkArgs(log, decoder)
  case events.SecuritySocketCreate:
    return ParseSecuritySocketCreateArgs(log, decoder)
  case events.SecuritySocketListen:
    return ParseSecuritySocketListenArgs(log, decoder)
  case events.SecuritySocketConnect:
    return ParseSecuritySocketConnectArgs(log, decoder)
  case events.SecuritySocketAccept:
    return ParseSecuritySocketAcceptArgs(log, decoder)
  case events.SecuritySocketBind:
    return ParseSecuritySocketBindArgs(log, decoder)
  case events.SecuritySocketSetsockopt:
    return ParseSecuritySocketSetsockoptArgs(log, decoder)
  case events.SecuritySbMount:
    return ParseSecuritySbMountArgs(log, decoder)
  case events.SecurityBPF:
    return ParseSecurityBPFArgs(log, decoder)
  case events.SecurityBPFMap:
    return ParseSecurityBPFMapArgs(log, decoder)
  case events.SecurityKernelReadFile:
    return ParseSecurityKernelReadFileArgs(log, decoder)
  case events.SecurityPostReadFile:
    return ParseSecurityPostReadFileArgs(log, decoder)
  case events.SecurityInodeMknod:
    return ParseSecurityInodeMknodArgs(log, decoder)
  case events.SecurityInodeSymlinkEventId:
    return ParseSecurityInodeSymlinkEventIdArgs(log, decoder)
  case events.SecurityMmapFile:
    return ParseSecurityMmapFileArgs(log, decoder)
  case events.DoMmap:
    return ParseDoMmapArgs(log, decoder)
  case events.SecurityFileMprotect:
    return ParseSecurityFileMprotectArgs(log, decoder)
  case events.InitNamespaces:
    return ParseInitNamespacesArgs(log, decoder)
  case events.SocketDup:
    return ParseSocketDupArgs(log, decoder)
  case events.HiddenInodes:
    return ParseHiddenInodesArgs(log, decoder)
  case events.KernelWrite:
    return ParseKernelWriteArgs(log, decoder)
  case events.DirtyPipeSplice:
    return ParseDirtyPipeSpliceArgs(log, decoder)
  case events.ContainerCreate:
    return ParseContainerCreateArgs(log, decoder)
  case events.ContainerRemove:
    return ParseContainerRemoveArgs(log, decoder)
  case events.ExistingContainer:
    return ParseExistingContainerArgs(log, decoder)
  case events.ProcCreate:
    return ParseProcCreateArgs(log, decoder)
  case events.KprobeAttach:
    return ParseKprobeAttachArgs(log, decoder)
  case events.CallUsermodeHelper:
    return ParseCallUsermodeHelperArgs(log, decoder)
  case events.DebugfsCreateFile:
    return ParseDebugfsCreateFileArgs(log, decoder)
  case events.PrintSyscallTable:
    return ParsePrintSyscallTableArgs(log, decoder)
  case events.HiddenKernelModule:
    return ParseHiddenKernelModuleArgs(log, decoder)
  case events.HiddenKernelModuleSeeker:
    return ParseHiddenKernelModuleSeekerArgs(log, decoder)
  case events.HookedSyscalls:
    return ParseHookedSyscallsArgs(log, decoder)
  case events.DebugfsCreateDir:
    return ParseDebugfsCreateDirArgs(log, decoder)
  case events.DeviceAdd:
    return ParseDeviceAddArgs(log, decoder)
  case events.RegisterChrdev:
    return ParseRegisterChrdevArgs(log, decoder)
  case events.SharedObjectLoaded:
    return ParseSharedObjectLoadedArgs(log, decoder)
  case events.SymbolsLoaded:
    return ParseSymbolsLoadedArgs(log, decoder)
  case events.SymbolsCollision:
    return ParseSymbolsCollisionArgs(log, decoder)
  case events.CaptureFileWrite:
    return ParseCaptureFileWriteArgs(log, decoder)
  case events.CaptureFileRead:
    return ParseCaptureFileReadArgs(log, decoder)
  case events.CaptureExec:
    return ParseCaptureExecArgs(log, decoder)
  case events.CaptureModule:
    return ParseCaptureModuleArgs(log, decoder)
  case events.CaptureMem:
    return ParseCaptureMemArgs(log, decoder)
  case events.CaptureBpf:
    return ParseCaptureBpfArgs(log, decoder)
  case events.DoInitModule:
    return ParseDoInitModuleArgs(log, decoder)
  case events.ModuleLoad:
    return ParseModuleLoadArgs(log, decoder)
  case events.ModuleFree:
    return ParseModuleFreeArgs(log, decoder)
  case events.SocketAccept:
    return ParseSocketAcceptArgs(log, decoder)
  case events.LoadElfPhdrs:
    return ParseLoadElfPhdrsArgs(log, decoder)
  case events.PrintNetSeqOps:
    return ParsePrintNetSeqOpsArgs(log, decoder)
  case events.HookedSeqOps:
    return ParseHookedSeqOpsArgs(log, decoder)
  case events.TaskRename:
    return ParseTaskRenameArgs(log, decoder)
  case events.SecurityInodeRename:
    return ParseSecurityInodeRenameArgs(log, decoder)
  case events.DoSigaction:
    return ParseDoSigactionArgs(log, decoder)
  case events.BpfAttach:
    return ParseBpfAttachArgs(log, decoder)
  case events.KallsymsLookupName:
    return ParseKallsymsLookupNameArgs(log, decoder)
  case events.PrintMemDump:
    return ParsePrintMemDumpArgs(log, decoder)
  case events.VfsRead:
    return ParseVfsReadArgs(log, decoder)
  case events.VfsReadv:
    return ParseVfsReadvArgs(log, decoder)
  case events.VfsUtimes:
    return ParseVfsUtimesArgs(log, decoder)
  case events.DoTruncate:
    return ParseDoTruncateArgs(log, decoder)
  case events.FileModification:
    return ParseFileModificationArgs(log, decoder)
  case events.InotifyWatch:
    return ParseInotifyWatchArgs(log, decoder)
  case events.ProcessExecuteFailed:
    return ParseProcessExecuteFailedArgs(log, decoder)
  case events.TtyOpen:
    return ParseTtyOpenArgs(log, decoder)
  case events.NetPacketBase:
    return ParseNetPacketBaseArgs(log, decoder)
  case events.NetPacketIPBase:
    return ParseNetPacketIPBaseArgs(log, decoder)
  case events.NetPacketIPv4:
    return ParseNetPacketIPv4Args(log, decoder)
  case events.NetPacketIPv6:
    return ParseNetPacketIPv6Args(log, decoder)
  case events.NetPacketTCPBase:
    return ParseNetPacketTCPBaseArgs(log, decoder)
  case events.NetPacketTCP:
    return ParseNetPacketTCPArgs(log, decoder)
  case events.NetPacketUDPBase:
    return ParseNetPacketUDPBaseArgs(log, decoder)
  case events.NetPacketUDP:
    return ParseNetPacketUDPArgs(log, decoder)
  case events.NetPacketICMPBase:
    return ParseNetPacketICMPBaseArgs(log, decoder)
  case events.NetPacketICMP:
    return ParseNetPacketICMPArgs(log, decoder)
  case events.NetPacketICMPv6Base:
    return ParseNetPacketICMPv6BaseArgs(log, decoder)
  case events.NetPacketICMPv6:
    return ParseNetPacketICMPv6Args(log, decoder)
  case events.NetPacketDNSBase:
    return ParseNetPacketDNSBaseArgs(log, decoder)
  case events.NetPacketDNS:
    return ParseNetPacketDNSArgs(log, decoder)
  case events.NetPacketDNSRequest:
    return ParseNetPacketDNSRequestArgs(log, decoder)
  case events.NetPacketDNSResponse:
    return ParseNetPacketDNSResponseArgs(log, decoder)
  case events.NetPacketHTTPBase:
    return ParseNetPacketHTTPBaseArgs(log, decoder)
  case events.NetPacketHTTP:
    return ParseNetPacketHTTPArgs(log, decoder)
  case events.NetPacketHTTPRequest:
    return ParseNetPacketHTTPRequestArgs(log, decoder)
  case events.NetPacketHTTPResponse:
    return ParseNetPacketHTTPResponseArgs(log, decoder)
  case events.NetPacketSOCKS5Base:
    return ParseNetPacketSOCKS5BaseArgs(log, decoder)
  case events.NetPacketCapture:
    return ParseNetPacketCaptureArgs(log, decoder)
  case events.CaptureNetPacket:
    return ParseCaptureNetPacketArgs(log, decoder)
  case events.SockSetState:
    return ParseSockSetStateArgs(log, decoder)
  case events.TrackSyscallStats:
    return ParseTrackSyscallStatsArgs(log, decoder)
  case events.TestEvent:
    return ParseTestEventArgs(log, decoder)
  case events.SignalCgroupMkdir:
    return ParseSignalCgroupMkdirArgs(log, decoder)
  case events.SignalCgroupRmdir:
    return ParseSignalCgroupRmdirArgs(log, decoder)
  case events.NetFlowBase:
    return ParseNetFlowBaseArgs(log, decoder)
  }

  return nil, ErrUnknownArgsType
}
