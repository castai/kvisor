package main

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestTypeCodeGenerator(t *testing.T) {
	type testCase struct {
		title             string
		definitions       []eventDefinition
		expectedTypesCode string
		expectError       bool
	}

	testCases := []testCase{
		{
			title: "base case",
			definitions: []eventDefinition{
				{
					event: "Read",
					params: []param{
						{name: "fd", paramType: intT},
						{name: "buf", paramType: pointerT},
						{name: "count", paramType: sizeT},
					},
				},
				{
					event: "Open",
					params: []param{
						{name: "pathname", paramType: strT},
						{name: "flags", paramType: intT},
						{name: "mode", paramType: modeT},
					},
				},
			},
			expectedTypesCode: `// Code generated by tools/codegen; DO NOT EDIT.

package types

type Args interface {
  args()
}

// internalArgs is a marker type to distinguish Args interface from basically any
type internalArgs struct{}

func (c internalArgs) args() {}

type ReadArgs struct {
  internalArgs

  Fd int32
  Buf uintptr
  Count uint64
}

type OpenArgs struct {
  internalArgs

  Pathname string
  Flags int32
  Mode uint32
}
`,
			expectError: false,
		},

		{
			title: "should fail on unknown param type",
			definitions: []eventDefinition{
				{
					event: "Read",
					params: []param{
						{name: "the_fd", paramType: ArgType(255)},
					},
				},
			},
			expectError: true,
		},

		{
			title: "handle complex parameter names",
			definitions: []eventDefinition{
				{
					event: "ReadTHEThing",
					params: []param{
						{name: "the_fd", paramType: intT},
						{name: "buf.nr.1", paramType: pointerT},
						{name: "count", paramType: sizeT},
					},
				},
			},
			expectedTypesCode: `// Code generated by tools/codegen; DO NOT EDIT.

package types

type Args interface {
  args()
}

// internalArgs is a marker type to distinguish Args interface from basically any
type internalArgs struct{}

func (c internalArgs) args() {}

type ReadTHEThingArgs struct {
  internalArgs

  TheFd int32
  BufNr1 uintptr
  Count uint64
}
`,
			expectError: false,
		},
	}

	for _, test := range testCases {
		t.Run(test.title, func(t *testing.T) {
			r := require.New(t)

			result, err := generateTypes(test.definitions)
			if test.expectError {
				r.Error(err)
				return
			}

			r.Equal(test.expectedTypesCode, result)
		})
	}
}

func TestParserCodeGenerator(t *testing.T) {
	type testCase struct {
		title        string
		definitions  []eventDefinition
		packageName  string
		expectedCode string
		expectError  bool
	}

	testCases := []testCase{
		{
			title:       "base case",
			packageName: "parser",
			definitions: []eventDefinition{
				{
					event: "Read",
					params: []param{
						{name: "fd", paramType: intT},
						{name: "buf", paramType: pointerT},
						{name: "count", paramType: sizeT},
					},
				},
				{
					event: "Open",
					params: []param{
						{name: "pathname", paramType: strT},
						{name: "flags", paramType: intT},
						{name: "mode", paramType: modeT},
					},
				},
			},
			expectedCode: `// Code generated by tools/codegen; DO NOT EDIT.

package parser

import (
  "errors"

  "github.com/castai/kvisor/pkg/ebpftracer/events"
  "github.com/castai/kvisor/pkg/ebpftracer/types"
  "github.com/castai/kvisor/pkg/logging"
)

var (
  ErrUnknownArgsType error = errors.New("unknown args type")
)

// eventMaxByteSliceBufferSize is used to determine the max slice size allowed for different
// event types. For example, most events have a max size of 4096, but for network related events
// there is no max size (this is represented as -1).
func eventMaxByteSliceBufferSize(id events.ID) int {
  // For non network event, we have a max byte slice size of 4096
  if id < events.NetPacketBase || id > events.MaxNetID {
    return 4096
  }

  // Network events do not have a max buffer size.
  return -1
}

func ParseReadArgs(log *logging.Logger, decoder *Decoder) (types.ReadArgs, error) {
  var result types.ReadArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ReadArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'ReadArgs': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ReadArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.ReadArgs{}, err
      }
    case 1:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.ReadArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    case 2:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.ReadArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseOpenArgs(log *logging.Logger, decoder *Decoder) (types.OpenArgs, error) {
  var result types.OpenArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OpenArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'OpenArgs': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OpenArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.OpenArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.OpenArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.OpenArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseArgs(log *logging.Logger, decoder *Decoder, event events.ID) (types.Args, error) {
  switch event {
  case events.Read:
    return ParseReadArgs(log, decoder)
  case events.Open:
    return ParseOpenArgs(log, decoder)
  }

  return nil, ErrUnknownArgsType
}
`,
			expectError: false,
		},

		{
			title:       "should fail on unknown param type",
			packageName: "parser",
			definitions: []eventDefinition{
				{
					event: "Read",
					params: []param{
						{name: "the_fd", paramType: ArgType(255)},
					},
				},
			},
			expectError: true,
		},

		{
			title:       "handle complex parameter names",
			packageName: "parser",
			definitions: []eventDefinition{
				{
					event: "ReadTHEThing",
					params: []param{
						{name: "the_fd", paramType: intT},
						{name: "buf.nr.1", paramType: pointerT},
						{name: "count", paramType: sizeT},
					},
				},
			},
			expectedCode: `// Code generated by tools/codegen; DO NOT EDIT.

package parser

import (
  "errors"

  "github.com/castai/kvisor/pkg/ebpftracer/events"
  "github.com/castai/kvisor/pkg/ebpftracer/types"
  "github.com/castai/kvisor/pkg/logging"
)

var (
  ErrUnknownArgsType error = errors.New("unknown args type")
)

// eventMaxByteSliceBufferSize is used to determine the max slice size allowed for different
// event types. For example, most events have a max size of 4096, but for network related events
// there is no max size (this is represented as -1).
func eventMaxByteSliceBufferSize(id events.ID) int {
  // For non network event, we have a max byte slice size of 4096
  if id < events.NetPacketBase || id > events.MaxNetID {
    return 4096
  }

  // Network events do not have a max buffer size.
  return -1
}

func ParseReadTHEThingArgs(log *logging.Logger, decoder *Decoder) (types.ReadTHEThingArgs, error) {
  var result types.ReadTHEThingArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ReadTHEThingArgs{}, err
  }

  if numArgs != 3 {
    log.Warnf("unexpected number of args received when parsing 'ReadTHEThingArgs': wanted 3, got %d", numArgs)
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ReadTHEThingArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.TheFd)
      if err != nil {
        return types.ReadTHEThingArgs{}, err
      }
    case 1:
      var dataBufNr1 uint64
      err = decoder.DecodeUint64(&dataBufNr1)
      if err != nil {
        return types.ReadTHEThingArgs{}, err
      }
      result.BufNr1 = uintptr(dataBufNr1)
    case 2:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.ReadTHEThingArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseArgs(log *logging.Logger, decoder *Decoder, event events.ID) (types.Args, error) {
  switch event {
  case events.ReadTHEThing:
    return ParseReadTHEThingArgs(log, decoder)
  }

  return nil, ErrUnknownArgsType
}
`,
			expectError: false,
		},
	}

	for _, test := range testCases {
		t.Run(test.title, func(t *testing.T) {
			r := require.New(t)

			result, err := generateParsers(test.packageName, test.definitions)
			if test.expectError {
				r.Error(err)
				return
			}

			r.Equal(test.expectedCode, result)
		})
	}
}
