package main

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestTypeCodeGenerator(t *testing.T) {
	type testCase struct {
		title             string
		definitions       []eventDefinition
		expectedTypesCode string
		expectError       bool
	}

	testCases := []testCase{
		{
			title: "base case",
			definitions: []eventDefinition{
				{
					event: "Read",
					params: []param{
						{name: "fd", paramType: intT},
						{name: "buf", paramType: pointerT},
						{name: "count", paramType: sizeT},
					},
				},
				{
					event: "Open",
					params: []param{
						{name: "pathname", paramType: strT},
						{name: "flags", paramType: intT},
						{name: "mode", paramType: modeT},
					},
				},
			},
			expectedTypesCode: `// Code generated by tools/codegen; DO NOT EDIT.

package types

type Args interface {
  args()
}

// internalArgs is a marker type to distinguish Args interface from basically any
type internalArgs struct{}

func (c internalArgs) args() {}

type ReadArgs struct {
  internalArgs

  Fd int32
  Buf uintptr
  Count uint64
}

type OpenArgs struct {
  internalArgs

  Pathname string
  Flags int32
  Mode uint32
}
`,
			expectError: false,
		},

		{
			title: "should fail on unknown param type",
			definitions: []eventDefinition{
				{
					event: "Read",
					params: []param{
						{name: "the_fd", paramType: ArgType(255)},
					},
				},
			},
			expectError: true,
		},

		{
			title: "handle complex parameter names",
			definitions: []eventDefinition{
				{
					event: "ReadTHEThing",
					params: []param{
						{name: "the_fd", paramType: intT},
						{name: "buf.nr.1", paramType: pointerT},
						{name: "count", paramType: sizeT},
					},
				},
			},
			expectedTypesCode: `// Code generated by tools/codegen; DO NOT EDIT.

package types

type Args interface {
  args()
}

// internalArgs is a marker type to distinguish Args interface from basically any
type internalArgs struct{}

func (c internalArgs) args() {}

type ReadTHEThingArgs struct {
  internalArgs

  TheFd int32
  BufNr1 uintptr
  Count uint64
}
`,
			expectError: false,
		},
	}

	for _, test := range testCases {
		t.Run(test.title, func(t *testing.T) {
			r := require.New(t)

			result, err := generateTypes(test.definitions)
			if test.expectError {
				r.Error(err)
				return
			}

			r.Equal(test.expectedTypesCode, result)
		})
	}
}

func TestParserCodeGenerator(t *testing.T) {
	type testCase struct {
		title        string
		definitions  []eventDefinition
		packageName  string
		expectedCode string
		expectError  bool
	}

	testCases := []testCase{
		{
			title:       "base case",
			packageName: "parser",
			definitions: []eventDefinition{
				{
					event: "Read",
					params: []param{
						{name: "fd", paramType: intT},
						{name: "buf", paramType: pointerT},
						{name: "count", paramType: sizeT},
					},
				},
				{
					event: "Open",
					params: []param{
						{name: "pathname", paramType: strT},
						{name: "flags", paramType: intT},
						{name: "mode", paramType: modeT},
					},
				},
			},
			expectedCode: `// Code generated by tools/codegen; DO NOT EDIT.

package parser

import (
  "github.com/castai/kvisor/pkg/ebpftracer/events"
  "github.com/castai/kvisor/pkg/ebpftracer/types"
)

func ParseReadArgs(decoder *Decoder) (types.ReadArgs, error) {
  var result types.ReadArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ReadArgs{}, err
  }
  if numArgs > 3 {
    return types.ReadArgs{}, ErrTooManyArguments
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ReadArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.Fd)
      if err != nil {
        return types.ReadArgs{}, err
      }
    case 1:
      var dataBuf uint64
      err = decoder.DecodeUint64(&dataBuf)
      if err != nil {
        return types.ReadArgs{}, err
      }
      result.Buf = uintptr(dataBuf)
    case 2:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.ReadArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseOpenArgs(decoder *Decoder) (types.OpenArgs, error) {
  var result types.OpenArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.OpenArgs{}, err
  }
  if numArgs > 3 {
    return types.OpenArgs{}, ErrTooManyArguments
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.OpenArgs{}, err
    }

    switch currArg {
    case 0:
      result.Pathname, err = decoder.ReadStringFromBuff()
      if err != nil {
        return types.OpenArgs{}, err
      }
    case 1:
      err = decoder.DecodeInt32(&result.Flags)
      if err != nil {
        return types.OpenArgs{}, err
      }
    case 2:
      err = decoder.DecodeUint32(&result.Mode)
      if err != nil {
        return types.OpenArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseArgs(decoder *Decoder, event events.ID) (types.Args, error) {
  switch event {
  case events.Read:
    return ParseReadArgs(decoder)
  case events.Open:
    return ParseOpenArgs(decoder)
  }

  return nil, ErrUnknownArgsType
}
`,
			expectError: false,
		},

		{
			title:       "should fail on unknown param type",
			packageName: "parser",
			definitions: []eventDefinition{
				{
					event: "Read",
					params: []param{
						{name: "the_fd", paramType: ArgType(255)},
					},
				},
			},
			expectError: true,
		},

		{
			title:       "handle complex parameter names",
			packageName: "parser",
			definitions: []eventDefinition{
				{
					event: "ReadTHEThing",
					params: []param{
						{name: "the_fd", paramType: intT},
						{name: "buf.nr.1", paramType: pointerT},
						{name: "count", paramType: sizeT},
					},
				},
			},
			expectedCode: `// Code generated by tools/codegen; DO NOT EDIT.

package parser

import (
  "github.com/castai/kvisor/pkg/ebpftracer/events"
  "github.com/castai/kvisor/pkg/ebpftracer/types"
)

func ParseReadTHEThingArgs(decoder *Decoder) (types.ReadTHEThingArgs, error) {
  var result types.ReadTHEThingArgs
  var err error

  var numArgs uint8
  err = decoder.DecodeUint8(&numArgs)
  if err != nil {
    return types.ReadTHEThingArgs{}, err
  }
  if numArgs > 3 {
    return types.ReadTHEThingArgs{}, ErrTooManyArguments
  }

  for arg := 0; arg < int(numArgs); arg++ {
    var currArg uint8
    err = decoder.DecodeUint8(&currArg)
    if err != nil {
      return types.ReadTHEThingArgs{}, err
    }

    switch currArg {
    case 0:
      err = decoder.DecodeInt32(&result.TheFd)
      if err != nil {
        return types.ReadTHEThingArgs{}, err
      }
    case 1:
      var dataBufNr1 uint64
      err = decoder.DecodeUint64(&dataBufNr1)
      if err != nil {
        return types.ReadTHEThingArgs{}, err
      }
      result.BufNr1 = uintptr(dataBufNr1)
    case 2:
      err = decoder.DecodeUint64(&result.Count)
      if err != nil {
        return types.ReadTHEThingArgs{}, err
      }
    }
  }
  return result, nil
}

func ParseArgs(decoder *Decoder, event events.ID) (types.Args, error) {
  switch event {
  case events.ReadTHEThing:
    return ParseReadTHEThingArgs(decoder)
  }

  return nil, ErrUnknownArgsType
}
`,
			expectError: false,
		},
	}

	for _, test := range testCases {
		t.Run(test.title, func(t *testing.T) {
			r := require.New(t)

			result, err := generateParsers(test.packageName, test.definitions)
			if test.expectError {
				r.Error(err)
				return
			}

			r.Equal(test.expectedCode, result)
		})
	}
}
