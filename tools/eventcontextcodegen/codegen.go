package main

import (
	"fmt"
	"os"
	"reflect"
	"strings"
)

const fileSkeleton = `// Code generated by eventcontextcodegen; DO NOT EDIT.
%s

package decoder

import (
	"encoding/binary"
	"fmt"

	"github.com/castai/kvisor/pkg/ebpftracer/events"
	"github.com/castai/kvisor/pkg/ebpftracer/types"
)

%s

func EventContextSize() int {
	return %d
}
`

const decodeContextFuncSkeleton = `// DecodeContext translates data from the decoder buffer, starting from the decoder cursor, to bufferdecoder.eventContext struct.
func (decoder *Decoder) DecodeContext(ctx *types.EventContext) error {
	offset := decoder.cursor

	if len(decoder.buffer[offset:]) < EventContextSize() {
		return fmt.Errorf("context buffer size [%%d] smaller than %%d", len(decoder.buffer[offset:]), EventContextSize())
	}

%s
	decoder.cursor += EventContextSize()
	return nil
}
`

func generateParserCode(eventContext eventContextDefinition, targetContext targetContextDefinition, targetFile string, arch string) error {
	m, err := generateDecoderMethod(eventContext, targetContext)
	if err != nil {
		return err
	}
	code := fmt.Sprintf(fileSkeleton, generateBuildTag(arch), m, eventContext.totalSize())

	return os.WriteFile(targetFile, []byte(code), 0666)
}

func generateBuildTag(arch string) string {
	switch arch {
	case "arm64":
		return "//go:build 386 || amd64"
	case "x86":
		return "//go:build arm64"
	}

	fmt.Printf("unknown build tag: %s", arch)

	return ""
}

func generateDecoderMethod(eventContext eventContextDefinition, targetContext targetContextDefinition) (string, error) {
	var sink strings.Builder

	for _, tcf := range targetContext.fields {
		sourceField, offset, err := findSourceWithByteOffset(eventContext, tcf.source)
		if err != nil {
			return "", err
		}

		code, err := generateFieldParsingCode(tcf, sourceField, offset)
		if err != nil {
			return "", err
		}

		_ = must(sink.WriteString("\t"))
		_ = must(sink.WriteString(code))
		_ = must(sink.WriteString("\n"))
	}

	return fmt.Sprintf(decodeContextFuncSkeleton, sink.String()), nil
}

func must[T any](val T, err error) T {
	if err != nil {
		panic(err)
	}

	return val
}

func generateFieldParsingCode(targetField targetContextField, sourceField contextField, offset uint64) (string, error) {
  // NOTE(patrick.pichler): The generator is trusting that the source field and target field are
  // compatible. In the future, we could enfore it via a check, but for now it is good enough.
	switch field := targetField.fieldType.(type) {
	case uint16FieldType:
		return fmt.Sprintf("ctx.%s = binary.LittleEndian.Uint16(decoder.buffer[offset+%d : offset+%d])",
			targetField.name, offset, offset+sourceField.fieldType.sizeInBytes()), nil
	case arrayFieldType:
		return fmt.Sprintf("_ = copy(ctx.%s[:], decoder.buffer[%d:%d])",
			targetField.name, offset, offset+sourceField.fieldType.sizeInBytes()), nil
	case int32FieldType:
		return fmt.Sprintf("ctx.%s = int32(binary.LittleEndian.Uint32(decoder.buffer[offset+%d : offset+%d]))",
			targetField.name, offset, offset+sourceField.fieldType.sizeInBytes()), nil
	case int64FieldType:
		return fmt.Sprintf("ctx.%s = int64(binary.LittleEndian.Uint64(decoder.buffer[offset+%d : offset+%d]))",
			targetField.name, offset, offset+sourceField.fieldType.sizeInBytes()), nil
	case int8FieldType:
		return fmt.Sprintf("ctx.%s = decoder.buffer[offset+%d]", targetField.name, offset), nil
	case uint32FieldType:
		return fmt.Sprintf("ctx.%s = binary.LittleEndian.Uint32(decoder.buffer[offset+%d : offset+%d])",
			targetField.name, offset, offset+sourceField.fieldType.sizeInBytes()), nil
	case uint64FieldType:
		return fmt.Sprintf("ctx.%s = binary.LittleEndian.Uint64(decoder.buffer[offset+%d : offset+%d])",
			targetField.name, offset, offset+sourceField.fieldType.sizeInBytes()), nil
	case eventIDFieldType:
		if _, ok := sourceField.fieldType.(uint32FieldType); !ok {
			return "", fmt.Errorf("expacted uint32, but got %s", reflect.TypeOf(sourceField.fieldType))
		}

		return fmt.Sprintf("ctx.%s = events.ID(binary.LittleEndian.Uint32(decoder.buffer[offset+%d : offset+%d]))",
			targetField.name, offset, offset+sourceField.fieldType.sizeInBytes()), nil
	default:
		return "", fmt.Errorf("unexpected main.fieldType: %#v", field)
	}
}

func findSourceWithByteOffset(eventContext eventContextDefinition, source string) (contextField, uint64, error) {
	var currentOffset uint64 = 0

	for _, cf := range eventContext.fields {
		if cf.name == source {
			return cf, currentOffset, nil
		}

		currentOffset += cf.fieldType.sizeInBytes()
	}

	return contextField{}, 0, fmt.Errorf("field `%s` not found", source)
}
